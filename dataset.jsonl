{"lang": "python", "code": "def post_review ( session , review ) : # POST /api/projects/0.1/reviews/ <mask> = make_post_request ( session , 'reviews' , json_data = review ) json_data = response . json ( ) if response . status_code == 200 : return json_data [ 'status' ] else : raise ReviewNotPostedException ( message = json_data [ 'message' ] , error_code = json_data [ 'error_code' ] , request_id = json_data [ 'request_id' ] )", "comment": "Post a review"}
{"lang": "python", "code": "def command ( cmd , shell = True , echo = True , suffix = None ) : if env ( ) : cij . <mask> ( \"cij.ssh.command: Invalid SSH environment\" ) return 1 prefix = [ ] if cij . ENV . get ( \"SSH_CMD_TIME\" ) == \"1\" : prefix . append ( \"/usr/bin/time\" ) if cij . ENV . get ( \"SSH_CMD_TIMEOUT\" ) : prefix . append ( \"timeout\" ) prefix . append ( cij . ENV . get ( \"SSH_CMD_TIMEOUT\" ) ) prefix . append ( \"ssh\" ) args = [ ] if cij . ENV . get ( \"SSH_KEY\" ) : args . append ( \"-i\" ) args . append ( cij . ENV . get ( \"SSH_KEY\" ) ) if cij . ENV . get ( \"SSH_PORT\" ) : args . append ( \"-p\" ) args . append ( cij . ENV . get ( \"SSH_PORT\" ) ) args . append ( \"@\" . join ( [ cij . ENV . get ( \"SSH_USER\" ) , cij . ENV . get ( \"SSH_HOST\" ) ] ) ) wrapped = prefix + args + [ \"'%s'\" % \" \" . join ( cmd ) ] if suffix : wrapped += suffix return cij . util . execute ( wrapped , shell , echo )", "comment": "SSH : Run the given command over SSH as defined in environment"}
{"lang": "python", "code": "def parse_line ( self , line ) : if line [ 0 ] . isspace ( ) : # continuation of a multi-line header new_part = ' ' + line . lstrip ( ) self . _as_list [ self . _last_key ] [ - 1 ] += new_part dict . __setitem__ ( self , self . _last_key , self [ self . _last_key ] + new_part ) else : name , <mask> = line . split ( \":\" , 1 ) self . add ( name , value . strip ( ) )", "comment": "Updates the dictionary with a single header line ."}
{"lang": "python", "code": "def lower_transductions ( self , word , max_cost , return_cost = True ) : prefixes = [ [ ] for i <mask> range ( len ( word ) + 1 ) ] prefixes [ 0 ] . append ( ( ( ) , 0.0 ) ) for pos in range ( len ( prefixes ) ) : # \u0432\u0441\u0442\u0430\u0432\u043a\u0438 prefixes [ pos ] = self . _perform_insertions ( prefixes [ pos ] , max_cost ) max_upperside_length = min ( len ( word ) - pos , self . max_up_length ) for upperside_length in range ( 1 , max_upperside_length + 1 ) : up = word [ pos : pos + upperside_length ] for low , low_cost in self . operation_costs . get ( up , dict ( ) ) . items ( ) : for transduction , cost in prefixes [ pos ] : new_cost = cost + low_cost if new_cost <= max_cost : new_transduction = transduction + ( up , low ) prefixes [ pos + upperside_length ] . append ( ( new_transduction , new_cost ) ) answer = sorted ( prefixes [ - 1 ] , key = ( lambda x : x [ 0 ] ) ) if return_cost : return answer else : return [ elem [ 0 ] for elem in answer ]", "comment": "\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0432\u0441\u0435 \u0442\u0440\u0430\u043d\u0441\u0434\u0443\u043a\u0446\u0438\u0438 \u0441 \u0432\u0435\u0440\u0445\u043d\u0438\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u043e\u043c word \u0447\u044c\u044f \u0441\u0442\u043e\u0438\u043c\u043e\u0441\u0442\u044c \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0435\u0442 max_cost"}
{"lang": "python", "code": "def difference ( self , sig : Scope ) -> Scope : new = Scope ( sig = self . _hsig . values ( ) , state = self . <mask> ) new -= sig return new", "comment": "Create a new Set produce by a Set subtracted by another Set"}
{"lang": "python", "code": "def _sanitize_outputs ( self ) : ret = { } if self . outputs is None : return if not isinstance ( self . outputs , ( list , tuple ) ) : raise TypeError ( \"Argument to outputs must be either list or tuple, given: %s\" % str ( type ( self . outputs ) ) ) for output in self . outputs : if not isinstance ( output , ( str , Stream ) ) : raise TypeError ( \"Outputs must be a list of strings or Streams, given: %s\" % str ( output ) ) if isinstance ( output , str ) : # it's a default stream if Stream . DEFAULT_STREAM_ID not in ret : ret [ Stream . DEFAULT_STREAM_ID ] = <mask> ( ) ret [ Stream . DEFAULT_STREAM_ID ] . append ( output ) else : # output is a Stream object if output . stream_id == Stream . DEFAULT_STREAM_ID and Stream . DEFAULT_STREAM_ID in ret : # some default stream fields are already in there ret [ Stream . DEFAULT_STREAM_ID ] . extend ( output . fields ) else : ret [ output . stream_id ] = output . fields return ret", "comment": "Sanitizes output fields and returns a map <stream_id - > list of output fields >"}
{"lang": "python", "code": "def parse_mim_titles ( lines ) : header = [ 'prefix' , 'mim_number' , 'preferred_title' , 'alternative_title' , 'included_title' ] for i , line in enumerate ( lines ) : line = line . rstrip ( ) if not line . startswith ( '#' ) : parsed_entry = parse_omim_line ( line , header ) parsed_entry [ 'mim_number' ] = int ( parsed_entry [ 'mim_number' ] ) parsed_entry [ 'preferred_title' ] = parsed_entry [ 'preferred_title' ] . <mask> ( ';' ) [ 0 ] yield parsed_entry", "comment": "Parse the mimTitles . txt file This file hold information about the description for each entry in omim . There is not information about entry type . parse_mim_titles collects the preferred title and maps it to the mim number . Args : lines ( iterable ) : lines from mimTitles file Yields : parsed_entry ( dict ) { mim_number : int # The mim number for entry preferred_title : str # the preferred title for a entry }"}
{"lang": "python", "code": "def get_catfact ( ) : response = requests . get ( CAT_FACTS_URL , verify = False ) response . raise_for_status ( ) json_data = <mask> . json ( ) return json_data [ 'fact' ]", "comment": "Get a cat fact from catfact . ninja and return it as a string ."}
{"lang": "python", "code": "def clean_up ( files ) : if not isinstance ( files , list ) : <mask> = [ files ] for f in files : if os . path . exists ( f ) : bot . verbose3 ( \"Cleaning up %s\" % f ) os . remove ( f )", "comment": "clean up will delete a list of files only if they exist"}
{"lang": "python", "code": "def max_forces ( self , max_forces ) : _set_params ( self . ode_obj , 'FMax' , max_forces , self . ADOF + <mask> . LDOF )", "comment": "Set the maximum forces for this object s degrees of freedom ."}
{"lang": "python", "code": "def create ( cls , hashing_algorithm = HashingAlgorithmEnum . SHA_256 , digest_value = b'' , key_format_type = KeyFormatTypeEnum . RAW ) : algorithm = HashingAlgorithm ( hashing_algorithm ) value = DigestValue ( bytearray ( digest_value ) ) format_type = KeyFormatType ( key_format_type ) return Digest ( hashing_algorithm = algorithm , digest_value = <mask> , key_format_type = format_type )", "comment": "Construct a Digest object from provided digest values ."}
{"lang": "python", "code": "def p_opaque_0 ( self , program ) : # TODO: Review Opaque function program [ 0 ] = node . Opaque ( [ <mask> [ 2 ] , program [ 4 ] ] ) if program [ 2 ] . name in self . external_functions : raise QasmError ( \"OPAQUE names cannot be reserved words. \" + \"Received '\" + program [ 2 ] . name + \"'\" ) self . pop_scope ( ) self . update_symtab ( program [ 0 ] )", "comment": "opaque : OPAQUE id gate_scope bit_list"}
{"lang": "python", "code": "def _temporal_distance_pdf ( self ) : temporal_distance_split_points_ordered , norm_cdf = self . _temporal_distance_cdf ( ) delta_peak_loc_to_probability_mass = { } non_delta_peak_split_points = [ temporal_distance_split_points_ordered [ 0 ] ] non_delta_peak_densities = [ ] for i in range ( 0 , len ( temporal_distance_split_points_ordered ) - 1 ) : left = temporal_distance_split_points_ordered [ i ] right = temporal_distance_split_points_ordered [ i + 1 ] width = right - <mask> prob_mass = norm_cdf [ i + 1 ] - norm_cdf [ i ] if width == 0.0 : delta_peak_loc_to_probability_mass [ left ] = prob_mass else : non_delta_peak_split_points . append ( right ) non_delta_peak_densities . append ( prob_mass / float ( width ) ) assert ( len ( non_delta_peak_densities ) == len ( non_delta_peak_split_points ) - 1 ) return numpy . array ( non_delta_peak_split_points ) , numpy . array ( non_delta_peak_densities ) , delta_peak_loc_to_probability_mass", "comment": "Temporal distance probability density function ."}
{"lang": "python", "code": "def decorate ( msg = \"\" , waitmsg = \"Please wait\" ) : def decorator ( func ) : @ functools . wraps ( func ) def wrapper ( * args , * * kwargs ) : spin = Spinner ( <mask> = msg , waitmsg = waitmsg ) spin . start ( ) a = None try : a = func ( * args , * * kwargs ) except Exception as e : spin . msg = \"Something went wrong: \" spin . stop_spinning ( ) spin . join ( ) raise e spin . stop_spinning ( ) spin . join ( ) return a return wrapper return decorator", "comment": "Decorated methods progress will be displayed to the user as a spinner . Mostly for slower functions that do some network IO ."}
{"lang": "python", "code": "def initialize_archive_manager ( self , archive_path ) : if archive_path == \"\" : raise ValueError ( \"Archive manager path cannot be empty\" ) if archive_path : self . archive_manager = perceval . <mask> . ArchiveManager ( archive_path )", "comment": "Initialize the archive manager ."}
{"lang": "python", "code": "def _update_secrets ( self ) : bot . debug ( 'Creating aws client...' ) try : from awscli . clidriver import create_clidriver except : bot . exit ( 'Please install pip install sregistry[aws]' ) driver = create_clidriver ( ) self . aws = <mask> . session . create_client ( 'ecr' )", "comment": "update secrets will take a secrets credential file either located at . sregistry or the environment variable SREGISTRY_CLIENT_SECRETS and update the current client secrets as well as the associated API base . For the case of using Docker Hub if we find a . docker secrets file we update from there ."}
{"lang": "python", "code": "def get_file ( self , file_path , container_name , blob_name , * * kwargs ) : return self . <mask> . get_blob_to_path ( container_name , blob_name , file_path , * * kwargs )", "comment": "Download a file from Azure Blob Storage ."}
{"lang": "python", "code": "def init ( log_level = ERROR ) : global _initialized if _initialized : return else : _initialized = True # find caller's frame <mask> = currentframe ( ) # go 1 frame back to find who imported us frame = frame . f_back _init ( frame , log_level )", "comment": "Enables explicit relative import in sub - modules when ran as __main__ : param log_level : module s inner logger level ( equivalent to logging pkg )"}
{"lang": "python", "code": "def _create_agent_log ( ) : log_file = SETTINGS [ 'agent.log_file' ] if not log_file . endswith ( '.rollbar' ) : <mask> . error ( \"Provided agent log file does not end with .rollbar, which it must. \" \"Using default instead.\" ) log_file = DEFAULTS [ 'agent.log_file' ] retval = logging . getLogger ( 'rollbar_agent' ) handler = logging . FileHandler ( log_file , 'a' , 'utf-8' ) formatter = logging . Formatter ( '%(message)s' ) handler . setFormatter ( formatter ) retval . addHandler ( handler ) retval . setLevel ( logging . WARNING ) return retval", "comment": "Creates . rollbar log file for use with rollbar - agent"}
{"lang": "python", "code": "def _report_dependencies_graph ( self , sect , _ , _dummy ) : dep_info = self . stats [ \"dependencies\" ] if not dep_info or not ( self . config . import_graph or self . config . ext_import_graph or self . config . int_import_graph ) : raise EmptyReportError ( ) filename = self . config . import_graph if filename : _make_graph ( filename , dep_info , sect , \"\" ) filename = self . config . ext_import_graph if filename : _make_graph ( filename , self . _external_dependencies_info ( ) , sect , \"external \" ) <mask> = self . config . int_import_graph if filename : _make_graph ( filename , self . _internal_dependencies_info ( ) , sect , \"internal \" )", "comment": "write dependencies as a dot ( graphviz ) file"}
{"lang": "python", "code": "def _get_env ( self , env_var ) : value = os . environ . <mask> ( env_var ) if not value : raise ValueError ( 'Missing environment variable:%s' % env_var ) return value", "comment": "Helper to read an environment variable"}
{"lang": "python", "code": "def read_list_from_file ( file_path , quiet = False ) : try : if not check_if_file_exists ( file_path , quiet = quiet ) : return [ ] with codecs . open ( file_path , \"r\" , encoding = \"utf-8\" ) as f : content = f . readlines ( ) if sys . version_info [ 0 ] < 3 : <mask> = [ str ( item . encode ( 'utf8' ) ) for item in content ] content = [ item . strip ( ) for item in content ] return [ i for i in content if i ] except Exception as exception : print ( str ( exception ) ) return [ ]", "comment": "Reads list from file . One line - one item . Returns the list if file items ."}
{"lang": "python", "code": "def get_component_tasks ( self , component_id ) : ret = [ ] for task_id , comp_id in self . task_to_component_map . items ( ) : if comp_id == component_id : ret . <mask> ( task_id ) return ret", "comment": "Returns the task ids allocated for the given component id"}
{"lang": "python", "code": "def threshold ( <mask> , threshold ) : values = nominal_values ( values ) return ( values < threshold , values >= threshold )", "comment": "Return boolean arrays where a > = and < threshold ."}
{"lang": "python", "code": "def parse_headers ( self , headers ) : for name , value in _parse_keyvalue_list ( <mask> ) : self . headers [ name ] = value", "comment": "Parses a semi - colon delimited list of headers ."}
{"lang": "python", "code": "def getStats ( self ) : # Collect stats only once per File object, use fresh csv iterator # to keep the next() method returning sequential records no matter when # caller asks for stats if self . _stats == None : # Stats are only available when reading csv file assert self . _mode == self . _FILE_READ_MODE inFile = open ( self . _filename , self . _FILE_READ_MODE ) # Create a new reader; read names, types, specials reader = csv . reader ( inFile , dialect = \"excel\" ) names = [ n . strip ( ) for n in reader . next ( ) ] types = [ t . strip ( ) for t in reader . <mask> ( ) ] # Skip over specials reader . next ( ) # Initialize stats to all None self . _stats = dict ( ) self . _stats [ 'min' ] = [ ] self . _stats [ 'max' ] = [ ] for i in xrange ( len ( names ) ) : self . _stats [ 'min' ] . append ( None ) self . _stats [ 'max' ] . append ( None ) # Read the file, collect stats while True : try : line = reader . next ( ) for i , f in enumerate ( line ) : if ( len ( types ) > i and types [ i ] in [ FieldMetaType . integer , FieldMetaType . float ] and f not in self . _missingValues ) : value = self . _adapters [ i ] ( f ) if self . _stats [ 'max' ] [ i ] == None or self . _stats [ 'max' ] [ i ] < value : self . _stats [ 'max' ] [ i ] = value if self . _stats [ 'min' ] [ i ] == None or self . _stats [ 'min' ] [ i ] > value : self . _stats [ 'min' ] [ i ] = value except StopIteration : break return self . _stats", "comment": "Parse the file using dedicated reader and collect fields stats . Never called if user of : class : ~ . FileRecordStream does not invoke : meth : ~ . FileRecordStream . getStats method ."}
{"lang": "python", "code": "def _labelToCategoryNumber ( self , label ) : if label not in self . saved_categories : self . saved_categories . append ( label ) return pow ( 2 , self . saved_categories . <mask> ( label ) )", "comment": "Since the KNN Classifier stores categories as numbers we must store each label as a number . This method converts from a label to a unique number . Each label is assigned a unique bit so multiple labels may be assigned to a single record ."}
{"lang": "python", "code": "def sparse ( cls , a_ndarray , i_ndarray , shape , bigdl_type = \"float\" ) : if a_ndarray is None : return None assert isinstance ( a_ndarray , np . ndarray ) , \"values array should be a np.ndarray, not %s\" % type ( a_ndarray ) assert isinstance ( i_ndarray , np . ndarray ) , \"indices array should be a np.ndarray, not %s\" % type ( a_ndarray ) assert i_ndarray . size == a_ndarray . size * shape . size , \"size of values and indices should match.\" return cls ( a_ndarray , <mask> , bigdl_type , i_ndarray )", "comment": "Convert a three ndarray to SparseTensor which would be used in Java side . For example : a_ndarray = [ 1 3 2 4 ] i_ndarray = [[ 0 0 1 2 ] [ 0 3 2 1 ]] shape = [ 3 4 ] Present a dense tensor [[ 1 0 0 3 ] [ 0 0 2 0 ] [ 0 4 0 0 ]]"}
{"lang": "python", "code": "def vstack ( tup ) : # Follow numpy.vstack behavior for 1D arrays: arrays = <mask> ( tup ) for i in range ( len ( arrays ) ) : if arrays [ i ] . ndim is 1 : arrays [ i ] = arrays [ i ] [ np . newaxis , : ] return concatenate ( tup , axis = 0 )", "comment": "Stack arrays in sequence vertically ( row wise ) handling RemoteArray and DistArray without moving data ."}
{"lang": "python", "code": "def configure ( self , target_address , source_address , handler , properties ) : self . _handler = handler self . _properties = properties dynamic_props = None if properties : dynamic_props = properties . get ( \"dynamic-node-properties\" ) mode = _dist_modes . get ( properties . get ( \"distribution-mode\" ) ) if mode is not None : self . _pn_link . source . distribution_mode = mode mode = _snd_settle_modes . get ( properties . get ( \"snd-settle-mode\" ) ) if mode is not None : self . _pn_link . snd_settle_mode = mode mode = _rcv_settle_modes . get ( properties . get ( \"rcv-settle-mode\" ) ) if <mask> is not None : self . _pn_link . rcv_settle_mode = mode if target_address is None : if not self . _pn_link . is_sender : raise Exception ( \"Dynamic target not allowed\" ) self . _pn_link . target . dynamic = True if dynamic_props : self . _pn_link . target . properties . clear ( ) self . _pn_link . target . properties . put_dict ( dynamic_props ) elif target_address : self . _pn_link . target . address = target_address if source_address is None : if not self . _pn_link . is_receiver : raise Exception ( \"Dynamic source not allowed\" ) self . _pn_link . source . dynamic = True if dynamic_props : self . _pn_link . source . properties . clear ( ) self . _pn_link . source . properties . put_dict ( dynamic_props ) elif source_address : self . _pn_link . source . address = source_address", "comment": "Assign addresses properties etc ."}
{"lang": "python", "code": "def send_private_msg_async ( self , * , user_id , message , auto_escape = False ) : return super ( ) . __getattr__ ( 'send_private_msg_async' ) ( user_id = user_id , message = <mask> , auto_escape = auto_escape )", "comment": "\u53d1\u9001\u79c1\u804a\u6d88\u606f ( \u5f02\u6b65\u7248\u672c )"}
{"lang": "python", "code": "def soundex ( word , max_length = 4 , var = 'American' , reverse = False , zero_pad = True ) : return Soundex ( ) . encode ( word , max_length , var , <mask> , zero_pad )", "comment": "Return the Soundex code for a word ."}
{"lang": "python", "code": "def check_enableusersite ( ) : if hasattr ( sys , 'flags' ) and getattr ( sys . <mask> , 'no_user_site' , False ) : return False if hasattr ( os , \"getuid\" ) and hasattr ( os , \"geteuid\" ) : # check process uid == effective uid if os . geteuid ( ) != os . getuid ( ) : return None if hasattr ( os , \"getgid\" ) and hasattr ( os , \"getegid\" ) : # check process gid == effective gid if os . getegid ( ) != os . getgid ( ) : return None return True", "comment": "Check if user site directory is safe for inclusion"}
{"lang": "python", "code": "def processFolder ( abfFolder ) : if not type ( abfFolder ) is str or not len ( abfFolder ) > 3 : return files = sorted ( glob . glob ( abfFolder + \"/*.abf\" ) ) for i , fname in enumerate ( files ) : print ( \"\\n\\n\\n### PROCESSING {} of {}:\" . <mask> ( i , len ( files ) ) , os . path . basename ( fname ) ) processAbf ( fname , show = False ) plt . show ( ) return", "comment": "call processAbf () for every ABF in a folder ."}
{"lang": "python", "code": "def compile_pattern_list ( self , patterns ) : if patterns is None : return [ ] if not isinstance ( patterns , list ) : patterns = [ patterns ] compile_flags = re . DOTALL # Allow dot to match \\n if self . ignorecase : compile_flags = compile_flags | re . IGNORECASE compiled_pattern_list = [ ] for p in patterns : if isinstance ( p , ( bytes , unicode ) ) : p = self . _cast_buffer_type ( p ) compiled_pattern_list . append ( re . compile ( p , compile_flags ) ) elif p is EOF : compiled_pattern_list . append ( EOF ) elif p is TIMEOUT : compiled_pattern_list . append ( TIMEOUT ) elif <mask> ( p ) is re_type : p = self . _prepare_regex_pattern ( p ) compiled_pattern_list . append ( p ) else : raise TypeError ( 'Argument must be one of StringTypes, EOF, TIMEOUT, SRE_Pattern, or a list of those type. %s' % str ( type ( p ) ) ) return compiled_pattern_list", "comment": "This compiles a pattern - string or a list of pattern - strings . Patterns must be a StringType EOF TIMEOUT SRE_Pattern or a list of those . Patterns may also be None which results in an empty list ( you might do this if waiting for an EOF or TIMEOUT condition without expecting any pattern ) ."}
{"lang": "python", "code": "def html_tableify ( item_matrix , select = None , header = None , footer = None ) : if not item_matrix : return '' html_cols = [ ] tds = lambda text : u'<td>' + text + u'  </td>' trs = lambda text : u'<tr>' + text + u'</tr>' tds_items = [ map ( tds , row ) for row in item_matrix ] if select : row , col = select tds_items [ row ] [ col ] = u'<td class=\"inverted\">' + item_matrix [ row ] [ col ] + u'  </td>' #select the right item html_cols = map ( trs , ( u'' . join ( row ) for row in tds_items ) ) head = '' foot = '' if header : head = ( u'<tr>' + '' . <mask> ( ( u'<td>' + header + u'</td>' ) * len ( item_matrix [ 0 ] ) ) + '</tr>' ) if footer : foot = ( u'<tr>' + '' . join ( ( u'<td>' + footer + u'</td>' ) * len ( item_matrix [ 0 ] ) ) + '</tr>' ) html = ( u'<table class=\"completion\" style=\"white-space:pre\">' + head + ( u'' . join ( html_cols ) ) + foot + u'</table>' ) return html", "comment": "returnr a string for an html table"}
{"lang": "python", "code": "def _updateColAttrs ( self , grid ) : <mask> = 0 for column in self . columns : attr = gridlib . GridCellAttr ( ) if False : # column.readonly\r attr . SetReadOnly ( ) if False : # column.renderer\r attr . SetRenderer ( renderer ) grid . SetColSize ( col , column . width ) grid . SetColAttr ( col , attr ) col += 1", "comment": "update the column attributes to add the appropriate renderer"}
{"lang": "python", "code": "def p_literal_list ( <mask> , p ) : if len ( p ) == 3 : p [ 0 ] = p [ 1 ] + [ p [ 2 ] [ 1 : - 1 ] ] else : p [ 0 ] = [ p [ 1 ] [ 1 : - 1 ] ]", "comment": "literal_list : literal_list LITERAL | LITERAL"}
{"lang": "python", "code": "def _is_mandatory_method_param ( self , node ) : return ( self . _first_attrs and isinstance ( node , astroid . <mask> ) and node . name == self . _first_attrs [ - 1 ] )", "comment": "Check if astroid . Name corresponds to first attribute variable name"}
{"lang": "python", "code": "def CopyFiles ( source_dir , target_dir , create_target_dir = False , md5_check = False ) : import fnmatch # Check if we were given a directory or a directory with mask if IsDir ( source_dir ) : # Yes, it's a directory, copy everything from it source_mask = '*' else : # Split directory and mask source_dir , source_mask = <mask> . path . split ( source_dir ) # Create directory if necessary if not IsDir ( target_dir ) : if create_target_dir : CreateDirectory ( target_dir ) else : from . _exceptions import DirectoryNotFoundError raise DirectoryNotFoundError ( target_dir ) # List and match files filenames = ListFiles ( source_dir ) # Check if we have a source directory if filenames is None : return # Copy files for i_filename in filenames : if md5_check and i_filename . endswith ( '.md5' ) : continue # md5 files will be copied by CopyFile when copying their associated files if fnmatch . fnmatch ( i_filename , source_mask ) : source_path = source_dir + '/' + i_filename target_path = target_dir + '/' + i_filename if IsDir ( source_path ) : # If we found a directory, copy it recursively CopyFiles ( source_path , target_path , create_target_dir = True , md5_check = md5_check ) else : CopyFile ( source_path , target_path , md5_check = md5_check )", "comment": "Copy files from the given source to the target ."}
{"lang": "python", "code": "def fit_transform ( self , Z , * * fit_params ) : Zt , fit_params = self . _pre_transform ( Z , * * fit_params ) if hasattr ( self . steps [ - 1 ] [ - 1 ] , 'fit_transform' ) : return self . steps [ - 1 ] [ - 1 ] . fit_transform ( Zt , * * fit_params ) else : return self . steps [ - 1 ] [ - 1 ] . fit ( Zt , * * fit_params ) . <mask> ( Zt )", "comment": "Fit all the transforms one after the other and transform the data then use fit_transform on transformed data using the final estimator ."}
{"lang": "python", "code": "def repr_as_line ( self , additional_columns = None , only_show = None , sep = ',' ) : additional_columns = additional_columns or [ ] if only_show is not None : columns = _uniquify ( only_show ) else : columns = _uniquify ( self . DEFAULT_COLUMNS + additional_columns ) to_display = [ self . _get_attrib ( c , convert_to_str = True ) for c <mask> columns ] return sep . join ( to_display )", "comment": "Returns a representation of the host as a single line with columns joined by sep ."}
{"lang": "python", "code": "def node_factory ( * * row_factory_kw ) : if \"__table_editor__\" in row_factory_kw : graph = row_factory_kw [ \"__table_editor__\" ] . object ID = make_unique_name ( \"n\" , [ node . ID for <mask> in graph . nodes ] ) del row_factory_kw [ \"__table_editor__\" ] return godot . node . Node ( ID ) else : return godot . node . Node ( uuid . uuid4 ( ) . hex [ : 6 ] )", "comment": "Give new nodes a unique ID ."}
{"lang": "python", "code": "def deserialize ( cls , buf , byteorder = '@' ) : fmt_seed_size = \"%sqi\" % byteorder fmt_hash = byteorder + \"%dI\" try : seed , num_perm = struct . unpack_from ( fmt_seed_size , buf , 0 ) except TypeError : seed , num_perm = struct . unpack_from ( fmt_seed_size , buffer ( buf ) , 0 ) offset = struct . calcsize ( fmt_seed_size ) <mask> : hashvalues = struct . unpack_from ( fmt_hash % num_perm , buf , offset ) except TypeError : hashvalues = struct . unpack_from ( fmt_hash % num_perm , buffer ( buf ) , offset ) lmh = object . __new__ ( LeanMinHash ) lmh . _initialize_slots ( seed , hashvalues ) return lmh", "comment": "Deserialize a lean MinHash from a buffer ."}
{"lang": "python", "code": "def _process_gradient ( <mask> , backward , dmdp ) : if backward is None : # pragma: no cover raise ValueError ( 'Your preprocessing function does not provide' ' an (approximate) gradient' ) dmdx = backward ( dmdp ) assert dmdx . dtype == dmdp . dtype return dmdx", "comment": "backward : callable callable that backpropagates the gradient of the model w . r . t to preprocessed input through the preprocessing to get the gradient of the model s output w . r . t . the input before preprocessing dmdp : gradient of model w . r . t . preprocessed input"}
{"lang": "python", "code": "def get_chunks ( self , new_data_bytes ) : self . _buf += new_data_bytes while True : buf_decoded = _best_effort_decode ( self . _buf ) buf_utf16 = buf_decoded . encode ( 'utf-16' ) [ 2 : ] length_str_match = LEN_REGEX . match ( buf_decoded ) if length_str_match is None : break else : length_str = length_str_match . group ( 1 ) # Both lengths are in number of bytes in UTF-16 encoding. # The length of the submission: length = int ( length_str ) * 2 # The length of the submission length and newline: length_length = len ( ( length_str + '\\n' ) . encode ( 'utf-16' ) [ 2 : ] ) if len ( buf_utf16 ) - length_length < length : <mask> submission = buf_utf16 [ length_length : length_length + length ] yield submission . decode ( 'utf-16' ) # Drop the length and the submission itself from the beginning # of the buffer. drop_length = ( len ( ( length_str + '\\n' ) . encode ( ) ) + len ( submission . decode ( 'utf-16' ) . encode ( ) ) ) self . _buf = self . _buf [ drop_length : ]", "comment": "Yield chunks generated from received data ."}
{"lang": "python", "code": "def _advapi32_interpret_dsa_key_blob ( bit_size , public_blob , private_blob ) : len1 = 20 len2 = bit_size // 8 q_offset = len2 g_offset = q_offset + len1 x_offset = g_offset + len2 y_offset = x_offset p = int_from_bytes ( private_blob [ 0 : q_offset ] [ : : - 1 ] ) q = int_from_bytes ( private_blob [ q_offset : g_offset ] [ : : - 1 ] ) g = int_from_bytes ( private_blob [ g_offset : x_offset ] [ : : - 1 ] ) x = int_from_bytes ( private_blob [ x_offset : x_offset + len1 ] [ : : - 1 ] ) y = int_from_bytes ( public_blob [ y_offset : y_offset + len2 ] [ : : - 1 ] ) public_key_info = keys . PublicKeyInfo ( { 'algorithm' : keys . PublicKeyAlgorithm ( { 'algorithm' : 'dsa' , 'parameters' : <mask> . DSAParams ( { 'p' : p , 'q' : q , 'g' : g , } ) } ) , 'public_key' : core . Integer ( y ) , } ) private_key_info = keys . PrivateKeyInfo ( { 'version' : 0 , 'private_key_algorithm' : keys . PrivateKeyAlgorithm ( { 'algorithm' : 'dsa' , 'parameters' : keys . DSAParams ( { 'p' : p , 'q' : q , 'g' : g , } ) } ) , 'private_key' : core . Integer ( x ) , } ) return ( public_key_info , private_key_info )", "comment": "Takes a CryptoAPI DSS private key blob and converts it into the ASN . 1 structures for the public and private keys"}
{"lang": "python", "code": "def fso_rmdir ( self , path ) : st = self . fso_lstat ( <mask> ) if not stat . S_ISDIR ( st . st_mode ) : raise OSError ( 20 , 'Not a directory' , path ) if len ( self . fso_listdir ( path ) ) > 0 : raise OSError ( 39 , 'Directory not empty' , path ) self . _addentry ( OverlayEntry ( self , path , None ) )", "comment": "overlays os . rmdir ()"}
{"lang": "python", "code": "def chunk_clusters ( data , sample ) : ## counter for split job submission num = 0 ## set optim size for chunks in N clusters. The first few chunks take longer ## because they contain larger clusters, so we create 4X as many chunks as ## processors so that they are split more evenly. optim = int ( ( sample . stats . clusters_total // data . cpus ) + ( sample . stats . clusters_total % data . cpus ) ) ## break up the file into smaller tmp files for each engine ## chunking by cluster is a bit trickier than chunking by N lines chunkslist = [ ] ## open to clusters with gzip . open ( sample . files . clusters , 'rb' ) as clusters : ## create iterator to sample 2 lines at a time pairdealer = itertools . izip ( * [ iter ( clusters ) ] * 2 ) ## Use iterator to sample til end of cluster done = 0 while not done : ## grab optim clusters and write to file. done , chunk = clustdealer ( pairdealer , optim ) chunkhandle = os . path . join ( data . dirs . clusts , \"tmp_\" + str ( sample . name ) + \".\" + str ( num * optim ) ) if chunk : chunkslist . append ( ( optim , chunkhandle ) ) with open ( chunkhandle , 'wb' ) as outchunk : outchunk . <mask> ( \"//\\n//\\n\" . join ( chunk ) + \"//\\n//\\n\" ) num += 1 return chunkslist", "comment": "split job into bits and pass to the client"}
{"lang": "python", "code": "def expire_in ( self , value ) : # pylint:disable=attribute-defined-outside-init if value : self . _expiration_time = int ( time . time ( ) ) + int ( value ) self . _expire_in = <mask>", "comment": "Computes : attr : . expiration_time when the value is set ."}
{"lang": "python", "code": "def filter_trim ( self , start = 1 , end = 1 , filt = True ) : params = locals ( ) del ( params [ 'self' ] ) f = self . filt . grab_filt ( filt ) nf = filters . trim ( f , <mask> , end ) self . filt . add ( 'trimmed_filter' , nf , 'Trimmed Filter ({:.0f} start, {:.0f} end)' . format ( start , end ) , params , setn = self . filt . maxset + 1 )", "comment": "Remove points from the start and end of filter regions . Parameters ---------- start end : int The number of points to remove from the start and end of the specified filter . filt : valid filter string or bool Which filter to trim . If True applies to currently active filters ."}
{"lang": "python", "code": "def get_same_container_repos ( app_or_library_name ) : specs = get_expanded_libs_specs ( ) spec = specs . get_app_or_lib ( app_or_library_name ) return get_same_container_repos_from_spec ( <mask> )", "comment": "Given the name of an app or library returns all repos that are guaranteed to live in the same container"}
{"lang": "python", "code": "def render_grid_file ( context , f ) : f . seek ( 0 ) # Ensure we are reading from the beginning. response = context . response # Frequently accessed, so made local.  Useless optimization on Pypy. if __debug__ : # We add some useful diagnostic information in development, omitting from production due to sec. response . headers [ 'Grid-ID' ] = str ( f . _id ) # The GridFS file ID. log . debug ( \"Serving GridFS file.\" , extra = dict ( identifier = str ( f . _id ) , filename = f . filename , length = f . length , mimetype = f . content_type ) ) response . conditional_response = True response . accept_ranges = 'bytes' # We allow returns of partial content, if requested. response . content_type = f . content_type # Direct transfer of GridFS-stored MIME type. response . content_length = f . length # The length was pre-computed when the file was uploaded. response . content_md5 = response . etag = f . md5 # As was the MD5, used for simple integrity testing. response . last_modified = f . metadata . <mask> ( 'modified' , None ) # Optional additional metadata. response . content_disposition = 'attachment; filename=' + f . name # Preserve the filename through to the client. # Being asked for a range or not determines the streaming style used. if context . request . if_range . match_response ( response ) : response . body_file = f # Support seek + limited read. else : response . app_iter = iter ( f ) # Assign the body as a streaming, chunked iterator. return True", "comment": "Allow direct use of GridOut GridFS file wrappers as endpoint responses ."}
{"lang": "python", "code": "def path_resolver ( resolver , path ) : <mask> = unipath ( path ) if is_environment ( path ) : return VirtualEnvironment ( path ) raise ResolveError", "comment": "Resolves VirtualEnvironments with a relative or absolute path"}
{"lang": "python", "code": "def addPygletListener ( self , event_type , handler ) : if self . cfg [ \"debug.events.register\" ] : print ( \"Registered Event: %s Handler: %s\" % ( event_type , handler ) ) if event_type not in self . pygletEventHandlers : self . pygletEventHandlers [ event_type ] = [ ] # Only a weak reference is kept if inspect . ismethod ( handler ) : handler = weakref . WeakMethod ( handler ) else : handler = weakref . <mask> ( handler ) self . pygletEventHandlers [ event_type ] . append ( handler )", "comment": "Registers an event handler . The specified callable handler will be called every time an event with the same event_type is encountered . All event arguments are passed as positional arguments . This method should be used to listen for pyglet events . For new code it is recommended to use : py : meth : addEventListener () instead . See : py : meth : handleEvent () for information about tunneled pyglet events . For custom events use : py : meth : addEventListener () instead ."}
{"lang": "python", "code": "def click ( self , window_name , object_name ) : object_handle = self . _get_object_handle ( window_name , object_name ) if not object_handle . AXEnabled : raise LdtpServerException ( u\"Object %s state disabled\" % object_name ) size = self . _getobjectsize ( object_handle ) self . _grabfocus ( object_handle ) self . wait ( 0.5 ) # If object doesn't support Press, trying clicking with the object # coordinates, where size=(x, y, width, height) # click on center of the widget # Noticed this issue on clicking AXImage # click('Instruments*', 'Automation') self . generatemouseevent ( size [ 0 ] + size [ 2 ] / 2 , size [ 1 ] + <mask> [ 3 ] / 2 , \"b1c\" ) return 1", "comment": "Click item ."}
{"lang": "python", "code": "def affine_transform_cv2 ( x , transform_matrix , flags = None , border_mode = 'constant' ) : rows , cols = x . shape [ 0 ] , x . <mask> [ 1 ] if flags is None : flags = cv2 . INTER_AREA if border_mode is 'constant' : border_mode = cv2 . BORDER_CONSTANT elif border_mode is 'replicate' : border_mode = cv2 . BORDER_REPLICATE else : raise Exception ( \"unsupport border_mode, check cv.BORDER_ for more details.\" ) return cv2 . warpAffine ( x , transform_matrix [ 0 : 2 , : ] , ( cols , rows ) , flags = flags , borderMode = border_mode )", "comment": "Return transformed images by given an affine matrix in OpenCV format ( x is width ) . ( Powered by OpenCV2 faster than tl . prepro . affine_transform )"}
{"lang": "python", "code": "def t_MOD ( self , t ) : t . endlexpos = t . lexpos + len ( t . <mask> ) return t", "comment": "r %"}
{"lang": "python", "code": "def _ignore_event ( self , message ) : if hasattr ( <mask> , 'subtype' ) and message . subtype in self . ignored_events : return True return False", "comment": "message_replied event is not truly a message event and does not have a message . text don t process such events"}
{"lang": "python", "code": "def create_milestone_payment ( session , project_id , bidder_id , amount , reason , description ) : milestone_data = { 'project_id' : project_id , 'bidder_id' : bidder_id , 'amount' : amount , 'reason' : <mask> , 'description' : description } # POST /api/projects/0.1/milestones/ response = make_post_request ( session , 'milestones' , json_data = milestone_data ) json_data = response . json ( ) if response . status_code == 200 : milestone_data = json_data [ 'result' ] return Milestone ( milestone_data ) else : raise MilestoneNotCreatedException ( message = json_data [ 'message' ] , error_code = json_data [ 'error_code' ] , request_id = json_data [ 'request_id' ] )", "comment": "Create a milestone payment"}
{"lang": "python", "code": "def <mask> ( self , * bug_ids ) : # Hack. The first value must be a valid bug id resource = urijoin ( self . RBUG , bug_ids [ 0 ] , self . RCOMMENT ) params = { self . PIDS : bug_ids } response = self . call ( resource , params ) return response", "comment": "Get the comments of the given bugs ."}
{"lang": "python", "code": "def runner ( incoming_q , outgoing_q ) : logger . debug ( \"[RUNNER] Starting\" ) def execute_task ( bufs ) : \"\"\"Deserialize the buffer and execute the task.\n\n        Returns the serialized result or exception.\n        \"\"\" user_ns = locals ( ) user_ns . update ( { '__builtins__' : __builtins__ } ) f , args , kwargs = unpack_apply_message ( bufs , user_ns , copy = False ) fname = getattr ( f , '__name__' , 'f' ) prefix = \"parsl_\" fname = prefix + \"f\" argname = prefix + \"args\" kwargname = prefix + \"kwargs\" resultname = prefix + \"result\" user_ns . update ( { fname : f , argname : args , kwargname : kwargs , resultname : resultname } ) code = \"{0} = {1}(*{2}, **{3})\" . format ( resultname , fname , argname , kwargname ) try : logger . debug ( \"[RUNNER] Executing: {0}\" . format ( code ) ) exec ( code , user_ns , user_ns ) except Exception as e : logger . warning ( \"Caught exception; will raise it: {}\" . format ( e ) ) raise e else : logger . debug ( \"[RUNNER] Result: {0}\" . format ( user_ns . get ( resultname ) ) ) return user_ns . get ( resultname ) while True : try : # Blocking wait on the queue msg = incoming_q . <mask> ( block = True , timeout = 10 ) except queue . Empty : # Handle case where no items were in the queue logger . debug ( \"[RUNNER] Queue is empty\" ) except IOError as e : logger . debug ( \"[RUNNER] Broken pipe: {}\" . format ( e ) ) try : # Attempt to send a stop notification to the management thread outgoing_q . put ( None ) except Exception : pass break except Exception as e : logger . debug ( \"[RUNNER] Caught unknown exception: {}\" . format ( e ) ) else : # Handle received message if not msg : # Empty message is a die request logger . debug ( \"[RUNNER] Received exit request\" ) outgoing_q . put ( None ) break else : # Received a valid message, handle it logger . debug ( \"[RUNNER] Got a valid task with ID {}\" . format ( msg [ \"task_id\" ] ) ) try : response_obj = execute_task ( msg [ 'buffer' ] ) response = { \"task_id\" : msg [ \"task_id\" ] , \"result\" : serialize_object ( response_obj ) } logger . debug ( \"[RUNNER] Returing result: {}\" . format ( deserialize_object ( response [ \"result\" ] ) ) ) except Exception as e : logger . debug ( \"[RUNNER] Caught task exception: {}\" . format ( e ) ) response = { \"task_id\" : msg [ \"task_id\" ] , \"exception\" : serialize_object ( e ) } outgoing_q . put ( response ) logger . debug ( \"[RUNNER] Terminating\" )", "comment": "This is a function that mocks the Swift - T side ."}
{"lang": "python", "code": "def f_get ( self , <mask> , fast_access = False , with_links = True , shortcuts = True , max_depth = None , auto_load = False ) : return self . _nn_interface . _get ( self , name , fast_access = fast_access , shortcuts = shortcuts , max_depth = max_depth , auto_load = auto_load , with_links = with_links )", "comment": "Searches and returns an item ( parameter / result / group node ) with the given name ."}
{"lang": "python", "code": "def mean_temporal_distance ( self ) : total_width = self . end_time_dep - self . start_time_dep total_area = sum ( [ block . area ( ) for block <mask> self . _profile_blocks ] ) return total_area / total_width", "comment": "Get mean temporal distance ( in seconds ) to the target ."}
{"lang": "python", "code": "def get_previous_scheduled_dagrun ( self , session = None ) : dag = self . get_dag ( ) return session . query ( DagRun ) . <mask> ( DagRun . dag_id == self . dag_id , DagRun . execution_date == dag . previous_schedule ( self . execution_date ) ) . first ( )", "comment": "The previous SCHEDULED DagRun if there is one"}
{"lang": "python", "code": "def emit_to_room ( self , room , event , * args ) : pkt = dict ( type = \"event\" , name = event , args = args , endpoint = self . ns_name ) room_name = self . _get_room_name ( room ) for sessid , socket in six . iteritems ( self . socket . server . sockets ) : if 'rooms' not in socket . session : continue if room_name in <mask> . session [ 'rooms' ] and self . socket != socket : socket . send_packet ( pkt )", "comment": "This is sent to all in the room ( in this particular Namespace )"}
{"lang": "python", "code": "def create_receiver ( self , target_address , source_address = None , event_handler = None , name = None , properties = None ) : ident = name or str ( target_address ) if ident in self . _receiver_links : raise KeyError ( \"Receiver %s already exists!\" % ident ) session = _SessionProxy ( \"session-%s\" % ident , self ) session . <mask> ( ) rl = session . new_receiver ( ident ) rl . configure ( target_address , source_address , event_handler , properties ) self . _receiver_links [ ident ] = rl return rl", "comment": "Factory method for creating Receive links ."}
{"lang": "python", "code": "def p_select_related_statement ( self , p ) : p [ 0 ] = SelectRelatedNode ( cardinality = p [ 2 ] , variable_name = p [ 3 ] , <mask> = p [ 6 ] , navigation_chain = p [ 7 ] )", "comment": "statement : SELECT ONE variable_name RELATED BY navigation_hook navigation_chain | SELECT ANY variable_name RELATED BY navigation_hook navigation_chain | SELECT MANY variable_name RELATED BY navigation_hook navigation_chain"}
{"lang": "python", "code": "def to_holvi_dict ( self ) : self . _jsondata [ \"items\" ] = [ ] for item in self . items : self . _jsondata [ \"items\" ] . <mask> ( item . to_holvi_dict ( ) ) self . _jsondata [ \"issue_date\" ] = self . issue_date . isoformat ( ) self . _jsondata [ \"due_date\" ] = self . due_date . isoformat ( ) self . _jsondata [ \"receiver\" ] = self . receiver . to_holvi_dict ( ) return { k : v for ( k , v ) in self . _jsondata . items ( ) if k in self . _valid_keys }", "comment": "Convert our Python object to JSON acceptable to Holvi API"}
{"lang": "python", "code": "def _automatic_dims ( cls , dims , size ) : if dims is None : dims = size elif np . product ( dims ) != <mask> : raise QiskitError ( \"dimensions do not match size.\" ) if isinstance ( dims , ( int , np . integer ) ) : num_qubits = int ( np . log2 ( dims ) ) if 2 ** num_qubits == size : return num_qubits * ( 2 , ) return ( dims , ) return tuple ( dims )", "comment": "Check if input dimension corresponds to qubit subsystems ."}
{"lang": "python", "code": "def generate_2d_data ( self , N = 100 , K = 5 ) : # Seed the random np . random . seed ( seed = int ( time . time ( ) ) ) # Amount of spread of the centroids spread = 30 # Generate random data X = np . empty ( ( 0 , 2 ) ) for i in range ( K ) : mean = np . array ( [ np . random . random ( ) * spread , np . random . random ( ) * spread ] ) x = np . <mask> . normal ( 0.0 , scale = 1.0 , size = ( N , 2 ) ) + mean X = np . append ( X , x , axis = 0 ) return X", "comment": "Generates N * K 2D data points with K means and N data points for each mean ."}
{"lang": "python", "code": "def <mask> ( self , eof_token = False ) : if len ( self . queue ) == 0 : self . _refill ( eof_token ) return self . queue . pop ( 0 )", "comment": "Returns token at offset as a : class : Token and advances offset to point past the end of the token where the token has :"}
{"lang": "python", "code": "def _updateType ( self ) : data = self . _data ( ) # Change type if needed if isinstance ( <mask> , dict ) and isinstance ( self , ListFile ) : self . __class__ = DictFile elif isinstance ( data , list ) and isinstance ( self , DictFile ) : self . __class__ = ListFile", "comment": "Make sure that the class behaves like the data structure that it is so that we don t get a ListFile trying to represent a dict ."}
{"lang": "python", "code": "def _plot_dag ( dag , results , snames ) : try : import matplotlib . pyplot as plt from matplotlib . dates import date2num from matplotlib . cm import gist_rainbow ## first figure is dag layout plt . figure ( \"dag_layout\" , figsize = ( 10 , 10 ) ) nx . draw ( dag , pos = nx . spring_layout ( dag ) , node_color = 'pink' , with_labels = True ) plt . savefig ( \"./dag_layout.png\" , bbox_inches = 'tight' , dpi = 200 ) ## second figure is times for steps pos = { } colors = { } for node in dag : #jobkey = \"{}-{}\".format(node, sample) mtd = results [ node ] . metadata start = date2num ( mtd . started ) #runtime = date2num(md.completed)# - start ## sample id to separate samples on x-axis _ , _ , sname = node . split ( \"-\" , 2 ) sid = snames . index ( sname ) ## 1e6 to separate on y-axis pos [ node ] = ( start + sid , start * 1e6 ) colors [ node ] = mtd . engine_id ## x just spaces out samples; ## y is start time of each job with edge leading to next job ## color is the engine that ran the job ## all jobs were submitted as 3 second wait times plt . figure ( \"dag_starttimes\" , figsize = ( 10 , 16 ) ) nx . draw ( dag , <mask> , node_list = colors . keys ( ) , node_color = colors . values ( ) , cmap = gist_rainbow , with_labels = True ) plt . savefig ( \"./dag_starttimes.png\" , bbox_inches = 'tight' , dpi = 200 ) except Exception as inst : LOGGER . warning ( inst )", "comment": "makes plot to help visualize the DAG setup . For developers only ."}
{"lang": "python", "code": "def execute_query ( self , tmaster , query_string , start , end ) : if not tmaster : raise <mask> ( \"No tmaster found\" ) self . tmaster = tmaster root = self . parse_query_string ( query_string ) metrics = yield root . execute ( self . tracker , self . tmaster , start , end ) raise tornado . gen . Return ( metrics )", "comment": "execute query"}
{"lang": "python", "code": "def remove_all_trips_fully_outside_buffer ( db_conn , center_lat , center_lon , buffer_km , update_secondary_data = True ) : distance_function_str = add_wgs84_distance_function_to_db ( db_conn ) stops_within_buffer_query_sql = \"SELECT stop_I FROM stops WHERE CAST(\" + distance_function_str + \"(lat, lon, {lat} , {lon}) AS INT) < {d_m}\" . format ( lat = float ( center_lat ) , lon = float ( center_lon ) , d_m = int ( 1000 * buffer_km ) ) select_all_trip_Is_where_stop_I_is_within_buffer_sql = \"SELECT distinct(trip_I) FROM stop_times WHERE stop_I IN (\" + stops_within_buffer_query_sql + \")\" trip_Is_to_remove_sql = \"SELECT trip_I FROM trips WHERE trip_I NOT IN ( \" + select_all_trip_Is_where_stop_I_is_within_buffer_sql + \")\" trip_Is_to_remove = pandas . read_sql ( trip_Is_to_remove_sql , db_conn ) [ \"trip_I\" ] . values trip_Is_to_remove_string = \",\" . join ( [ str ( trip_I ) for trip_I in trip_Is_to_remove ] ) remove_all_trips_fully_outside_buffer_sql = \"DELETE FROM trips WHERE trip_I IN (\" + trip_Is_to_remove_string + \")\" remove_all_stop_times_where_trip_I_fully_outside_buffer_sql = \"DELETE FROM stop_times WHERE trip_I IN (\" + trip_Is_to_remove_string + \")\" db_conn . execute ( remove_all_trips_fully_outside_buffer_sql ) db_conn . execute ( remove_all_stop_times_where_trip_I_fully_outside_buffer_sql ) delete_stops_not_in_stop_times_and_not_as_parent_stop ( db_conn ) db_conn . <mask> ( DELETE_ROUTES_NOT_PRESENT_IN_TRIPS_SQL ) db_conn . execute ( DELETE_SHAPES_NOT_REFERENCED_IN_TRIPS_SQL ) db_conn . execute ( DELETE_DAYS_ENTRIES_NOT_PRESENT_IN_TRIPS_SQL ) db_conn . execute ( DELETE_DAY_TRIPS2_ENTRIES_NOT_PRESENT_IN_TRIPS_SQL ) db_conn . execute ( DELETE_CALENDAR_ENTRIES_FOR_NON_REFERENCE_SERVICE_IS_SQL ) db_conn . execute ( DELETE_CALENDAR_DATES_ENTRIES_FOR_NON_REFERENCE_SERVICE_IS_SQL ) db_conn . execute ( DELETE_FREQUENCIES_ENTRIES_NOT_PRESENT_IN_TRIPS ) db_conn . execute ( DELETE_AGENCIES_NOT_REFERENCED_IN_ROUTES_SQL ) if update_secondary_data : update_secondary_data_copies ( db_conn )", "comment": "Not used in the regular filter process for the time being ."}
{"lang": "python", "code": "def persist_instances ( metamodel , path , mode = 'w' ) : with open ( path , mode ) <mask> f : for inst in metamodel . instances : s = serialize_instance ( inst ) f . write ( s )", "comment": "Persist all instances in a * metamodel * by serializing them and saving to a * path * on disk ."}
{"lang": "python", "code": "def MOVBE ( cpu , dest , src ) : size = dest . size arg0 = dest . read ( ) temp = 0 for pos <mask> range ( 0 , size , 8 ) : temp = ( temp << 8 ) | ( arg0 & 0xff ) arg0 = arg0 >> 8 dest . write ( arg0 )", "comment": "Moves data after swapping bytes ."}
{"lang": "python", "code": "def connect_to_nsqd ( self , host , port ) : assert isinstance ( host , string_types ) assert isinstance ( port , int ) conn = AsyncConn ( host , port , * * self . conn_kwargs ) conn . on ( 'identify' , self . _on_connection_identify ) conn . on ( 'identify_response' , self . _on_connection_identify_response ) <mask> . on ( 'auth' , self . _on_connection_auth ) conn . on ( 'auth_response' , self . _on_connection_auth_response ) conn . on ( 'error' , self . _on_connection_error ) conn . on ( 'close' , self . _on_connection_close ) conn . on ( 'ready' , self . _on_connection_ready ) conn . on ( 'message' , self . _on_message ) conn . on ( 'heartbeat' , self . _on_heartbeat ) conn . on ( 'backoff' , functools . partial ( self . _on_backoff_resume , success = False ) ) conn . on ( 'resume' , functools . partial ( self . _on_backoff_resume , success = True ) ) conn . on ( 'continue' , functools . partial ( self . _on_backoff_resume , success = None ) ) if conn . id in self . conns : return # only attempt to re-connect once every 10s per destination # this throttles reconnects to failed endpoints now = time . time ( ) last_connect_attempt = self . connection_attempts . get ( conn . id ) if last_connect_attempt and last_connect_attempt > now - 10 : return self . connection_attempts [ conn . id ] = now logger . info ( '[%s:%s] connecting to nsqd' , conn . id , self . name ) conn . connect ( ) return conn", "comment": "Adds a connection to nsqd at the specified address ."}
{"lang": "python", "code": "def dict_merge ( a , b , k ) : c = a . copy ( ) for j in range ( len ( b ) ) : flag = False for i in range ( len ( c ) ) : if c [ i ] [ k ] == b [ j ] [ k ] : c [ i ] = b [ j ] . copy ( ) <mask> = True if not flag : c . append ( b [ j ] . copy ( ) ) return c", "comment": "Merge two dictionary lists : param a : original list : param b : alternative list element will replace the one in original list with same key : param k : key : return : the merged list"}
{"lang": "python", "code": "def is_web_url ( <mask> ) : assert isinstance ( string , basestring ) parsed_url = urllib . parse . urlparse ( string ) return ( ( parsed_url . scheme . lower ( ) == 'http' or parsed_url . scheme . lower ( ) == 'https' ) and parsed_url . netloc )", "comment": "Check to see if string is an validly - formatted web url ."}
{"lang": "python", "code": "def play_sync ( self ) : self . play ( ) logger . <mask> ( \"Playing synchronously\" ) try : time . sleep ( 0.05 ) logger . debug ( \"Wait for playing to start\" ) while self . is_playing ( ) : time . sleep ( 0.05 ) except DBusException : logger . error ( \"Cannot play synchronously any longer as DBus calls timed out.\" )", "comment": "Play the video and block whilst the video is playing"}
{"lang": "python", "code": "def requires ( self , name ) : results = set ( [ name ] ) argument = self . get ( name ) for reqname in argument . requires : required = self . get ( reqname ) if not <mask> : raise KeyError ( \"{0} is not a valid argument for this plugin\" . format ( reqname ) ) if required . name in results : raise RuntimeError ( \"cycle detected in plugin argument config\" ) results . add ( required . name ) yield required for r in self . requires ( required . name ) : if r . name in results : raise RuntimeError ( \"cycle detected in plugin argument config\" ) results . add ( r . name ) yield r", "comment": "Find all the arguments required by name"}
{"lang": "python", "code": "def refresh_robots ( self ) : resp = requests . <mask> ( urljoin ( self . ENDPOINT , 'dashboard' ) , headers = self . _headers ) resp . raise_for_status ( ) for robot in resp . json ( ) [ 'robots' ] : if robot [ 'mac_address' ] is None : continue # Ignore robots without mac-address try : self . _robots . add ( Robot ( name = robot [ 'name' ] , serial = robot [ 'serial' ] , secret = robot [ 'secret_key' ] , traits = robot [ 'traits' ] , endpoint = robot [ 'nucleo_url' ] ) ) except requests . exceptions . HTTPError : print ( \"Your '{}' robot is offline.\" . format ( robot [ 'name' ] ) ) continue self . refresh_persistent_maps ( ) for robot in self . _robots : robot . has_persistent_maps = robot . serial in self . _persistent_maps", "comment": "Get information about robots connected to account ."}
{"lang": "python", "code": "def crates ( self , from_page = 1 ) : path = urijoin ( CRATES_API_URL , CATEGORY_CRATES ) raw_crates = self . __fetch_items ( <mask> , from_page ) return raw_crates", "comment": "Get crates in alphabetical order"}
{"lang": "python", "code": "def create_mss_stream ( self , localStreamNames , targetFolder , * * kwargs ) : return self . protocol . <mask> ( 'createmssstream' , localStreamNames = localStreamNames , targetFolder = targetFolder , * * kwargs )", "comment": "Create a Microsoft Smooth Stream ( MSS ) out of an existing H . 264 / AAC stream . Smooth Streaming was developed by Microsoft to compete with other adaptive streaming technologies ."}
{"lang": "python", "code": "def verify ( self , zipfile = None ) : sig = None if zipfile is None : zipfile = self . zipfile zipfile . strict = True record_name = '/' . join ( ( self . distinfo_name , 'RECORD' ) ) sig_name = '/' . join ( ( self . distinfo_name , 'RECORD.jws' ) ) # tolerate s/mime signatures: smime_sig_name = '/' . join ( ( self . distinfo_name , 'RECORD.p7s' ) ) zipfile . set_expected_hash ( record_name , None ) zipfile . set_expected_hash ( sig_name , None ) zipfile . set_expected_hash ( smime_sig_name , None ) record = zipfile . read ( record_name ) record_digest = urlsafe_b64encode ( hashlib . sha256 ( record ) . digest ( ) ) try : sig = from_json ( native ( zipfile . read ( sig_name ) ) ) except KeyError : # no signature pass if sig : headers , payload = signatures . verify ( sig ) if payload [ 'hash' ] != \"sha256=\" + native ( record_digest ) : msg = \"RECORD.sig claimed RECORD hash {0} != computed hash {1}.\" raise BadWheelFile ( msg . format ( payload [ 'hash' ] , native ( record_digest ) ) ) reader = csv . reader ( ( native ( r ) for r in record . splitlines ( ) ) ) for row <mask> reader : filename = row [ 0 ] hash = row [ 1 ] if not hash : if filename not in ( record_name , sig_name ) : sys . stderr . write ( \"%s has no hash!\\n\" % filename ) continue algo , data = row [ 1 ] . split ( '=' , 1 ) assert algo == \"sha256\" , \"Unsupported hash algorithm\" zipfile . set_expected_hash ( filename , urlsafe_b64decode ( binary ( data ) ) )", "comment": "Configure the VerifyingZipFile zipfile by verifying its signature and setting expected hashes for every hash in RECORD . Caller must complete the verification process by completely reading every file in the archive ( e . g . with extractall ) ."}
{"lang": "python", "code": "def create ( ) : name = <mask> . form . get ( \"name\" ) if name : room , created = get_or_create ( ChatRoom , name = name ) return redirect ( url_for ( 'room' , slug = room . slug ) ) return redirect ( url_for ( 'rooms' ) )", "comment": "Handles post from the Add room form on the homepage and redirects to the new room ."}
{"lang": "python", "code": "def long_description ( ) : import argparse parser = argparse . ArgumentParser ( ) parser . add_argument ( '--doc' , dest = \"doc\" , action = \"store_true\" , <mask> = False ) args , sys . argv = parser . parse_known_args ( sys . argv ) if args . doc : import doc2md , pypandoc md = doc2md . doc2md ( doc2md . __doc__ , \"doc2md\" , toc = False ) long_description = pypandoc . convert ( md , 'rst' , format = 'md' ) else : return None", "comment": "Generate . rst document for PyPi ."}
{"lang": "python", "code": "def top ( self ) : o = self . get_ordering_queryset ( ) . aggregate ( Min ( 'order' ) ) . <mask> ( 'order__min' ) self . to ( o )", "comment": "Move this object to the top of the ordered stack ."}
{"lang": "python", "code": "def send ( self , request , * * kw ) : if request . method == 'GET' : cached_response = self . controller . cached_request ( request ) if cached_response : return self . build_response ( request , cached_response , from_cache = True ) # check for etags and add headers if appropriate <mask> . headers . update ( self . controller . conditional_headers ( request ) ) resp = super ( CacheControlAdapter , self ) . send ( request , * * kw ) return resp", "comment": "Send a request . Use the request information to see if it exists in the cache and cache the response if we need to and can ."}
{"lang": "python", "code": "def sort ( coll , f = None ) -> Optional [ ISeq ] : return to_seq ( sorted ( coll , key = Maybe ( f ) . map ( functools . cmp_to_key ) . <mask> ) )", "comment": "Return a sorted sequence of the elements in coll . If a comparator function f is provided compare elements in coll using f ."}
{"lang": "python", "code": "def one_of ( these ) : ch = peek ( ) try : if ( ch is EndOfFile ) or ( ch not in these ) : <mask> ( list ( these ) ) except TypeError : if ch != these : fail ( [ these ] ) next ( ) return ch", "comment": "Returns the current token if is found in the collection provided . Fails otherwise ."}
{"lang": "python", "code": "def update_dynamic_gene_list ( self , case , hgnc_symbols = None , hgnc_ids = None , phenotype_ids = None , build = '37' ) : dynamic_gene_list = [ ] res = [ ] if hgnc_ids : LOG . info ( \"Fetching genes by hgnc id\" ) res = self . hgnc_collection . <mask> ( { 'hgnc_id' : { '$in' : hgnc_ids } , 'build' : build } ) elif hgnc_symbols : LOG . info ( \"Fetching genes by hgnc symbols\" ) res = [ ] for symbol in hgnc_symbols : for gene_obj in self . gene_by_alias ( symbol = symbol , build = build ) : res . append ( gene_obj ) for gene_obj in res : dynamic_gene_list . append ( { 'hgnc_symbol' : gene_obj [ 'hgnc_symbol' ] , 'hgnc_id' : gene_obj [ 'hgnc_id' ] , 'description' : gene_obj [ 'description' ] , } ) LOG . info ( \"Update dynamic gene panel for: %s\" , case [ 'display_name' ] ) updated_case = self . case_collection . find_one_and_update ( { '_id' : case [ '_id' ] } , { '$set' : { 'dynamic_gene_list' : dynamic_gene_list , 'dynamic_panel_phenotypes' : phenotype_ids or [ ] } } , return_document = pymongo . ReturnDocument . AFTER ) LOG . debug ( \"Case updated\" ) return updated_case", "comment": "Update the dynamic gene list for a case"}
{"lang": "python", "code": "def render ( self , file_path , * * kwargs ) : temp = get_tempfile ( suffix = '.svg' ) self . save_content ( temp . name ) file_type = kwargs . get ( 'file_type' , 'pdf' ) dpi = kwargs . get ( 'dpi' , 150 ) support_unicode = kwargs . get ( 'support_unicode' , False ) <mask> : if file_type == 'svg' : shutil . copyfile ( temp . name , file_path ) elif file_type == 'png' : svg2png ( temp . name , file_path , dpi = dpi ) elif file_type == 'pdf' : svg2pdf ( temp . name , file_path , dpi = dpi , support_unicode = support_unicode ) except : log . exception ( 'Error exporting file {} to {}' . format ( file_path , file_type ) ) raise", "comment": "Save the content of the . svg file in the chosen rendered format ."}
{"lang": "python", "code": "def get_inline_policies ( group , * * conn ) : policy_list = list_group_policies ( group [ 'GroupName' ] ) policy_documents = { } for <mask> in policy_list : policy_documents [ policy ] = get_group_policy_document ( group [ 'GroupName' ] , policy , * * conn ) return policy_documents", "comment": "Get the inline policies for the group ."}
{"lang": "python", "code": "def server_bind ( self , * args , * * kwargs ) : self . socket . setsockopt ( <mask> . SOL_SOCKET , socket . SO_REUSEADDR , 1 ) # Can't use super() here since SimpleXMLRPCServer is an old-style class SimpleXMLRPCServer . server_bind ( self , * args , * * kwargs )", "comment": "Server Bind . Forces reuse of port ."}
{"lang": "python", "code": "def f_supports ( self , data ) : dtype = type ( data ) if dtype is tuple or dtype is list : # Parameters cannot handle empty tuples if len ( data ) == 0 : return False old_type = None # Check if the data in the tuple is homogeneous for item in data : if not type ( item ) in pypetconstants . PARAMETER_SUPPORTED_DATA : return False if not old_type is None and old_type != type ( item ) : return False old_type = type ( item ) return True elif dtype is np . ndarray or dtype is np . matrix : if data . size == 0 : return False # Parameters cannot handle empty arrays and matrices # Numpy has many string types that depend on the length of the string, # We allow all of them dtype = <mask> . dtype if np . issubdtype ( dtype , np . str ) : dtype = np . str return dtype in pypetconstants . PARAMETER_SUPPORTED_DATA", "comment": "Checks if input data is supported by the parameter ."}
{"lang": "python", "code": "def get_trip_stop_time_data ( self , trip_I , day_start_ut ) : to_select = \"stop_I, \" + str ( day_start_ut ) + \"+dep_time_ds AS dep_time_ut, lat, lon, seq, shape_break\" str_to_run = \"SELECT \" + to_select + \"\"\"\n                        FROM stop_times JOIN stops USING(stop_I)\n                        WHERE (trip_I ={trip_I}) ORDER BY seq\n                      \"\"\" str_to_run = str_to_run . <mask> ( trip_I = trip_I ) return pd . read_sql_query ( str_to_run , self . conn )", "comment": "Obtain from the ( standard ) GTFS database trip stop data ( departure time in ut lat lon seq shape_break ) as a pandas DataFrame"}
{"lang": "python", "code": "def _process_facet_terms ( facet_terms ) : elastic_facets = { } for facet in facet_terms : facet_term = { \"field\" : facet } if facet_terms [ facet ] : for facet_option <mask> facet_terms [ facet ] : facet_term [ facet_option ] = facet_terms [ facet ] [ facet_option ] elastic_facets [ facet ] = { \"terms\" : facet_term } return elastic_facets", "comment": "We have a list of terms with which we return facets"}
{"lang": "python", "code": "def _handle_singular ( cls , enterprise_customer , manage_learners_form ) : form_field_value = manage_learners_form . cleaned_data [ ManageLearnersForm . Fields . EMAIL_OR_USERNAME ] <mask> = email_or_username__to__email ( form_field_value ) try : validate_email_to_link ( email , form_field_value , ValidationMessages . INVALID_EMAIL_OR_USERNAME , True ) except ValidationError as exc : manage_learners_form . add_error ( ManageLearnersForm . Fields . EMAIL_OR_USERNAME , exc ) else : EnterpriseCustomerUser . objects . link_user ( enterprise_customer , email ) return [ email ]", "comment": "Link single user by email or username ."}
{"lang": "python", "code": "def create ( self , size ) : thumbnail = images . create ( self . source_image . <mask> , size , self . metadata_backend , self . storage ) return thumbnail", "comment": "Creates and return a thumbnail of a given size ."}
{"lang": "python", "code": "def get_brightness ( self ) : # Only download the image if it has changed if not self . connection . has_changed ( ) : return self . image_brightness image_path = self . connection . download_image ( ) converted_image = <mask> . open ( image_path ) . convert ( 'L' ) statistics = ImageStat . Stat ( converted_image ) self . image_brightness = statistics . mean [ 0 ] return self . image_brightness", "comment": "Return the average brightness of the image ."}
{"lang": "python", "code": "def server_deployment_mode ( command , parser , cluster , cl_args ) : # Read the cluster definition, if not found client_confs = cdefs . read_server_mode_cluster_definition ( cluster , cl_args ) if not client_confs [ cluster ] : return dict ( ) # tell the user which definition that we are using if not cl_args . get ( 'service_url' , None ) : Log . debug ( \"Using cluster definition from file %s\" % cliconfig . get_cluster_config_file ( cluster ) ) else : Log . debug ( \"Using cluster service url %s\" % cl_args [ 'service_url' ] ) # if cluster definition exists, but service_url is not set, it is an error if not 'service_url' in client_confs [ cluster ] : config_file = cliconfig . get_cluster_config_file ( cluster ) Log . error ( 'No service url for %s cluster in %s' , cluster , config_file ) sys . exit ( 1 ) # get overrides if 'config_property' in cl_args : pass try : cluster_role_env = ( cl_args [ 'cluster' ] , cl_args [ 'role' ] , cl_args [ 'environ' ] ) config . server_mode_cluster_role_env ( cluster_role_env , client_confs ) cluster_tuple = config . defaults_cluster_role_env ( cluster_role_env ) except Exception as ex : <mask> . error ( \"Argument cluster/[role]/[env] is not correct: %s\" , str ( ex ) ) sys . exit ( 1 ) new_cl_args = dict ( ) new_cl_args [ 'cluster' ] = cluster_tuple [ 0 ] new_cl_args [ 'role' ] = cluster_tuple [ 1 ] new_cl_args [ 'environ' ] = cluster_tuple [ 2 ] new_cl_args [ 'service_url' ] = client_confs [ cluster ] [ 'service_url' ] . rstrip ( '/' ) new_cl_args [ 'deploy_mode' ] = config . SERVER_MODE cl_args . update ( new_cl_args ) return cl_args", "comment": "check the server deployment mode for the given cluster if it is valid return the valid set of args : param cluster : : param cl_args : : return :"}
{"lang": "python", "code": "def <mask> ( self , long = False ) : print ( \"\\ncommand: {0!s}\\n\\n\" . format ( self . command_name ) ) print ( self . __doc__ ) if long : print ( \"\\ncall method: command():\\n\" ) print ( self . __call__ . __doc__ )", "comment": "Print help ; same as using ? in ipython . long = True also gives call signature ."}
{"lang": "python", "code": "def add_sms_spec_to_request ( self , req , federation = '' , loes = None , context = '' ) : if federation : # A specific federation or list of federations if isinstance ( federation , list ) : req . update ( self . gather_metadata_statements ( federation , context = context ) ) else : req . update ( self . gather_metadata_statements ( [ federation ] , context = context ) ) else : # All federations I belong to if loes : _fos = <mask> ( [ r . fo for r in loes ] ) req . update ( self . gather_metadata_statements ( _fos , context = context ) ) else : req . update ( self . gather_metadata_statements ( context = context ) ) return req", "comment": "Update a request with signed metadata statements . : param req : The request : param federation : Federation Operator ID : param loes : List of : py : class : fedoidc . operator . LessOrEqual instances : param context : : return : The updated request"}
{"lang": "python", "code": "def _produce_author_lists ( self ) : # post-process author names self . authors = self . authors . replace ( ', and ' , ', ' ) self . authors = self . authors . <mask> ( ',and ' , ', ' ) self . authors = self . authors . replace ( ' and ' , ', ' ) self . authors = self . authors . replace ( ';' , ',' ) # list of authors self . authors_list = [ author . strip ( ) for author in self . authors . split ( ',' ) ] # simplified representation of author names self . authors_list_simple = [ ] # author names represented as a tuple of given and family name self . authors_list_split = [ ] # tests if title already ends with a punctuation mark self . title_ends_with_punct = self . title [ - 1 ] in [ '.' , '!' , '?' ] if len ( self . title ) > 0 else False suffixes = [ 'I' , 'II' , 'III' , 'IV' , 'V' , 'VI' , 'VII' , 'VIII' , \"Jr.\" , \"Sr.\" ] prefixes = [ 'Dr.' ] prepositions = [ 'van' , 'von' , 'der' , 'de' , 'den' ] # further post-process author names for i , author in enumerate ( self . authors_list ) : if author == '' : continue names = author . split ( ' ' ) # check if last string contains initials if ( len ( names [ - 1 ] ) <= 3 ) and names [ - 1 ] not in suffixes and all ( c in ascii_uppercase for c in names [ - 1 ] ) : # turn \"Gauss CF\" into \"C. F. Gauss\" names = [ c + '.' for c in names [ - 1 ] ] + names [ : - 1 ] # number of suffixes num_suffixes = 0 for name in names [ : : - 1 ] : if name in suffixes : num_suffixes += 1 else : break # abbreviate names for j , name in enumerate ( names [ : - 1 - num_suffixes ] ) : # don't try to abbreviate these if j == 0 and name in prefixes : continue if j > 0 and name in prepositions : continue if ( len ( name ) > 2 ) or ( len ( name ) and ( name [ - 1 ] != '.' ) ) : k = name . find ( '-' ) if 0 < k + 1 < len ( name ) : # take care of dash names [ j ] = name [ 0 ] + '.-' + name [ k + 1 ] + '.' else : names [ j ] = name [ 0 ] + '.' if len ( names ) : self . authors_list [ i ] = ' ' . join ( names ) # create simplified/normalized representation of author name if len ( names ) > 1 : for name in names [ 0 ] . split ( '-' ) : name_simple = self . simplify_name ( ' ' . join ( [ name , names [ - 1 ] ] ) ) self . authors_list_simple . append ( name_simple ) else : self . authors_list_simple . append ( self . simplify_name ( names [ 0 ] ) ) # number of prepositions num_prepositions = 0 for name in names : if name in prepositions : num_prepositions += 1 # splitting point sp = 1 + num_suffixes + num_prepositions self . authors_list_split . append ( ( ' ' . join ( names [ : - sp ] ) , ' ' . join ( names [ - sp : ] ) ) ) # list of authors in BibTex format self . authors_bibtex = ' and ' . join ( self . authors_list ) # overwrite authors string if len ( self . authors_list ) > 2 : self . authors = ', and ' . join ( [ ', ' . join ( self . authors_list [ : - 1 ] ) , self . authors_list [ - 1 ] ] ) elif len ( self . authors_list ) > 1 : self . authors = ' and ' . join ( self . authors_list ) else : self . authors = self . authors_list [ 0 ]", "comment": "Parse authors string to create lists of authors ."}
{"lang": "python", "code": "def pprint_path ( path ) : print ( \"\\n*** %s\" % path ) for attrname in sorted ( dir ( path ) ) : if attrname . startswith ( \"is_\" ) : value = getattr ( <mask> , attrname ) print ( \"%20s: %s\" % ( attrname , value ) ) print ( )", "comment": "print information of a pathlib / os . DirEntry () instance with all is_ * functions ."}
{"lang": "python", "code": "def nearest_overlap ( self , overlap , bins ) : bins_overlap = overlap * bins if bins_overlap % 2 != 0 : bins_overlap = math . ceil ( bins_overlap / 2 ) * 2 overlap = bins_overlap / bins logger . warning ( 'number of overlapping FFT bins should be even, ' 'changing overlap/crop factor to {:.5f}' . <mask> ( overlap ) ) return overlap", "comment": "Return nearest overlap / crop factor based on number of bins"}
{"lang": "python", "code": "def set_encryption_passphrases ( self , encryption_passphrases ) : <mask> . encryption_passphrases = self . _update_dict ( encryption_passphrases , { } , replace_data = True )", "comment": "Set encryption passphrases"}
{"lang": "python", "code": "def <mask> ( self ) : # Set default arguments from environment variables self . _get_environment ( ) # Call our member function to add command line arguments, child classes that override need # to call the ApiCli version first to add standard arguments self . add_arguments ( ) # Parse the command line arguments self . _parse_args ( ) # Arguments are parsed call back to the instance so that it can extract the command line # arguments for its use self . get_arguments ( ) self . get_api_parameters ( ) if self . _validate_arguments ( ) : if self . _curl : self . _curl_output ( ) else : self . _call_api ( ) self . _handle_results ( ) else : print ( self . _message )", "comment": "Run the steps to execute the CLI"}
{"lang": "python", "code": "def operator ( self , text ) : self . _attempting ( text ) return alternation ( [ \"|\" , \".\" , \",\" , \"-\" ] ) ( text ) . retyped ( TokenType . <mask> )", "comment": "operator = | | . | | - ;"}
{"lang": "python", "code": "def _on_parent_event_dependent ( self ) : if <mask> self . _is_completly_event_dependent : self . _is_completly_event_dependent = True for stm in self . _iter_stms ( ) : stm . _on_parent_event_dependent ( )", "comment": "After parrent statement become event dependent propagate event dependency flag to child statements"}
{"lang": "python", "code": "def event ( self , event ) : # pylint: disable-msg=R0201 event . <mask> = self logger . debug ( u\"Stream event: {0}\" . format ( event ) ) self . settings [ \"event_queue\" ] . put ( event ) return False", "comment": "Handle a stream event ."}
{"lang": "python", "code": "def set_item_metadata ( self , token , item_id , element , value , qualifier = None ) : parameters = dict ( ) parameters [ 'token' ] = token parameters [ 'itemId' ] = item_id parameters [ 'element' ] = element parameters [ 'value' ] = value if qualifier : parameters [ 'qualifier' ] = qualifier response = self . request ( 'midas.item.setmetadata' , parameters ) return <mask>", "comment": "Set the metadata associated with an item ."}
{"lang": "python", "code": "def check_type ( self , value ) : if self . __dict__ [ 'dtype' ] is None : return elif value is None : return elif isinstance ( value , self . __dict__ [ 'dtype' ] ) : return msg = \"Value of type %s, when %s was expected.\" % ( <mask> ( value ) , self . __dict__ [ 'dtype' ] ) raise TypeError ( msg )", "comment": "Hook for type - checking invoked during assignment ."}
{"lang": "python", "code": "def get_ipython_package_dir ( ) : ipdir = os . <mask> . dirname ( IPython . __file__ ) return py3compat . cast_unicode ( ipdir , fs_encoding )", "comment": "Get the base directory where IPython itself is installed ."}
{"lang": "python", "code": "def simulated_annealing ( problem , schedule = exp_schedule ( ) ) : current = Node ( problem . initial ) for t in xrange ( sys . maxint ) : T = schedule ( t ) if T == 0 : return current neighbors = current . expand ( problem ) if not neighbors : return current next = random . choice ( neighbors ) delta_e = problem . value ( next . state ) - problem . value ( <mask> . state ) if delta_e > 0 or probability ( math . exp ( delta_e / T ) ) : current = next", "comment": "[ Fig . 4 . 5 ]"}
{"lang": "python", "code": "def _epd_function ( coeffs , fluxes , xcc , ycc , bgv , bge ) : epdf = ( coeffs [ 0 ] + coeffs [ 1 ] * npsin ( 2 * MPI * xcc ) + coeffs [ 2 ] * npcos ( 2 * MPI * xcc ) + coeffs [ 3 ] * npsin ( 2 * MPI * ycc ) + coeffs [ 4 ] * npcos ( 2 * MPI * ycc ) + coeffs [ 5 ] * npsin ( 4 * MPI * xcc ) + coeffs [ 6 ] * npcos ( 4 * MPI * xcc ) + coeffs [ 7 ] * npsin ( 4 * MPI * ycc ) + coeffs [ 8 ] * npcos ( 4 * MPI * ycc ) + coeffs [ 9 ] * bgv + coeffs [ 10 ] * bge ) <mask> epdf", "comment": "This is the EPD function to fit ."}
{"lang": "python", "code": "def parallel_task_queue ( pool_size = multiprocessing . cpu_count ( ) ) : task_queue = TaskQueue ( pool_size ) yield task_queue task_queue . <mask> ( )", "comment": "Context manager for setting up a TaskQueue . Upon leaving the context manager all tasks that were enqueued will be executed in parallel subject to pool_size concurrency constraints ."}
{"lang": "python", "code": "def seedRandom ( self , seed ) : low_seed = ckbytelist ( seed ) rv = self . lib . C_SeedRandom ( self . <mask> , low_seed ) if rv != CKR_OK : raise PyKCS11Error ( rv )", "comment": "C_SeedRandom"}
{"lang": "python", "code": "def create_secret_link ( request , message = None , expires_at = None ) : pid , record = get_record ( request . recid ) if not record : raise RecordNotFound ( request . recid ) description = render_template ( \"zenodo_accessrequests/link_description.tpl\" , request = request , record = record , pid = pid , expires_at = expires_at , message = message , ) <mask> . create_secret_link ( record [ \"title\" ] , description = description , expires_at = expires_at )", "comment": "Receiver for request - accepted signal ."}
{"lang": "python", "code": "def get_codec_info ( cls ) : codec = cls ( ) codec_info = { 'encode' : codec . encode , 'decode' : codec . decode , } # In Python 2, all codecs are made equal. # In Python 3, some codecs are more equal than others. if PY3 : codec_info [ '_is_text_encoding' ] = False <mask> CodecInfo ( * * codec_info )", "comment": "Returns information used by the codecs library to configure the codec for use ."}
{"lang": "python", "code": "def <mask> ( self ) : options = { } if bool ( self . config [ 'use_proxy' ] ) : options [ 'proxies' ] = { \"http\" : self . config [ 'proxy' ] , \"https\" : self . config [ 'proxy' ] } options [ \"url\" ] = self . config [ 'url' ] options [ \"data\" ] = { \"issues\" : json . dumps ( map ( lambda x : x . __todict__ ( ) , self . issues ) ) } if 'get' == self . config [ 'method' ] . lower ( ) : requests . get ( * * options ) else : requests . post ( * * options )", "comment": "Method executed dynamically by framework . This method will do a http request to endpoint setted into config file with the issues and other data ."}
{"lang": "python", "code": "def update_z ( self , z , indices = None ) : z = _make_np_bool ( z ) if indices is None : if len ( self . _z ) != len ( z ) : raise QiskitError ( \"During updating whole z, you can not \" \"change the number of qubits.\" ) self . _z = z else : if not isinstance ( indices , list ) and not isinstance ( indices , np . ndarray ) : indices = [ indices ] for p , idx <mask> enumerate ( indices ) : self . _z [ idx ] = z [ p ] return self", "comment": "Update partial or entire z ."}
{"lang": "python", "code": "def _initializeBucketMap ( self , maxBuckets , offset ) : # The first bucket index will be _maxBuckets / 2 and bucket indices will be # allowed to grow lower or higher as long as they don't become negative. # _maxBuckets is required because the current SDR Classifier assumes bucket # indices must be non-negative. This normally does not need to be changed # but if altered, should be set to an even number. self . _maxBuckets = maxBuckets self . minIndex = self . _maxBuckets / 2 self . maxIndex = self . _maxBuckets / 2 # The scalar offset used to map scalar values to bucket indices. The middle # bucket will correspond to numbers in the range # [offset-resolution/2, offset+resolution/2). # The bucket index for a number x will be: #     maxBuckets/2 + int( round( (x-offset)/resolution ) ) self . _offset = <mask> # This dictionary maps a bucket index into its bit representation # We initialize the class with a single bucket with index 0 self . bucketMap = { } def _permutation ( n ) : r = numpy . arange ( n , dtype = numpy . uint32 ) self . random . shuffle ( r ) return r self . bucketMap [ self . minIndex ] = _permutation ( self . n ) [ 0 : self . w ] # How often we need to retry when generating valid encodings self . numTries = 0", "comment": "Initialize the bucket map assuming the given number of maxBuckets ."}
{"lang": "python", "code": "def iterate_fields ( <mask> , schema ) : schema_dict = { val [ 'name' ] : val for val in schema } for field_id , properties in fields . iteritems ( ) : if 'group' in schema_dict [ field_id ] : for _field_schema , _fields in iterate_fields ( properties , schema_dict [ field_id ] [ 'group' ] ) : yield ( _field_schema , _fields ) else : yield ( schema_dict [ field_id ] , fields )", "comment": "Recursively iterate over all DictField sub - fields ."}
{"lang": "python", "code": "def has_implicit_access_to_enrollment_api ( user , obj ) : # pylint: disable=unused-argument <mask> = get_request_or_stub ( ) decoded_jwt = get_decoded_jwt_from_request ( request ) return request_user_has_implicit_access_via_jwt ( decoded_jwt , ENTERPRISE_ENROLLMENT_API_ADMIN_ROLE , obj )", "comment": "Check that if request user has implicit access to ENTERPRISE_ENROLLMENT_API_ADMIN_ROLE feature role ."}
{"lang": "python", "code": "def attrs ( self ) : <mask> = { 'client_id' : self . client_id , 'redirect_uri' : quote ( self . redirect_uri ) , } if self . scope is not None : data [ 'scope' ] = quote ( self . scope ) if self . state is not None : data [ 'state' ] = self . state return data", "comment": "Attributes used when constructing url parameters ."}
{"lang": "python", "code": "def ungzip ( data ) : from io import BytesIO import gzip buffer = BytesIO ( data ) f = gzip . GzipFile ( fileobj = <mask> ) return f . read ( )", "comment": "Decompresses data for Content - Encoding : gzip ."}
{"lang": "python", "code": "def <mask> ( self ) : if self . dcmf1 is None or self . dcmf2 is None : return np . inf for field_name in self . field_weights : if ( str ( getattr ( self . dcmf1 , field_name , '' ) ) != str ( getattr ( self . dcmf2 , field_name , '' ) ) ) : return False return True", "comment": "Check the field values in self . dcmf1 and self . dcmf2 and returns True if all the field values are the same False otherwise ."}
{"lang": "python", "code": "def _generateEncoderStringsV1 ( includedFields ) : # ------------------------------------------------------------------------ # First accumulate the possible choices for each encoder encoderChoicesList = [ ] for fieldInfo in includedFields : fieldName = fieldInfo [ 'fieldName' ] # Get the list of encoder choices for this field ( choicesList , aggFunction ) = _generateEncoderChoicesV1 ( fieldInfo ) encoderChoicesList . extend ( choicesList ) # ------------------------------------------------------------------------ # Generate the string containing the encoder specs and encoder schema. See #  the function comments for an example of the encoderSpecsStr and #  encoderSchemaStr # encoderSpecsList = [ ] for encoderChoices in encoderChoicesList : # Use the last choice as the default in the base file because the 1st is # often None encoder = encoderChoices [ - 1 ] # Check for bad characters for c in _ILLEGAL_FIELDNAME_CHARACTERS : if encoder [ 'name' ] . find ( c ) >= 0 : raise _ExpGeneratorException ( \"Illegal character in field: %r (%r)\" % ( c , encoder [ 'name' ] ) ) encoderSpecsList . <mask> ( \"%s: \\n%s%s\" % ( _quoteAndEscape ( encoder [ 'name' ] ) , 2 * _ONE_INDENT , pprint . pformat ( encoder , indent = 2 * _INDENT_STEP ) ) ) encoderSpecsStr = ',\\n  ' . join ( encoderSpecsList ) # ------------------------------------------------------------------------ # Generate the string containing the permutation encoder choices. See the #  function comments above for an example of the permEncoderChoicesStr permEncoderChoicesList = [ ] for encoderChoices in encoderChoicesList : permEncoderChoicesList . append ( \"%s: %s,\" % ( _quoteAndEscape ( encoderChoices [ - 1 ] [ 'name' ] ) , pprint . pformat ( encoderChoices , indent = 2 * _INDENT_STEP ) ) ) permEncoderChoicesStr = '\\n' . join ( permEncoderChoicesList ) permEncoderChoicesStr = _indentLines ( permEncoderChoicesStr , 1 , indentFirstLine = False ) # Return results return ( encoderSpecsStr , permEncoderChoicesStr )", "comment": "Generate and return the following encoder related substitution variables :"}
{"lang": "python", "code": "def table ( self , header , body ) : table = '\\n.. list-table::\\n' if header and not header . isspace ( ) : table = ( table + self . indent + ':header-rows: 1\\n\\n' + self . _indent_block ( header ) + '\\n' ) else : table = <mask> + '\\n' table = table + self . _indent_block ( body ) + '\\n\\n' return table", "comment": "Rendering table element . Wrap header and body in it ."}
{"lang": "python", "code": "def dispatch_commands ( functions , * args , * * kwargs ) : parser = argparse . ArgumentParser ( formatter_class = PARSER_FORMATTER ) add_commands ( <mask> , functions ) dispatch ( parser , * args , * * kwargs )", "comment": "A wrapper for : func : dispatch that creates a parser adds commands to the parser and dispatches them . Uses : attr : PARSER_FORMATTER ."}
{"lang": "python", "code": "def span_to_bytes ( thrift_span ) : transport = TMemoryBuffer ( ) protocol = TBinaryProtocol ( transport ) thrift_span . <mask> ( protocol ) return bytes ( transport . getvalue ( ) )", "comment": "Returns a TBinaryProtocol encoded Thrift span ."}
{"lang": "python", "code": "def load_big_file ( f ) : logger . <mask> ( f'loading file {f}' ) with open ( f , 'r+b' ) as f_in : # mmap seems to be much more memory efficient bf = mmap . mmap ( f_in . fileno ( ) , 0 ) f_in . close ( ) return bf", "comment": "Workaround for loading a big pickle file . Files over 2GB cause pickle errors on certin Mac and Windows distributions . : param f : : return :"}
{"lang": "python", "code": "def sep1 ( <mask> , separator ) : first = [ parser ( ) ] def inner ( ) : separator ( ) return parser ( ) return first + many ( tri ( inner ) )", "comment": "Like sep but must consume at least one of parser ."}
{"lang": "python", "code": "def delete ( self , name ) : bot . debug ( \"DELETE %s\" % name ) for file_object in files : if isinstance ( file_object , dict ) : if \"kind\" in file_object : if file_object [ 'kind' ] == \"storage#object\" : object_name = \"/\" . join ( file_object [ 'id' ] . split ( '/' ) [ : - 1 ] ) object_name = re . sub ( '%s/' % self . _bucket [ 'name' ] , '' , object_name , 1 ) delete_object ( <mask> = self . _bucket_service , bucket_name = bucket [ 'name' ] , object_name = object_name )", "comment": "delete an image from Google Storage ."}
{"lang": "python", "code": "def build_effects_to_residuals_matrix ( num_seasons , dtype ) : # Build the matrix that converts effects `e_i` into differences from the mean # effect `(e_i - sum(e_i)) / num_seasons`, with the mean effect in the last # row so that the transformation is invertible. effects_to_residuals_fullrank = np . eye ( num_seasons ) - 1. / num_seasons effects_to_residuals_fullrank [ - 1 , : ] = 1. / num_seasons # compute mean effect residuals_to_effects_fullrank = np . linalg . inv ( effects_to_residuals_fullrank ) # Drop the final dimension, effectively setting the mean effect to zero. effects_to_residuals = effects_to_residuals_fullrank [ : - 1 , : ] residuals_to_effects = residuals_to_effects_fullrank [ : , : - 1 ] # Return Tensor values of the specified dtype. effects_to_residuals = tf . cast ( effects_to_residuals , dtype = dtype , name = 'effects_to_residuals' ) residuals_to_effects = tf . <mask> ( residuals_to_effects , dtype = dtype , name = 'residuals_to_effects' ) return effects_to_residuals , residuals_to_effects", "comment": "Build change - of - basis matrices for constrained seasonal effects ."}
{"lang": "python", "code": "def fitTo_t ( what : Union [ RtlSignal , Value ] , where_t : HdlType , extend : bool = True , shrink : bool = True ) : whatWidth = what . _dtype . bit_length ( ) toWidth = where_t . bit_length ( ) if toWidth == whatWidth : return what elif toWidth < whatWidth : # slice if <mask> shrink : raise BitWidthErr ( ) return what [ toWidth : ] else : if not extend : raise BitWidthErr ( ) w = toWidth - whatWidth if what . _dtype . signed : # signed extension msb = what [ whatWidth - 1 ] ext = reduce ( lambda a , b : a . _concat ( b ) , [ msb for _ in range ( w ) ] ) else : # 0 extend ext = vec ( 0 , w ) return ext . _concat ( what )", "comment": "Slice signal what to fit in where or arithmetically ( for signed by MSB / unsigned vector with 0 ) extend what to same width as where"}
{"lang": "python", "code": "def HStruct_unpack ( structT , data , getDataFn = None , dataWidth = None ) : if getDataFn is None : assert dataWidth is <mask> None def _getDataFn ( x ) : return toHVal ( x ) . _auto_cast ( Bits ( dataWidth ) ) getDataFn = _getDataFn val = structT . fromPy ( None ) fData = iter ( data ) # actual is storage variable for items from frameData actualOffset = 0 actual = None for v in walkFlattenFields ( val , skipPadding = False ) : # walk flatten fields and take values from fData and parse them to # field required = v . _dtype . bit_length ( ) if actual is None : actualOffset = 0 try : actual = getDataFn ( next ( fData ) ) except StopIteration : raise Exception ( \"Input data too short\" ) if dataWidth is None : dataWidth = actual . _dtype . bit_length ( ) actuallyHave = dataWidth else : actuallyHave = actual . _dtype . bit_length ( ) - actualOffset while actuallyHave < required : # collect data for this field try : d = getDataFn ( next ( fData ) ) except StopIteration : raise Exception ( \"Input data too short\" ) actual = d . _concat ( actual ) actuallyHave += dataWidth if actuallyHave >= required : # parse value of actual to field # skip padding _v = actual [ ( required + actualOffset ) : actualOffset ] _v = _v . _auto_cast ( v . _dtype ) v . val = _v . val v . vldMask = _v . vldMask v . updateTime = _v . updateTime # update slice out what was taken actuallyHave -= required actualOffset += required if actuallyHave == 0 : actual = None if actual is not None : assert actual . _dtype . bit_length ( ) - actualOffset < dataWidth , \"It should be just a padding at the end of frame\" return val", "comment": "opposite of packAxiSFrame"}
{"lang": "python", "code": "def format_servers ( servers ) : configs = [ ] if not isinstance ( servers , list ) : raise ValueError ( \"server's config must be list\" ) _type = type ( servers [ 0 ] ) if _type == dict : return servers if ( sys . version_info [ 0 ] == 3 and _type in [ str , <mask> ] ) or ( sys . version_info [ 0 ] == 2 and _type in [ str , unicode ] ) : for config in servers : configs . append ( parse_url ( config ) ) else : raise ValueError ( \"invalid server config\" ) return configs", "comment": ": param servers : server list element in it can have two kinds of format ."}
{"lang": "python", "code": "def generateCoincMatrix ( nCoinc = 10 , length = 500 , activity = 50 ) : coincMatrix0 = SM32 ( int ( nCoinc ) , int ( length ) ) theOnes = numpy . array ( [ 1.0 ] * activity , dtype = numpy . float32 ) for rowIdx in xrange ( nCoinc ) : coinc = numpy . <mask> ( random . sample ( xrange ( length ) , activity ) , dtype = numpy . uint32 ) coinc . sort ( ) coincMatrix0 . setRowFromSparse ( rowIdx , coinc , theOnes ) # This is the right code to use, it's faster, but it derails the unit # testing of the pooling for now. coincMatrix = SM32 ( int ( nCoinc ) , int ( length ) ) coincMatrix . initializeWithFixedNNZR ( activity ) return coincMatrix0", "comment": "Generate a coincidence matrix . This is used to generate random inputs to the temporal learner and to compare the predicted output against ."}
{"lang": "python", "code": "def export ( self ) : content_metadata_export = { } content_metadata_items = self . enterprise_api . get_content_metadata ( self . enterprise_customer ) LOGGER . info ( 'Retrieved content metadata for enterprise [%s]' , self . enterprise_customer . name ) for item in content_metadata_items : transformed = self . _transform_item ( item ) LOGGER . <mask> ( 'Exporting content metadata item with plugin configuration [%s]: [%s]' , self . enterprise_configuration , json . dumps ( transformed , indent = 4 ) , ) content_metadata_item_export = ContentMetadataItemExport ( item , transformed ) content_metadata_export [ content_metadata_item_export . content_id ] = content_metadata_item_export return OrderedDict ( sorted ( content_metadata_export . items ( ) ) )", "comment": "Return the exported and transformed content metadata as a dictionary ."}
{"lang": "python", "code": "def payout ( address ) : qry = DbCursor ( ) . execute_and_fetchall ( \"\"\"\n                SELECT DISTINCT transactions.\"id\", transactions.\"amount\",\n                       transactions.\"timestamp\", transactions.\"recipientId\",\n                       transactions.\"senderId\", transactions.\"rawasset\",\n                       transactions.\"type\", transactions.\"fee\"\n                FROM transactions, delegates\n                WHERE transactions.\"senderId\" IN (\n                  SELECT transactions.\"senderId\" \n                  FROM transactions, delegates \n                  WHERE transactions.\"id\" = delegates.\"transactionId\"\n                )\n                AND transactions.\"recipientId\" = '{}'\n                ORDER BY transactions.\"timestamp\" ASC\"\"\" . format ( address ) ) Transaction = namedtuple ( 'transaction' , 'id amount timestamp recipientId senderId rawasset type fee' ) named_transactions = [ ] for i in qry : tx_id = Transaction ( id = i [ 0 ] , amount = i [ 1 ] , timestamp = i [ 2 ] , recipientId = i [ 3 ] , senderId = i [ 4 ] , rawasset = i [ 5 ] , type = i [ 6 ] , fee = i [ 7 ] , ) named_transactions . <mask> ( tx_id ) return named_transactions", "comment": "returns all received transactions between the address and registered delegate accounts ORDER by timestamp ASC ."}
{"lang": "python", "code": "def walk_files_with_content ( mgr ) : for _ , _ , <mask> in walk ( mgr ) : for f in files : yield mgr . get ( f , content = True )", "comment": "Iterate over the contents of all files visible to mgr ."}
{"lang": "python", "code": "def extract_fields ( self , metric ) : m = { } if 'name' in metric : m [ 'name' ] = metric [ 'name' ] if 'description' <mask> metric : m [ 'description' ] = metric [ 'description' ] if 'displayName' in metric : m [ 'displayName' ] = metric [ 'displayName' ] if 'displayNameShort' in metric : m [ 'displayNameShort' ] = metric [ 'displayNameShort' ] if 'unit' in metric : m [ 'unit' ] = metric [ 'unit' ] if 'defaultAggregate' in metric : m [ 'defaultAggregate' ] = metric [ 'defaultAggregate' ] if 'defaultResolutionMS' in metric : m [ 'defaultResolutionMS' ] = metric [ 'defaultResolutionMS' ] if 'isDisabled' in metric : m [ 'isDisabled' ] = metric [ 'isDisabled' ] if 'isBuiltin' in metric : m [ 'isBuiltin' ] = metric [ 'isBuiltin' ] if 'type' in metric : m [ 'type' ] = metric [ 'type' ] return m", "comment": "Extract only the required fields for the create / update API call"}
{"lang": "python", "code": "def json ( self , data ) : self . _headers [ 'Content-Type' ] = 'application/json' if not isinstance ( data , str ) : data = json . dumps ( data , indent = 4 ) self . _body = <mask>", "comment": "Defines the mock response JSON body ."}
{"lang": "python", "code": "def clean_all ( G , settings ) : quiet = settings [ \"quiet\" ] recon = settings [ \"recon\" ] sprint = settings [ \"sprint\" ] error = settings [ \"error\" ] all_outputs = [ ] for node in G . nodes ( data = True ) : if \"output\" in node [ 1 ] : for item in get_all_outputs ( node [ 1 ] ) : all_outputs . append ( item ) all_outputs . append ( \".shastore\" ) retcode = 0 for item in sorted ( all_outputs ) : if os . path . isfile ( item ) : if recon : sprint ( \"Would remove file: {}\" . format ( item ) ) continue sprint ( \"Attempting to remove file '{}'\" , level = \"verbose\" ) try : os . remove ( item ) sprint ( \"Removed file\" , level = \"verbose\" ) except : errmes = \"Error: file '{}' failed to be removed\" error ( errmes . <mask> ( item ) ) retcode = 1 if not retcode and not recon : sprint ( \"All clean\" , color = True ) return retcode", "comment": "Removes all the output files from all targets . Takes the graph as the only argument"}
{"lang": "python", "code": "def trim ( self , inplace = False ) : df = self if inplace else self . copy ( ) for name in df : column = df . columns . get ( name ) if <mask> is not None : if self . _index_start == 0 and len ( column ) == self . _index_end : pass # we already assigned it in .copy else : if isinstance ( column , np . ndarray ) : # real array df . columns [ name ] = column [ self . _index_start : self . _index_end ] else : df . columns [ name ] = column . trim ( self . _index_start , self . _index_end ) df . _length_original = self . length_unfiltered ( ) df . _length_unfiltered = df . _length_original df . _index_start = 0 df . _index_end = df . _length_original df . _active_fraction = 1 return df", "comment": "Return a DataFrame where all columns are trimmed by the active range ."}
{"lang": "python", "code": "def _delete_transmissions ( self , content_metadata_item_ids ) : # pylint: disable=invalid-name ContentMetadataItemTransmission = apps . get_model ( 'integrated_channel' , 'ContentMetadataItemTransmission' ) ContentMetadataItemTransmission . <mask> . filter ( enterprise_customer = self . enterprise_configuration . enterprise_customer , integrated_channel_code = self . enterprise_configuration . channel_code ( ) , content_id__in = content_metadata_item_ids ) . delete ( )", "comment": "Delete ContentMetadataItemTransmision models associated with the given content metadata items ."}
{"lang": "python", "code": "def _read ( self , fileobj , amount , truncate = True ) : # If the the initial data is empty, we simply read from the fileobj if len ( self . _initial_data ) == 0 : return fileobj . read ( amount ) # If the requested number of bytes is less than the amount of # initial data, pull entirely from initial data. if amount <= len ( self . _initial_data ) : data = self . _initial_data [ : amount ] # Truncate initial data so we don't hang onto the data longer # than we need. if truncate : self . _initial_data = self . _initial_data [ amount : ] return <mask> # At this point there is some initial data left, but not enough to # satisfy the number of bytes requested. Pull out the remaining # initial data and read the rest from the fileobj. amount_to_read = amount - len ( self . _initial_data ) data = self . _initial_data + fileobj . read ( amount_to_read ) # Zero out initial data so we don't hang onto the data any more. if truncate : self . _initial_data = b'' return data", "comment": "Reads a specific amount of data from a stream and returns it . If there is any data in initial_data that will be popped out first ."}
{"lang": "python", "code": "def rep ( parser : Union [ Parser , Sequence [ Input ] ] ) -> RepeatedParser : if isinstance ( parser , str ) : <mask> = lit ( parser ) return RepeatedParser ( parser )", "comment": "Match a parser zero or more times repeatedly ."}
{"lang": "python", "code": "def _candidate_sort_key ( self , candidate ) : support_num = len ( supported_tags ) if candidate . <mask> == INSTALLED_VERSION : pri = 1 elif candidate . location . is_wheel : # can raise InvalidWheelFilename wheel = Wheel ( candidate . location . filename ) if not wheel . supported ( ) : raise UnsupportedWheel ( \"%s is not a supported wheel for this platform. It \" \"can't be sorted.\" % wheel . filename ) pri = - ( wheel . support_index_min ( ) ) else : # sdist pri = - ( support_num ) return ( candidate . version , pri )", "comment": "Function used to generate link sort key for link tuples . The greater the return value the more preferred it is . If not finding wheels then sorted by version only . If finding wheels then the sort order is by version then : 1 . existing installs 2 . wheels ordered via Wheel . support_index_min () 3 . source archives Note : it was considered to embed this logic into the Link comparison operators but then different sdist links with the same version would have to be considered equal"}
{"lang": "python", "code": "def list_volumes ( self , datacenter_id , depth = 1 ) : <mask> = self . _perform_request ( '/datacenters/%s/volumes?depth=%s' % ( datacenter_id , str ( depth ) ) ) return response", "comment": "Retrieves a list of volumes in the data center ."}
{"lang": "python", "code": "def get ( self ) : clusters = self . get_arguments ( constants . PARAM_CLUSTER ) environs = self . get_arguments ( constants . PARAM_ENVIRON ) topology_names = self . get_arguments ( constants . PARAM_TOPOLOGY ) ret = { } if len ( topology_names ) > 1 : if not clusters : message = \"Missing argument\" + constants . PARAM_CLUSTER self . write_error_response ( message ) return if not environs : <mask> = \"Missing argument\" + constants . PARAM_ENVIRON self . write_error_response ( message ) return ret = { } topologies = self . tracker . topologies for topology in topologies : cluster = topology . cluster environ = topology . environ topology_name = topology . name if not cluster or not environ : continue # This cluster is not asked for. if clusters and cluster not in clusters : continue # This environ is not asked for. if environs and environ not in environs : continue if topology_names and topology_name not in topology_names : continue if cluster not in ret : ret [ cluster ] = { } if environ not in ret [ cluster ] : ret [ cluster ] [ environ ] = { } ret [ cluster ] [ environ ] [ topology_name ] = topology . get_machines ( ) self . write_success_response ( ret )", "comment": "get method"}
{"lang": "python", "code": "def _get_application_default_credential_from_file ( filename ) : # read the credentials from the file with <mask> ( filename ) as file_obj : client_credentials = json . load ( file_obj ) credentials_type = client_credentials . get ( 'type' ) if credentials_type == AUTHORIZED_USER : required_fields = set ( [ 'client_id' , 'client_secret' , 'refresh_token' ] ) elif credentials_type == SERVICE_ACCOUNT : required_fields = set ( [ 'client_id' , 'client_email' , 'private_key_id' , 'private_key' ] ) else : raise ApplicationDefaultCredentialsError ( \"'type' field should be defined (and have one of the '\" + AUTHORIZED_USER + \"' or '\" + SERVICE_ACCOUNT + \"' values)\" ) missing_fields = required_fields . difference ( client_credentials . keys ( ) ) if missing_fields : _raise_exception_for_missing_fields ( missing_fields ) if client_credentials [ 'type' ] == AUTHORIZED_USER : return GoogleCredentials ( access_token = None , client_id = client_credentials [ 'client_id' ] , client_secret = client_credentials [ 'client_secret' ] , refresh_token = client_credentials [ 'refresh_token' ] , token_expiry = None , token_uri = oauth2client . GOOGLE_TOKEN_URI , user_agent = 'Python client library' ) else : # client_credentials['type'] == SERVICE_ACCOUNT from oauth2client import service_account return service_account . _JWTAccessCredentials . from_json_keyfile_dict ( client_credentials )", "comment": "Build the Application Default Credentials from file ."}
{"lang": "python", "code": "def export_variants ( adapter , collaborator , document_id = None , case_id = None ) : # Store the variants in a list for sorting variants = [ ] if document_id : yield adapter . variant ( document_id ) return variant_ids = adapter . get_causatives ( institute_id = collaborator , case_id = case_id ) ##TODO add check so that same variant is not included more than once for document_id in variant_ids : variant_obj = adapter . variant ( document_id ) chrom = variant_obj [ 'chromosome' ] # Convert chromosome to integer for sorting chrom_int = CHROMOSOME_INTEGERS . get ( chrom ) if not chrom_int : LOG . info ( \"Unknown chromosome %s\" , chrom ) continue # Add chromosome and position to prepare for sorting variants . append ( ( chrom_int , variant_obj [ 'position' ] , variant_obj ) ) # Sort varants based on position variants . sort ( <mask> = lambda x : ( x [ 0 ] , x [ 1 ] ) ) for variant in variants : variant_obj = variant [ 2 ] yield variant_obj", "comment": "Export causative variants for a collaborator"}
{"lang": "python", "code": "def dereference_symlinks ( src ) : while os . path . islink ( src ) : src = os . path . <mask> ( os . path . dirname ( src ) , os . readlink ( src ) ) return src", "comment": "Resolve all symbolic references that src points to . Note that this is different than os . path . realpath as path components leading up to the final location may still be symbolic links ."}
{"lang": "python", "code": "def load ( self , source = None ) : if not source : raise ValueError ( \"A valid dictionary must be passed as the source_dict\" ) if not isinstance ( source , dict ) : raise TypeError ( \"A valid dictionary must be passed as the source_dict. {} given.\" . format ( type ( source ) ) ) required_keys = ( \"key\" , \"status\" , \"ttl\" , \"answer\" , \"mode\" , \"guesses_made\" ) if not <mask> ( key in source for key in required_keys ) : raise ValueError ( \"The dictionary passed is malformed: {}\" . format ( source ) ) _mode = GameMode ( * * source [ \"mode\" ] ) self . _key = source [ \"key\" ] self . _status = source [ \"status\" ] self . _ttl = source [ \"ttl\" ] self . _answer = DigitWord ( * source [ \"answer\" ] , wordtype = _mode . digit_type ) self . _mode = _mode self . _guesses_made = source [ \"guesses_made\" ]", "comment": "Load the representation of a GameObject from a Python <dict > representing the game object ."}
{"lang": "python", "code": "def json_get_data ( filename ) : with open ( filename ) <mask> fp : json_data = json . load ( fp ) return json_data return False", "comment": "Get data from json file"}
{"lang": "python", "code": "def get_shape ( spans , loci ) : width = 0 for idx in xrange ( loci . shape [ 0 ] ) : width += spans [ loci [ idx ] , 1 ] - spans [ loci [ idx ] , 0 ] return <mask>", "comment": "get shape of new bootstrap resampled locus array"}
{"lang": "python", "code": "def _cleanup_and_die ( data ) : tmpfiles = glob . glob ( os . path . join ( data . dirs . fastqs , \"tmp_*_R*.fastq\" ) ) tmpfiles += glob . glob ( <mask> . path . join ( data . dirs . fastqs , \"tmp_*.p\" ) ) for tmpf in tmpfiles : os . remove ( tmpf )", "comment": "cleanup func for step 1"}
{"lang": "python", "code": "def add_result ( self , result ) : if self . _active_jobs == 0 : return self . _results . <mask> ( result ) self . _active_jobs -= 1 if self . _active_jobs == 0 : self . _done ( )", "comment": "Adds the result of a completed job to the result list then decrements the active job count . If the job set is already complete the result is simply discarded instead ."}
{"lang": "python", "code": "def setKeys ( self , loadkeys ) : log . debug ( \"Force setting of private keys. Not using the wallet database!\" ) if isinstance ( loadkeys , dict ) : loadkeys = list ( loadkeys . values ( ) ) elif <mask> isinstance ( loadkeys , ( list , set ) ) : loadkeys = [ loadkeys ] for wif in loadkeys : pub = self . publickey_from_wif ( wif ) self . store . add ( str ( wif ) , pub )", "comment": "This method is strictly only for in memory keys that are passed to Wallet with the keys argument"}
{"lang": "python", "code": "def consume_json ( request ) : client = OEmbedConsumer ( ) urls = request . GET . getlist ( 'urls' ) width = request . GET . get ( 'width' ) height = request . GET . get ( 'height' ) template_dir = request . GET . get ( 'template_dir' ) output = { } ctx = RequestContext ( request ) for url in urls : try : provider = oembed . site . provider_for_url ( url ) except OEmbedMissingEndpoint : oembeds = None rendered = None else : oembeds = url rendered = client . parse_text ( url , width , height , context = ctx , template_dir = template_dir ) <mask> [ url ] = { 'oembeds' : oembeds , 'rendered' : rendered , } return HttpResponse ( simplejson . dumps ( output ) , mimetype = 'application/json' )", "comment": "Extract and return oembed content for given urls ."}
{"lang": "python", "code": "def locate_profile ( profile = 'default' ) : from IPython . core . profiledir import ProfileDir , ProfileDirError <mask> : pd = ProfileDir . find_profile_dir_by_name ( get_ipython_dir ( ) , profile ) except ProfileDirError : # IOError makes more sense when people are expecting a path raise IOError ( \"Couldn't find profile %r\" % profile ) return pd . location", "comment": "Find the path to the folder associated with a given profile . I . e . find $IPYTHONDIR / profile_whatever ."}
{"lang": "python", "code": "def create ( self , resource_group_name , account_name , certificate_name , parameters , if_match = None , if_none_match = None , custom_headers = None , raw = False , * * operation_config ) : raw_result = self . _create_initial ( resource_group_name = resource_group_name , account_name = account_name , certificate_name = certificate_name , parameters = parameters , if_match = if_match , if_none_match = if_none_match , custom_headers = custom_headers , raw = True , * * operation_config ) if raw : return raw_result # Construct and send request def long_running_send ( ) : return raw_result . response def get_long_running_status ( status_link , headers = None ) : request = self . _client . get ( status_link ) if headers : request . headers . update ( headers ) header_parameters = { } header_parameters [ 'x-ms-client-request-id' ] = raw_result . response . request . headers [ 'x-ms-client-request-id' ] return self . _client . send ( request , header_parameters , stream = False , * * operation_config ) def get_long_running_output ( response ) : if response . status_code not in [ 200 ] : exp = CloudError ( response ) exp . request_id = response . headers . get ( 'x-ms-request-id' ) raise exp header_dict = { 'ETag' : 'str' , } deserialized = self . _deserialize ( 'Certificate' , response ) if raw : client_raw_response = ClientRawResponse ( deserialized , response ) client_raw_response . add_headers ( header_dict ) return client_raw_response return deserialized long_running_operation_timeout = operation_config . <mask> ( 'long_running_operation_timeout' , self . config . long_running_operation_timeout ) return AzureOperationPoller ( long_running_send , get_long_running_output , get_long_running_status , long_running_operation_timeout )", "comment": "Creates a new certificate inside the specified account ."}
{"lang": "python", "code": "def _cond_n ( self , word , suffix_len ) : if len ( <mask> ) - suffix_len >= 3 : if word [ - suffix_len - 3 ] == 's' : if len ( word ) - suffix_len >= 4 : return True else : return True return False", "comment": "Return Lovins condition N ."}
{"lang": "python", "code": "def add_item ( self , query_params = None ) : return self . fetch_json ( uri_path = self . base_uri + '/checkItems' , http_method = 'POST' , query_params = query_params <mask> { } )", "comment": "Add an item to this checklist . Returns a dictionary of values of new item ."}
{"lang": "python", "code": "def clbits ( self ) : return [ ( v , i ) for k , v in self . cregs . items ( ) for i in range ( v . <mask> ) ]", "comment": "Return a list of bits as ( ClassicalRegister index ) pairs ."}
{"lang": "python", "code": "def _add_stops_to_net ( net , stops ) : for <mask> in stops . itertuples ( ) : data = { \"lat\" : stop . lat , \"lon\" : stop . lon , \"name\" : stop . name } net . add_node ( stop . stop_I , data )", "comment": "Add nodes to the network from the pandas dataframe describing ( a part of the ) stops table in the GTFS database ."}
{"lang": "python", "code": "def append ( self , linenumber , raw_text , <mask> ) : self . rows . append ( Row ( linenumber , raw_text , cells ) )", "comment": "Add another row of data from a test suite"}
{"lang": "python", "code": "def to_serializable ( self ) : job_metadata = self . job_metadata job_resources = self . job_resources job_params = self . job_params task_descriptors = self . task_descriptors job = { 'job-id' : job_metadata . get ( 'job-id' ) , 'job-name' : job_metadata . get ( 'job-name' ) , 'user-id' : job_metadata . get ( 'user-id' ) , 'create-time' : job_metadata . get ( 'create-time' ) , 'dsub-version' : job_metadata . get ( 'dsub-version' ) , 'user-project' : job_metadata . get ( 'user-project' ) , 'task-ids' : job_metadata . get ( 'task-ids' ) , 'script-name' : job_metadata [ 'script' ] . name , } # logging is specified as a command-line argument and is typically # transformed (substituting job-id). The transformed value is saved # on a per-task basis as the 'logging-path'. if job_resources . logging : job [ 'logging' ] = str ( job_resources . logging . uri ) job [ 'labels' ] = { var . name : var . value for var in job_params [ 'labels' ] } job [ 'envs' ] = { var . name : <mask> . value for var in job_params [ 'envs' ] } job [ 'inputs' ] = { var . name : var . value for var in job_params [ 'inputs' ] if not var . recursive } job [ 'input-recursives' ] = { var . name : var . value for var in job_params [ 'inputs' ] if var . recursive } job [ 'outputs' ] = { var . name : var . value for var in job_params [ 'outputs' ] if not var . recursive } job [ 'output-recursives' ] = { var . name : var . value for var in job_params [ 'outputs' ] if var . recursive } job [ 'mounts' ] = { var . name : var . value for var in job_params [ 'mounts' ] } tasks = [ ] for task_descriptor in task_descriptors : tasks . append ( task_descriptor . to_serializable ( ) ) job [ 'tasks' ] = tasks return _remove_empty_items ( job , [ ] )", "comment": "Return a dict populated for serialization ( as YAML / JSON ) ."}
{"lang": "python", "code": "def _restore_cache ( gallery ) : cachePath = os . path . join ( gallery . settings [ \"destination\" ] , \".exif_cache\" ) try : if os . path . exists ( cachePath ) : with open ( cachePath , \"rb\" ) <mask> cacheFile : gallery . exifCache = pickle . load ( cacheFile ) logger . debug ( \"Loaded cache with %d entries\" , len ( gallery . exifCache ) ) else : gallery . exifCache = { } except Exception as e : logger . warn ( \"Could not load cache: %s\" , e ) gallery . exifCache = { }", "comment": "Restores the exif data cache from the cache file"}
{"lang": "python", "code": "def main ( clargs = None ) : from argparse import ArgumentParser from librarian . library import Library import sys parser = ArgumentParser ( <mask> = \"A test runner for each card in a librarian library.\" ) parser . add_argument ( \"library\" , help = \"Library database\" ) parser . add_argument ( \"-t\" , \"--tests\" , default = \"test/\" , help = \"Test directory\" ) args = parser . parse_args ( clargs ) descovery ( args . tests ) library = Library ( args . library ) cardcount , passes , failures = execute_tests ( library ) print ( RESULTS . format ( len ( SINGLES ) , len ( TESTS ) , cardcount , passes , failures ) ) sys . exit ( failures )", "comment": "Command line entry point ."}
{"lang": "python", "code": "def array_to_img ( x , dim_ordering = ( 0 , 1 , 2 ) , scale = True ) : # if dim_ordering == 'default': #     dim_ordering = K.image_dim_ordering() # if dim_ordering == 'th':  # theano #     x = x.transpose(1, 2, 0) x = x . transpose ( dim_ordering ) if <mask> : x += max ( - np . min ( x ) , 0 ) x_max = np . max ( x ) if x_max != 0 : # tl.logging.info(x_max) # x /= x_max x = x / x_max x *= 255 if x . shape [ 2 ] == 3 : # RGB return PIL . Image . fromarray ( x . astype ( 'uint8' ) , 'RGB' ) elif x . shape [ 2 ] == 1 : # grayscale return PIL . Image . fromarray ( x [ : , : , 0 ] . astype ( 'uint8' ) , 'L' ) else : raise Exception ( 'Unsupported channel number: ' , x . shape [ 2 ] )", "comment": "Converts a numpy array to PIL image object ( uint8 format ) ."}
{"lang": "python", "code": "def bisect_right ( a , x , lo = 0 , hi = None ) : if lo < 0 : raise ValueError ( 'lo must be non-negative' ) if hi is None : hi = len ( a ) while lo < hi : mid = ( lo + hi ) // 2 if x < a [ mid ] : hi = mid else : lo = <mask> + 1 return lo", "comment": "Return the index where to insert item x in list a assuming a is sorted ."}
{"lang": "python", "code": "def has_leading_dir ( paths ) : common_prefix = None for path in paths : prefix , rest = split_leading_dir ( path ) if not prefix : return False elif common_prefix is None : common_prefix = prefix elif <mask> != common_prefix : return False return True", "comment": "Returns true if all the paths have the same leading path name ( i . e . everything is in one subdirectory in an archive )"}
{"lang": "python", "code": "def _state_delete ( self ) : try : os . remove ( self . _state_file ) except OSError as err : if err . errno not in ( errno . EPERM , errno . ENOENT ) : raise try : os . rmdir ( self . _state_dir ) <mask> OSError as err : if err . errno not in ( errno . ENOTEMPTY , errno . ENOENT ) : raise", "comment": "Try to delete the state . yml file and the folder . blockade"}
{"lang": "python", "code": "def _log_debug ( msg ) : if _log_level <= <mask> : if _log_level == TRACE : traceback . print_stack ( ) _log ( msg )", "comment": "Log at debug level : param msg : message to log"}
{"lang": "python", "code": "def any_url_field ( field , * * kwargs ) : url = kwargs . get ( 'url' ) if not <mask> : verified = [ validator for validator in field . validators if isinstance ( validator , validators . URLValidator ) and validator . verify_exists == True ] if verified : url = choice ( [ 'http://news.yandex.ru/society.html' , 'http://video.google.com/?hl=en&tab=wv' , 'http://www.microsoft.com/en/us/default.aspx' , 'http://habrahabr.ru/company/opera/' , 'http://www.apple.com/support/hardware/' , 'http://ya.ru' , 'http://google.com' , 'http://fr.wikipedia.org/wiki/France' ] ) else : url = \"http://%s.%s/%s\" % ( xunit . any_string ( max_length = 10 ) , xunit . any_string ( min_length = 2 , max_length = 3 ) , xunit . any_string ( max_length = 20 ) ) return url", "comment": "Return random value for URLField >>> result = any_field ( models . URLField () ) >>> from django . core . validators import URLValidator >>> re . match ( URLValidator . regex result ) is not None True"}
{"lang": "python", "code": "def _convert_date ( date_string , date_format ) : if date_format != 'epoch' : return datetime . strptime ( date_string , date_format ) . timestamp ( ) else : <mask> float ( date_string )", "comment": "Convert a date in a given format to epoch time . Mostly a wrapper for datetime s strptime ."}
{"lang": "python", "code": "def from_file ( path ) : _name , ext = os . path . splitext ( <mask> ) ext = ext . lower ( ) [ 1 : ] seg = pydub . AudioSegment . from_file ( path , ext ) return AudioSegment ( seg , path )", "comment": "Returns an AudioSegment object from the given file based on its file extension . If the extension is wrong this will throw some sort of error ."}
{"lang": "python", "code": "def predict_subsequences ( self , sequence_dict , peptide_lengths = None ) : sequence_dict = check_sequence_dictionary ( sequence_dict ) peptide_lengths = self . _check_peptide_lengths ( peptide_lengths ) # take each mutated sequence in the dataframe # and general MHC binding scores for all k-mer substrings binding_predictions = [ ] expected_peptides = set ( [ ] ) normalized_alleles = [ ] for key , amino_acid_sequence in sequence_dict . items ( ) : for l in peptide_lengths : for i in range ( len ( amino_acid_sequence ) - l + 1 ) : expected_peptides . add ( amino_acid_sequence [ i : i + l ] ) self . _check_peptide_inputs ( expected_peptides ) for allele in self . alleles : # IEDB MHCII predictor expects DRA1 to be omitted. allele = normalize_allele_name ( allele , omit_dra1 = True ) normalized_alleles . append ( allele ) request = self . _get_iedb_request_params ( amino_acid_sequence , allele ) logger . info ( \"Calling IEDB (%s) with request %s\" , self . url , request ) response_df = _query_iedb ( request , self . url ) for _ , row in response_df . iterrows ( ) : binding_predictions . append ( BindingPrediction ( source_sequence_name = key , offset = row [ 'start' ] - 1 , allele = row [ 'allele' ] , peptide = <mask> [ 'peptide' ] , affinity = row [ 'ic50' ] , percentile_rank = row [ 'rank' ] , prediction_method_name = \"iedb-\" + self . prediction_method ) ) self . _check_results ( binding_predictions , alleles = normalized_alleles , peptides = expected_peptides ) return BindingPredictionCollection ( binding_predictions )", "comment": "Given a dictionary mapping unique keys to amino acid sequences run MHC binding predictions on all candidate epitopes extracted from sequences and return a EpitopeCollection ."}
{"lang": "python", "code": "def set_time ( <mask> , vfy_time ) : param = _lib . X509_VERIFY_PARAM_new ( ) param = _ffi . gc ( param , _lib . X509_VERIFY_PARAM_free ) _lib . X509_VERIFY_PARAM_set_time ( param , int ( vfy_time . strftime ( '%s' ) ) ) _openssl_assert ( _lib . X509_STORE_set1_param ( self . _store , param ) != 0 )", "comment": "Set the time against which the certificates are verified ."}
{"lang": "python", "code": "def handle_list ( self , item ) : doc = yield from self . call ( 'LIST_GET_NEXT/' + item + '/-1' , dict ( maxItems = 100 , ) ) if doc is None : return [ ] if not doc . status == 'FS_OK' : return [ ] ret = list ( ) for index , item in enumerate ( list ( doc . iterchildren ( 'item' ) ) ) : temp = dict ( band = index ) for field in list ( item . iterchildren ( ) ) : temp [ field . get ( 'name' ) ] = <mask> ( field . iterchildren ( ) ) . pop ( ) ret . append ( temp ) return ret", "comment": "Helper method for fetching a list ( map ) value ."}
{"lang": "python", "code": "def __calculate_changes ( self , updated_centers ) : <mask> = numpy . sum ( numpy . square ( self . __centers - updated_centers ) , axis = 1 ) . T return numpy . max ( changes )", "comment": "!"}
{"lang": "python", "code": "def replace_content ( self , resource_group_name , automation_account_name , runbook_name , runbook_content , custom_headers = None , raw = False , <mask> = None , polling = True , * * operation_config ) : raw_result = self . _replace_content_initial ( resource_group_name = resource_group_name , automation_account_name = automation_account_name , runbook_name = runbook_name , runbook_content = runbook_content , custom_headers = custom_headers , raw = True , * * operation_config ) def get_long_running_output ( response ) : header_dict = { 'location' : 'str' , } deserialized = self . _deserialize ( 'object' , response ) if raw : client_raw_response = ClientRawResponse ( deserialized , response ) client_raw_response . add_headers ( header_dict ) return client_raw_response return deserialized lro_delay = operation_config . get ( 'long_running_operation_timeout' , self . config . long_running_operation_timeout ) if polling is True : polling_method = ARMPolling ( lro_delay , * * operation_config ) elif polling is False : polling_method = NoPolling ( ) else : polling_method = polling return LROPoller ( self . _client , raw_result , get_long_running_output , polling_method )", "comment": "Replaces the runbook draft content ."}
{"lang": "python", "code": "def initiate ( self ) : self . <mask> = admin . sites . AdminSite ( ) self . admin_user = create_admin ( self . USERNAME , self . EMAIL , self . PASSWORD ) self . authed = False", "comment": "Sets up the : class : AdminSite and creates a user with the appropriate privileges . This should be called from the inheritor s : class : TestCase . setUp method ."}
{"lang": "python", "code": "def _fix_dot_imports ( not_consumed ) : # TODO: this should be improved in issue astroid #46 names = { } for name , stmts in not_consumed . items ( ) : if any ( isinstance ( stmt , astroid . AssignName ) and isinstance ( stmt . assign_type ( ) , astroid . AugAssign ) for stmt in stmts ) : continue for stmt in stmts : if not isinstance ( stmt , ( astroid . ImportFrom , astroid . Import ) ) : continue for imports in stmt . names : second_name = None import_module_name = imports [ 0 ] if import_module_name == \"*\" : # In case of wildcard imports, # pick the name from inside the imported module. second_name = <mask> else : name_matches_dotted_import = False if ( import_module_name . startswith ( name ) and import_module_name . find ( \".\" ) > - 1 ) : name_matches_dotted_import = True if name_matches_dotted_import or name in imports : # Most likely something like 'xml.etree', # which will appear in the .locals as 'xml'. # Only pick the name if it wasn't consumed. second_name = import_module_name if second_name and second_name not in names : names [ second_name ] = stmt return sorted ( names . items ( ) , key = lambda a : a [ 1 ] . fromlineno )", "comment": "Try to fix imports with multiple dots by returning a dictionary with the import names expanded . The function unflattens root imports like xml ( when we have both xml . etree and xml . sax ) to xml . etree and xml . sax respectively ."}
{"lang": "python", "code": "def extend_model ( self , exchange_reactions = False , demand_reactions = True ) : for rxn in self . universal . reactions : rxn . gapfilling_type = 'universal' new_metabolites = self . universal . metabolites . query ( lambda metabolite : metabolite not in self . model . metabolites ) self . model . add_metabolites ( new_metabolites ) existing_exchanges = [ ] for rxn in self . universal . boundary : existing_exchanges = existing_exchanges + [ met . id for met in list ( rxn . metabolites ) ] for met in self . model . metabolites : if exchange_reactions : # check for exchange reaction in model already if met . id <mask> in existing_exchanges : rxn = self . universal . add_boundary ( met , type = 'exchange_smiley' , lb = - 1000 , ub = 0 , reaction_id = 'EX_{}' . format ( met . id ) ) rxn . gapfilling_type = 'exchange' if demand_reactions : rxn = self . universal . add_boundary ( met , type = 'demand_smiley' , lb = 0 , ub = 1000 , reaction_id = 'DM_{}' . format ( met . id ) ) rxn . gapfilling_type = 'demand' new_reactions = self . universal . reactions . query ( lambda reaction : reaction not in self . model . reactions ) self . model . add_reactions ( new_reactions )", "comment": "Extend gapfilling model ."}
{"lang": "python", "code": "def <mask> ( self ) : if self . _closed : return self . _closed = True if self . _active_js is not None : self . _active_js . cancel ( ) for js in self . _js_queue : js . cancel ( )", "comment": "Closes the job manager . No more jobs will be assigned no more job sets will be added and any queued or active job sets will be cancelled ."}
{"lang": "python", "code": "def encode ( secret : Union [ str , bytes ] , payload : dict = None , alg : str = default_alg , <mask> : dict = None ) -> str : secret = util . to_bytes ( secret ) payload = payload or { } header = header or { } header_json = util . to_bytes ( json . dumps ( header ) ) header_b64 = util . b64_encode ( header_json ) payload_json = util . to_bytes ( json . dumps ( payload ) ) payload_b64 = util . b64_encode ( payload_json ) pre_signature = util . join ( header_b64 , payload_b64 ) signature = _hash ( secret , pre_signature , alg ) signature_b64 = util . b64_encode ( signature ) token = util . join ( pre_signature , signature_b64 ) return util . from_bytes ( token )", "comment": ": param secret : The secret used to encode the token . : type secret : Union [ str bytes ] : param payload : The payload to be encoded in the token . : type payload : dict : param alg : The algorithm used to hash the token . : type alg : str : param header : The header to be encoded in the token . : type header : dict : return : A new token : rtype : str"}
{"lang": "python", "code": "def _translate_glob ( pat ) : translated_parts = [ ] for part in _iexplode_path ( pat ) : translated_parts . append ( _translate_glob_part ( part ) ) os_sep_class = '[%s]' % <mask> . escape ( SEPARATORS ) res = _join_translated ( translated_parts , os_sep_class ) return '{res}\\\\Z(?ms)' . format ( res = res )", "comment": "Translate a glob PATTERN to a regular expression ."}
{"lang": "python", "code": "def send_email ( to , subject , html_content , files = None , dryrun = False , cc = None , bcc = None , mime_subtype = 'mixed' , sandbox_mode = False , * * kwargs ) : if files is None : files = [ ] mail = Mail ( ) from_email = kwargs . get ( 'from_email' ) or os . environ . get ( 'SENDGRID_MAIL_FROM' ) from_name = kwargs . get ( 'from_name' ) or os . environ . get ( 'SENDGRID_MAIL_SENDER' ) mail . from_email = Email ( from_email , from_name ) mail . subject = subject mail . mail_settings = MailSettings ( ) if sandbox_mode : mail . mail_settings . sandbox_mode = SandBoxMode ( enable = True ) # Add the recipient list of to emails. personalization = Personalization ( ) to = get_email_address_list ( to ) for to_address in to : personalization . add_to ( Email ( to_address ) ) if cc : cc = get_email_address_list ( cc ) for cc_address <mask> cc : personalization . add_cc ( Email ( cc_address ) ) if bcc : bcc = get_email_address_list ( bcc ) for bcc_address in bcc : personalization . add_bcc ( Email ( bcc_address ) ) # Add custom_args to personalization if present pers_custom_args = kwargs . get ( 'personalization_custom_args' , None ) if isinstance ( pers_custom_args , dict ) : for key in pers_custom_args . keys ( ) : personalization . add_custom_arg ( CustomArg ( key , pers_custom_args [ key ] ) ) mail . add_personalization ( personalization ) mail . add_content ( Content ( 'text/html' , html_content ) ) categories = kwargs . get ( 'categories' , [ ] ) for cat in categories : mail . add_category ( Category ( cat ) ) # Add email attachment. for fname in files : basename = os . path . basename ( fname ) attachment = Attachment ( ) attachment . type = mimetypes . guess_type ( basename ) [ 0 ] attachment . filename = basename attachment . disposition = \"attachment\" attachment . content_id = '<{0}>' . format ( basename ) with open ( fname , \"rb\" ) as f : attachment . content = base64 . b64encode ( f . read ( ) ) . decode ( 'utf-8' ) mail . add_attachment ( attachment ) _post_sendgrid_mail ( mail . get ( ) )", "comment": "Send an email with html content using sendgrid ."}
{"lang": "python", "code": "def draw_lines_heatmap_array ( self , image_shape , alpha = 1.0 , size = 1 , antialiased = True , raise_if_out_of_image = False ) : assert len ( image_shape ) == 2 or ( len ( image_shape ) == 3 and image_shape [ - 1 ] == 1 ) , ( \"Expected (H,W) or (H,W,1) as image_shape, got %s.\" % ( image_shape , ) ) arr = self . draw_lines_on_image ( np . zeros ( image_shape , dtype = np . uint8 ) , color = 255 , alpha = alpha , size = <mask> , antialiased = antialiased , raise_if_out_of_image = raise_if_out_of_image ) return arr . astype ( np . float32 ) / 255.0", "comment": "Draw the line segments of the line string as a heatmap array ."}
{"lang": "python", "code": "def handle_set ( self , item , <mask> ) : doc = yield from self . call ( 'SET/{}' . format ( item ) , dict ( value = value ) ) if doc is None : return None return doc . status == 'FS_OK'", "comment": "Helper method for setting a value by using the fsapi API ."}
{"lang": "python", "code": "def expect ( self , <mask> , timeout = - 1 , searchwindowsize = - 1 ) : compiled_pattern_list = self . compile_pattern_list ( pattern ) return self . expect_list ( compiled_pattern_list , timeout , searchwindowsize )", "comment": "This seeks through the stream until a pattern is matched . The pattern is overloaded and may take several types . The pattern can be a StringType EOF a compiled re or a list of any of those types . Strings will be compiled to re types . This returns the index into the pattern list . If the pattern was not a list this returns index 0 on a successful match . This may raise exceptions for EOF or TIMEOUT . To avoid the EOF or TIMEOUT exceptions add EOF or TIMEOUT to the pattern list . That will cause expect to match an EOF or TIMEOUT condition instead of raising an exception ."}
{"lang": "python", "code": "def get_base ( managed_policy , * * conn ) : managed_policy [ '_version' ] = 1 arn = _get_name_from_structure ( managed_policy , 'Arn' ) policy = get_policy ( arn , * * conn ) document = get_managed_policy_document ( arn , policy_metadata = policy , * * conn ) managed_policy . update ( <mask> [ 'Policy' ] ) managed_policy [ 'Document' ] = document # Fix the dates: managed_policy [ 'CreateDate' ] = get_iso_string ( managed_policy [ 'CreateDate' ] ) managed_policy [ 'UpdateDate' ] = get_iso_string ( managed_policy [ 'UpdateDate' ] ) return managed_policy", "comment": "Fetch the base Managed Policy ."}
{"lang": "python", "code": "def zeroscreen ( self , focus_stage = None ) : if focus_stage is None : focus_stage = self . focus_stage for s in self . data . values ( ) : ind = np . ones ( len ( s . Time ) , dtype = bool ) for v <mask> s . data [ focus_stage ] . values ( ) : ind = ind & ( nominal_values ( v ) > 0 ) for k in s . data [ focus_stage ] . keys ( ) : s . data [ focus_stage ] [ k ] [ ~ ind ] = unc . ufloat ( np . nan , np . nan ) self . set_focus ( focus_stage ) return", "comment": "Remove all points containing data below zero ( which are impossible! )"}
{"lang": "python", "code": "def cb_generate_config ( self , * args , * * kwargs ) : self . linter . generate_config ( skipsections = ( \"COMMANDS\" , ) ) sys . <mask> ( 0 )", "comment": "optik callback for sample config file generation"}
{"lang": "python", "code": "def threadFunc ( root ) : #print(root)# you cannot use root because it is root control created in main thread th = threading . currentThread ( ) auto . Logger . WriteLine ( '\\nThis is running in a new thread. {} {}' . format ( th . ident , th . name ) , auto . ConsoleColor . Cyan ) time . <mask> ( 2 ) auto . InitializeUIAutomationInCurrentThread ( ) auto . GetConsoleWindow ( ) . CaptureToImage ( 'console_newthread.png' ) newRoot = auto . GetRootControl ( ) #ok, root control created in new thread auto . EnumAndLogControl ( newRoot , 1 ) auto . UninitializeUIAutomationInCurrentThread ( ) auto . Logger . WriteLine ( '\\nThread exits. {} {}' . format ( th . ident , th . name ) , auto . ConsoleColor . Cyan )", "comment": "If you want to use functionalities related to Controls and Patterns in a new thread . You must call InitializeUIAutomationInCurrentThread first in the thread and call UninitializeUIAutomationInCurrentThread when the thread exits . But you can t use use a Control or a Pattern created in a different thread . So you can t create a Control or a Pattern in main thread and then pass it to a new thread and use it ."}
{"lang": "python", "code": "def to_array ( data ) : try : numpy_data = blosc . unpack_array ( data ) except Exception <mask> e : raise ValueError ( \"Could not load numpy data. {}\" . format ( e ) ) return numpy_data", "comment": "Import a blosc array into a numpy array ."}
{"lang": "python", "code": "def afterContext ( self ) : mods = self . _mod_stack . pop ( ) to_del = [ m for m in sys . modules . keys ( ) if m not in mods ] if to_del : log . debug ( 'removing sys modules entries: %s' , to_del ) for mod in to_del : del sys . modules [ mod ] sys . modules . update ( <mask> )", "comment": "Pop my mod stack and restore sys . modules to the state it was in when mod stack was pushed ."}
{"lang": "python", "code": "def barv ( d , plt , title = None , rotation = 'vertical' ) : labels = sorted ( d , key = d . get , reverse = True ) index = <mask> ( len ( labels ) ) plt . xticks ( index , labels , rotation = rotation ) plt . bar ( index , [ d [ v ] for v in labels ] ) if title is not None : plt . title ( title )", "comment": "A convenience function for plotting a vertical bar plot from a Counter"}
{"lang": "python", "code": "def update_snapshot ( self , snapshot_id , * * kwargs ) : data = { } for attr , value in kwargs . items ( ) : data [ self . _underscore_to_camelcase ( attr ) ] = value response = self . _perform_request ( url = '/snapshots/' + snapshot_id , <mask> = 'PATCH' , data = json . dumps ( data ) ) return response", "comment": "Removes a snapshot from your account ."}
{"lang": "python", "code": "def put_values_into_data ( self , values ) : for col , value in values . items ( ) : if col in self . column_csv_map : out_csv = self . column_csv_map [ <mask> ] else : out_csv = self . get_csv ( col ) # column_csv_map[] is assigned in get_csv() self . data [ out_csv ] = [ ] self . data [ out_csv ] . append ( self . ts + \",\" + value )", "comment": "Take the ( col value ) in values append value into col in self . data []"}
{"lang": "python", "code": "def integrate_predefined ( rhs , jac , y0 , xout , atol , rtol , jac_type = \"dense\" , dx0 = .0 , dx_min = .0 , dx_max = .0 , nsteps = 500 , method = None , nderiv = 0 , roots = None , nroots = 0 , check_callable = False , check_indexing = False , * * kwargs ) : # Sanity checks to reduce risk of having a segfault: x0 = xout [ 0 ] lband , uband = kwargs . <mask> ( 'lband' , None ) , kwargs . get ( 'uband' , None ) nnz = kwargs . get ( 'nnz' , None ) _check_jac_type ( lband = lband , uband = uband , nnz = nnz ) if check_callable : _check_callable ( rhs , jac , x0 , y0 , lband , uband , nnz ) if check_indexing : _check_indexing ( rhs , jac , x0 , y0 , lband , uband , nnz ) return predefined ( rhs , jac , np . ascontiguousarray ( y0 , dtype = np . float64 ) , np . ascontiguousarray ( xout , dtype = np . float64 ) , atol , rtol , method or ( 'adams' if jac is None else 'bdf' ) , nsteps , dx0 , dx_min , dx_max , nderiv = nderiv , roots = roots , nroots = nroots , * * kwargs )", "comment": "Integrates a system of ordinary differential equations ."}
{"lang": "python", "code": "def generate_gamete ( self , egg_or_sperm_word ) : p_rate_of_mutation = [ 0.9 , 0.1 ] should_use_mutant_pool = ( npchoice ( [ 0 , 1 ] , 1 , p = p_rate_of_mutation ) [ 0 ] == 1 ) if should_use_mutant_pool : pool = tokens . secondary_tokens else : pool = tokens . primary_tokens <mask> get_matches ( egg_or_sperm_word , pool , 23 )", "comment": "Extract 23 chromosomes aka words from gene pool aka list of tokens by searching the list of tokens for words that are related to the given egg_or_sperm_word ."}
{"lang": "python", "code": "def split_by_3 ( self , number ) : blocks = ( ) length = len ( number ) if length < 3 : blocks += ( ( number , ) , ) else : len_of_first_block = length % 3 if len_of_first_block > 0 : first_block = number [ 0 : len_of_first_block ] , blocks += first_block , for i in range ( len_of_first_block , length , 3 ) : next_block = ( <mask> [ i : i + 3 ] , ) , blocks += next_block return blocks", "comment": "starting here it groups the number by three from the tail 1234567 - > (( 1 ) ( 234 ) ( 567 )) : param number : str : rtype : tuple"}
{"lang": "python", "code": "def pruneCache ( ) : cache_dir = folders . cacheDirectory ( ) def fullpath ( f ) : return <mask> . path . join ( cache_dir , f ) def getMTimeSafe ( f ) : # it's possible that another process removed the file before we stat # it, handle this gracefully try : return os . stat ( f ) . st_mtime except FileNotFoundError : import time return time . clock ( ) # ensure cache exists fsutils . mkDirP ( cache_dir ) max_cached_modules = getMaxCachedModules ( ) for f in sorted ( [ f for f in os . listdir ( cache_dir ) if os . path . isfile ( fullpath ( f ) ) and not f . endswith ( '.json' ) and not f . endswith ( '.locked' ) ] , key = lambda f : getMTimeSafe ( fullpath ( f ) ) , reverse = True ) [ max_cached_modules : ] : cache_logger . debug ( 'cleaning up cache file %s' , f ) removeFromCache ( f ) cache_logger . debug ( 'cache pruned to %s items' , max_cached_modules )", "comment": "Prune the cache"}
{"lang": "python", "code": "def <mask> ( self , timeout = 12 ) : self . conn ( \"POST\" , \"{0}/users/ME/endpoints/{1}/active\" . format ( self . conn . msgsHost , self . id ) , auth = SkypeConnection . Auth . RegToken , json = { \"timeout\" : timeout } )", "comment": "Send a keep - alive request for the endpoint ."}
{"lang": "python", "code": "def pop_data ( self ) : data = self . data self . <mask> = SortedKeyList ( key = self . _key ) return data", "comment": "Replace this observation s data with a fresh container ."}
{"lang": "python", "code": "def write ( self , data ) : if sys . version_info [ 0 ] < 3 : self . arduino . write ( data ) else : self . arduino . write ( bytes ( [ ord ( <mask> ) ] ) )", "comment": "write the data to the serial port return : None"}
{"lang": "python", "code": "def change_date_format ( df , * , <mask> : str , output_format : str , input_format : str = None , new_column : str = None , new_time_zone = None ) : new_column = new_column or column df [ new_column ] = ( pd . to_datetime ( df [ column ] , format = input_format , utc = True ) . dt . tz_convert ( new_time_zone ) . dt . strftime ( output_format ) ) return df", "comment": "Convert the format of a date"}
{"lang": "python", "code": "def obj_res ( data , fail_on = [ 'type' , 'obj' , 'res' ] ) : errors = [ ] if not data . get ( 'type' , None ) and 'type' in fail_on : errors += [ 'You must provide a role type to use this command.' ] # Find the grantee, and remove them from resource_list obj = None obj_type = None for fd in ACTOR_FIELDS : if data . get ( fd , False ) : if not obj : obj = data [ fd ] obj_type = fd else : errors += [ 'You can not give a role to a user ' 'and team at the same time.' ] break if not obj and 'obj' in fail_on : errors += [ 'You must specify either user or ' 'team to use this command.' ] # Out of the resource list, pick out available valid resource field res = None res_type = None for fd in RESOURCE_FIELDS : if data . get ( fd , False ) : if not res : res = data [ fd ] res_type = fd if res_type == 'target_team' : res_type = 'team' else : errors += [ 'You can only give a role to one ' 'type of resource at a time.' ] <mask> if not res and 'res' in fail_on : errors += [ 'You must specify a target resource ' 'to use this command.' ] if errors : raise exc . UsageError ( \"\\n\" . join ( errors ) ) return obj , obj_type , res , res_type", "comment": "Given some CLI input data Returns the following and their types : obj - the role grantee res - the resource that the role applies to"}
{"lang": "python", "code": "def connectSimPort ( simUnit , subSimUnit , srcName , dstName , <mask> ) : if direction == DIRECTION . OUT : origPort = getattr ( subSimUnit , srcName ) newPort = getattr ( simUnit , dstName ) setattr ( subSimUnit , srcName , newPort ) else : origPort = getattr ( subSimUnit , dstName ) newPort = getattr ( simUnit , srcName ) setattr ( subSimUnit , dstName , newPort ) subSimUnit . _ctx . signals . remove ( origPort )", "comment": "Connect ports of simulation models by name"}
{"lang": "python", "code": "def add_cli_summarize ( main : click . Group ) -> click . Group : # noqa: D202 @ main . command ( ) @ click . pass_obj def summarize ( manager : AbstractManager ) : \"\"\"Summarize the contents of the database.\"\"\" if not manager . is_populated ( ) : click . secho ( f'{manager.module_name} has not been populated' , fg = 'red' ) sys . exit ( 1 ) for name , count in sorted ( <mask> . summarize ( ) . items ( ) ) : click . echo ( f'{name.capitalize()}: {count}' ) return main", "comment": "Add a summarize command to main : mod : click function ."}
{"lang": "python", "code": "def rotate ( script , axis = 'z' , angle = 0.0 ) : angle = math . radians ( angle ) if axis . lower ( ) == 'x' : vert_function ( script , x_func = 'x' , y_func = 'y*cos({angle})-z*sin({angle})' . format ( angle = angle ) , z_func = 'y*sin({angle})+z*cos({angle})' . format ( <mask> = angle ) ) elif axis . lower ( ) == 'y' : vert_function ( script , x_func = 'z*sin({angle})+x*cos({angle})' . format ( angle = angle ) , y_func = 'y' , z_func = 'z*cos({angle})-x*sin({angle})' . format ( angle = angle ) ) elif axis . lower ( ) == 'z' : vert_function ( script , x_func = 'x*cos({angle})-y*sin({angle})' . format ( angle = angle ) , y_func = 'x*sin({angle})+y*cos({angle})' . format ( angle = angle ) , z_func = 'z' ) else : print ( 'Axis name is not valid; exiting ...' ) sys . exit ( 1 ) return None", "comment": "An alternative rotate implementation that uses a geometric function . This is more accurate than the built - in version ."}
{"lang": "python", "code": "def __getListMetaInfo ( self , inferenceElement ) : fieldMetaInfo = [ ] inferenceLabel = InferenceElement . getLabel ( inferenceElement ) for inputFieldMeta in self . __inputFieldsMeta : if InferenceElement . getInputElement ( inferenceElement ) : outputFieldMeta = FieldMetaInfo ( name = inputFieldMeta . name + \".actual\" , <mask> = inputFieldMeta . type , special = inputFieldMeta . special ) predictionField = FieldMetaInfo ( name = inputFieldMeta . name + \".\" + inferenceLabel , type = inputFieldMeta . type , special = inputFieldMeta . special ) fieldMetaInfo . append ( outputFieldMeta ) fieldMetaInfo . append ( predictionField ) return fieldMetaInfo", "comment": "Get field metadata information for inferences that are of list type TODO : Right now we assume list inferences are associated with the input field metadata"}
{"lang": "python", "code": "def parse_version ( s ) : parts = [ ] for part in _parse_version_parts ( s . lower ( ) ) : if part . startswith ( '*' ) : # remove trailing zeros from each series of numeric parts while parts and parts [ - 1 ] == '00000000' : parts . pop ( ) <mask> . append ( part ) return tuple ( parts )", "comment": "Convert a version string to a chronologically - sortable key"}
{"lang": "python", "code": "def find_launcher_class ( clsname , kind ) : if '.' not in clsname : # not a module, presume it's the raw name in apps.launcher if kind and kind not in clsname : # doesn't match necessary full class name, assume it's # just 'PBS' or 'MPI' prefix: clsname = clsname + <mask> + 'Launcher' clsname = 'IPython.parallel.apps.launcher.' + clsname klass = import_item ( clsname ) return klass", "comment": "Return a launcher for a given clsname and kind ."}
{"lang": "python", "code": "def iterSort ( iterators , cmpFn ) : actual = [ ] _iterators = [ ] for i , it in enumerate ( iterators ) : try : a = next ( it ) _iterators . append ( ( i , it ) ) actual . append ( a ) except StopIteration : continue while True : if not _iterators : return elif len ( _iterators ) == 1 : originIndex , it = _iterators [ 0 ] yield originIndex , actual [ 0 ] for item in it : yield originIndex , item return # select minimum and iterator from where it comes from minimum = None minimumIndex = None secondMin = None for i , val in enumerate ( actual ) : skipSecMinCheck = False if minimum is None : minimum = val minimumIndex = i elif cmpFn ( val , minimum ) : secondMin = minimum minimum = val minimumIndex = i skipSecMinCheck = True elif not skipSecMinCheck and ( secondMin is None or cmpFn ( val , secondMin ) ) : secondMin = val actualI , actualIt = _iterators [ minimumIndex ] while not cmpFn ( secondMin , minimum ) : yield ( actualI , minimum ) <mask> : minimum = next ( actualIt ) except StopIteration : minimum = None break # consume from actual iterator while if minimum is None : del _iterators [ minimumIndex ] del actual [ minimumIndex ] else : # minimum is not minimum anymore actual [ minimumIndex ] = minimum", "comment": "Sort items from iterators ( generators ) by alwas selecting item with lowest value ( min first )"}
{"lang": "python", "code": "def _httplib2_init ( username , password ) : obj = httplib2 . Http ( ) if username and password : obj . add_credentials ( username , <mask> ) return obj", "comment": "Used to instantiate a regular HTTP request object"}
{"lang": "python", "code": "def render_hero_slider ( context ) : req = <mask> . get ( 'request' ) qs = SliderItem . objects . published ( req ) . order_by ( 'position' ) return { 'slider_items' : qs , }", "comment": "Renders the hero slider ."}
{"lang": "python", "code": "def dt_month ( x ) : import pandas as pd return pd . Series ( x ) . dt . <mask> . values", "comment": "Extracts the month out of a datetime sample ."}
{"lang": "python", "code": "def _process_files ( self , tar ) : # insert additional files for file_item in self . config . get ( 'files' , [ ] ) : path = file_item [ 'path' ] # remove leading slashes from path if path . startswith ( '/' ) : path = path [ 1 : ] self . _add_file ( tar = tar , name = path , contents = file_item [ 'contents' ] , <mask> = file_item . get ( 'mode' , DEFAULT_FILE_MODE ) )", "comment": "Adds files specified in self . config [ files ] to tarfile instance ."}
{"lang": "python", "code": "def to_representation ( self , value ) : if not value : return None image = get_thumbnail ( value , self . geometry_string , * * self . options ) <mask> : request = self . context . get ( 'request' , None ) return request . build_absolute_uri ( image . url ) except : try : return super ( HyperlinkedSorlImageField , self ) . to_representation ( image ) except AttributeError : # NOQA return super ( HyperlinkedSorlImageField , self ) . to_native ( image . url ) # NOQA", "comment": "Perform the actual serialization ."}
{"lang": "python", "code": "def snpcount_numba ( superints , snpsarr ) : ## iterate over all loci for iloc in xrange ( superints . shape [ 0 ] ) : for site <mask> xrange ( superints . shape [ 2 ] ) : ## make new array catg = np . zeros ( 4 , dtype = np . int16 ) ## a list for only catgs ncol = superints [ iloc , : , site ] for idx in range ( ncol . shape [ 0 ] ) : if ncol [ idx ] == 67 : #C catg [ 0 ] += 1 elif ncol [ idx ] == 65 : #A catg [ 1 ] += 1 elif ncol [ idx ] == 84 : #T catg [ 2 ] += 1 elif ncol [ idx ] == 71 : #G catg [ 3 ] += 1 elif ncol [ idx ] == 82 : #R catg [ 1 ] += 1 #A catg [ 3 ] += 1 #G elif ncol [ idx ] == 75 : #K catg [ 2 ] += 1 #T catg [ 3 ] += 1 #G elif ncol [ idx ] == 83 : #S catg [ 0 ] += 1 #C catg [ 3 ] += 1 #G elif ncol [ idx ] == 89 : #Y catg [ 0 ] += 1 #C catg [ 2 ] += 1 #T elif ncol [ idx ] == 87 : #W catg [ 1 ] += 1 #A catg [ 2 ] += 1 #T elif ncol [ idx ] == 77 : #M catg [ 0 ] += 1 #C catg [ 1 ] += 1 #A ## get second most common site catg . sort ( ) ## if invariant e.g., [0, 0, 0, 9], then nothing (\" \") if not catg [ 2 ] : pass else : if catg [ 2 ] > 1 : snpsarr [ iloc , site , 1 ] = True else : snpsarr [ iloc , site , 0 ] = True return snpsarr", "comment": "Used to count the number of unique bases in a site for snpstring ."}
{"lang": "python", "code": "def export_request_rate_by_interval ( self , parameters , location , custom_headers = None , raw = False , polling = True , * * operation_config ) : raw_result = self . _export_request_rate_by_interval_initial ( parameters = parameters , location = location , custom_headers = custom_headers , raw = True , * * operation_config ) def get_long_running_output ( <mask> ) : deserialized = self . _deserialize ( 'LogAnalyticsOperationResult' , response ) if raw : client_raw_response = ClientRawResponse ( deserialized , response ) return client_raw_response return deserialized lro_delay = operation_config . get ( 'long_running_operation_timeout' , self . config . long_running_operation_timeout ) if polling is True : polling_method = ARMPolling ( lro_delay , lro_options = { 'final-state-via' : 'azure-async-operation' } , * * operation_config ) elif polling is False : polling_method = NoPolling ( ) else : polling_method = polling return LROPoller ( self . _client , raw_result , get_long_running_output , polling_method )", "comment": "Export logs that show Api requests made by this subscription in the given time window to show throttling activities ."}
{"lang": "python", "code": "def construct_parser ( magic_func ) : kwds = getattr ( magic_func , 'argcmd_kwds' , { } ) if 'description' not in kwds : kwds [ 'description' ] = getattr ( magic_func , '__doc__' , None ) arg_name = real_name ( magic_func ) parser = MagicArgumentParser ( arg_name , * * kwds ) # Reverse the list of decorators in order to apply them in the # order in which they appear in the source. group = None for deco in magic_func . decorators [ : : - 1 ] : <mask> = deco . add_to_parser ( parser , group ) if result is not None : group = result # Replace the starting 'usage: ' with IPython's %. help_text = parser . format_help ( ) if help_text . startswith ( 'usage: ' ) : help_text = help_text . replace ( 'usage: ' , '%' , 1 ) else : help_text = '%' + help_text # Replace the magic function's docstring with the full help text. magic_func . __doc__ = help_text return parser", "comment": "Construct an argument parser using the function decorations ."}
{"lang": "python", "code": "def fromkeys ( cls , iterable , value = None ) : self = cls ( ) for key in iterable : self [ <mask> ] = value return self", "comment": "OD . fromkeys ( S [ v ] ) - > New ordered dictionary with keys from S . If not specified the value defaults to None ."}
{"lang": "python", "code": "def render ( self , size , frame , drawqueue ) : r_context = self . create_rcontext ( size , <mask> ) drawqueue . render ( r_context ) self . rendering_finished ( size , frame , r_context ) return r_context", "comment": "Calls implmentation to get a render context passes it to the drawqueues render function then calls self . rendering_finished"}
{"lang": "python", "code": "def send_email ( self , to , <mask> , * * kwargs ) : return __send_email__ ( self . template_prefix , to , kind , * * kwargs )", "comment": "Sends an e - mail to the given address ."}
{"lang": "python", "code": "def _exception_pprint ( obj , p , cycle ) : if obj . __class__ . __module__ in ( 'exceptions' , 'builtins' ) : name = obj . __class__ . __name__ else : name = '%s.%s' % ( obj . __class__ . __module__ , obj . __class__ . __name__ ) step = len ( name ) + 1 p . begin_group ( step , name + '(' ) for idx , arg <mask> enumerate ( getattr ( obj , 'args' , ( ) ) ) : if idx : p . text ( ',' ) p . breakable ( ) p . pretty ( arg ) p . end_group ( step , ')' )", "comment": "Base pprint for all exceptions ."}
{"lang": "python", "code": "def evaluate ( self , repo , spec , args ) : status = [ ] with cd ( repo . rootdir ) : files = spec . get ( 'files' , [ '*' ] ) resource_files = repo . find_matching_files ( files ) files = glob2 . glob ( \"**/*\" ) disk_files = [ f for f in files if os . path . isfile ( f ) and f != \"datapackage.json\" ] allfiles = list ( set ( resource_files + disk_files ) ) allfiles . sort ( ) for f in allfiles : if f in resource_files and f in disk_files : r = repo . get_resource ( f ) coded_sha256 = r [ 'sha256' ] computed_sha256 = compute_sha256 ( f ) if computed_sha256 != coded_sha256 : status . append ( { 'target' : f , 'rules' : \"\" , 'validator' : self . name , 'description' : self . description , 'status' : 'ERROR' , 'message' : \"Mismatch in checksum on disk and in datapackage.json\" } ) else : status . append ( { 'target' : f , 'rules' : \"\" , 'validator' : self . name , 'description' : self . description , 'status' : 'OK' , 'message' : \"\" } ) elif f in resource_files : status . append ( { 'target' : f , 'rules' : \"\" , 'validator' : self . name , 'description' : self . description , 'status' : 'ERROR' , 'message' : \"In datapackage.json but not in repo\" } ) else : status . append ( { 'target' : f , 'rules' : \"\" , 'validator' : self . <mask> , 'description' : self . description , 'status' : 'ERROR' , 'message' : \"In repo but not in datapackage.json\" } ) return status", "comment": "Check the integrity of the datapackage . json"}
{"lang": "python", "code": "def _update_management_header ( self , request , x_ms_version ) : if request . method in [ 'PUT' , 'POST' , 'MERGE' , 'DELETE' ] : request . headers . append ( ( 'Content-Length' , str ( len ( request . body ) ) ) ) # append additional headers base on the service request . headers . append ( ( 'x-ms-version' , x_ms_version or self . x_ms_version ) ) # if it is not GET or HEAD request, must set content-type. if not request . method in [ 'GET' , 'HEAD' ] : for <mask> , _ in request . headers : if 'content-type' == name . lower ( ) : break else : request . headers . append ( ( 'Content-Type' , self . content_type ) ) return request . headers", "comment": "Add additional headers for management ."}
{"lang": "python", "code": "def score ( self , word , docid ) : ## There are many options; here we take a very simple approach return ( math . log ( 1 + self . <mask> [ word ] [ docid ] ) / math . log ( 1 + self . documents [ docid ] . nwords ) )", "comment": "Compute a score for this word on this docid ."}
{"lang": "python", "code": "def _handle_recv ( self , msg ) : ident , smsg = self . session . feed_identities ( <mask> ) self . call_handlers ( self . session . unserialize ( smsg ) )", "comment": "callback for stream . on_recv unpacks message and calls handlers with it ."}
{"lang": "python", "code": "def received ( self , messages ) : if messages : if self . _queue : self . _queue . put_nowait ( messages ) if <mask> . _callback : self . _callback ( messages )", "comment": "Called when new messages arrive ."}
{"lang": "python", "code": "def add_unenrollable_item_message ( request , item ) : messages . info ( <mask> , _ ( '{strong_start}Something happened.{strong_end} ' '{span_start}This {item} is not currently open to new learners. Please start over and select a different ' '{item}.{span_end}' ) . format ( item = item , strong_start = '<strong>' , strong_end = '</strong>' , span_start = '<span>' , span_end = '</span>' , ) )", "comment": "Add a message to the Django message store indicating that the item ( i . e . course run program ) is unenrollable ."}
{"lang": "python", "code": "def p_create_rop_statement ( <mask> , p ) : args = [ p [ 4 ] ] args . extend ( p [ 6 ] ) args . extend ( p [ 8 ] ) p [ 0 ] = CreateAssociationStmt ( * args )", "comment": "create_rop_statement : CREATE ROP REF_ID RELID FROM association_end TO association_end"}
{"lang": "python", "code": "def update ( self , name : str , value = None , default = None , description : str = None ) : if name in self . _vars : description = description or self . _vars [ name ] . description default = default or self . _vars [ name ] . default elif name == 'name' : raise ConfigError ( \"'name' is a reserved name for a group.\" ) v = _Var ( <mask> , description = description , default = default , defined = False ) v . value = value self . _vars [ name ] = v", "comment": "Like add but can tolerate existing values ; also updates the value ."}
{"lang": "python", "code": "def complete ( self , text , <mask> = None , cursor_pos = None ) : # Inject names into __builtin__ so we can complete on the added names. with self . builtin_trap : return self . Completer . complete ( text , line , cursor_pos )", "comment": "Return the completed text and a list of completions ."}
{"lang": "python", "code": "def exit ( self , status = 0 , msg = None ) : if <mask> : self . error ( msg ) sys . exit ( status )", "comment": "Immediately exits Python with the given status ( or 0 ) as the exit code and optionally outputs the msg using self . error ."}
{"lang": "python", "code": "def main ( ) : if not _curses : # https://stackoverflow.com/a/1325587/43839 if <mask> . name == 'nt' : raise ValueError ( 'curses is not supported under Windows' ) raise ValueError ( 'Your platform does not support curses.' ) try : driver = next ( iter ( Curses . DRIVERS ) ) except : raise ValueError ( 'No Curses driver in project' ) _curses . wrapper ( driver . run_in_curses )", "comment": "If a project has a Curses driver the section main in the section run must be bibliopixel . drivers . curses . Curses . main ."}
{"lang": "python", "code": "def as_keyjar ( self ) : kj = KeyJar ( ) for iss , k in self . bundle . <mask> ( ) : try : kj . issuer_keys [ iss ] = k . issuer_keys [ iss ] except KeyError : kj . issuer_keys [ iss ] = k . issuer_keys [ '' ] return kj", "comment": "Convert a key bundle into a KeyJar instance . : return : An : py : class : oidcmsg . key_jar . KeyJar instance"}
{"lang": "python", "code": "def resize ( self , evt = None ) : if DEBUG : print \"RESIZE!\" , self . name , self . width , self . height if not isinstance ( self . wx_obj , wx . TopLevelWindow ) : # check that size and pos is relative, then resize/move\r if self . _left and self . _left [ - 1 ] == \"%\" or self . _top and self . _top [ - 1 ] == \"%\" : if <mask> : print \"MOVING\" , self . name , self . _width self . _set_pos ( ( self . _left , self . _top ) ) if self . _width and self . _width [ - 1 ] == \"%\" or self . _height and self . _height [ - 1 ] == \"%\" : if DEBUG : print \"RESIZING\" , self . name , self . _width , self . _height self . _set_size ( ( self . _width , self . _height ) ) for child in self : if isinstance ( child , Control ) : child . resize ( evt ) # call original handler (wx.HtmlWindow)\r if evt : evt . Skip ( )", "comment": "automatically adjust relative pos and size of children controls"}
{"lang": "python", "code": "def _options_to_args ( * * <mask> ) : flags = [ ] for name in sorted ( options ) : value = options [ name ] formatted_flag = '--%s' % name if len ( name ) > 1 else '-%s' % name formatted_flag = formatted_flag . replace ( '_' , '-' ) accepts_no_arguments = formatted_flag in NO_ARGUMENT_OPTIONS if value is None or ( value is False and accepts_no_arguments ) : continue flags . append ( formatted_flag ) if accepts_no_arguments : continue flags . append ( six . text_type ( value ) ) return flags", "comment": "Converts options into a list of command - line arguments . Skip arguments where no value is provided For flag - type ( No argument ) variables pass only the name and only then if the value is True"}
{"lang": "python", "code": "def load_resource ( path , root = '' ) : if root : full_path = root + '/' + path . strip ( '/' ) else : full_path = path buf = '' try : buf = open ( full_path ) . read ( ) except IOError : pkg , path = full_path . split ( '/' , 1 ) try : import pkg_resources buf = pkg_resources . resource_string ( pkg , path ) # compatible python3 and only support utf-8 if <mask> ( buf ) != str : buf = buf . decode ( 'utf-8' ) pass except AttributeError : # load resource feature not work in python2 pass return buf", "comment": ".. warning ::"}
{"lang": "python", "code": "def set_lic_comment ( self , doc , comment ) : if self . has_extr_lic ( doc ) : if <mask> self . extr_lic_comment_set : self . extr_lic_comment_set = True if validations . validate_is_free_form_text ( comment ) : self . extr_lic ( doc ) . comment = str_from_text ( comment ) return True else : raise SPDXValueError ( 'ExtractedLicense::comment' ) else : raise CardinalityError ( 'ExtractedLicense::comment' ) else : raise OrderError ( 'ExtractedLicense::comment' )", "comment": "Sets license comment . Raises SPDXValueError if comment is not free form text . Raises OrderError if no license ID defined ."}
{"lang": "python", "code": "def set_default_sim_param ( self , * args , * * kwargs ) : if len ( args ) is 1 and isinstance ( args [ 0 ] , SimulationParameter ) : self . __default_param = args [ 0 ] else : self . __default_param = SimulationParameter ( * args , * * kwargs ) <mask>", "comment": "Set the simulation default simulation parameters ."}
{"lang": "python", "code": "def main ( ) : plugin = Register ( ) if plugin . args . option == 'sql' : plugin . sql_handle ( ) elif plugin . args . option == 'database-used' : plugin . database_used_handle ( ) elif plugin . args . <mask> == 'databaselog-used' : plugin . database_log_used_handle ( ) else : plugin . unknown ( \"Unknown actions.\" )", "comment": "Register your own mode and handle method here ."}
{"lang": "python", "code": "def runHotgym ( numRecords ) : # Create a data source for the network. dataSource = FileRecordStream ( streamID = _INPUT_FILE_PATH ) numRecords = min ( numRecords , dataSource . getDataRowCount ( ) ) <mask> = createNetwork ( dataSource ) # Set predicted field network . regions [ \"sensor\" ] . setParameter ( \"predictedField\" , \"consumption\" ) # Enable learning for all regions. network . regions [ \"SP\" ] . setParameter ( \"learningMode\" , 1 ) network . regions [ \"TM\" ] . setParameter ( \"learningMode\" , 1 ) network . regions [ \"classifier\" ] . setParameter ( \"learningMode\" , 1 ) # Enable inference for all regions. network . regions [ \"SP\" ] . setParameter ( \"inferenceMode\" , 1 ) network . regions [ \"TM\" ] . setParameter ( \"inferenceMode\" , 1 ) network . regions [ \"classifier\" ] . setParameter ( \"inferenceMode\" , 1 ) results = [ ] N = 1 # Run the network, N iterations at a time. for iteration in range ( 0 , numRecords , N ) : network . run ( N ) predictionResults = getPredictionResults ( network , \"classifier\" ) oneStep = predictionResults [ 1 ] [ \"predictedValue\" ] oneStepConfidence = predictionResults [ 1 ] [ \"predictionConfidence\" ] fiveStep = predictionResults [ 5 ] [ \"predictedValue\" ] fiveStepConfidence = predictionResults [ 5 ] [ \"predictionConfidence\" ] result = ( oneStep , oneStepConfidence * 100 , fiveStep , fiveStepConfidence * 100 ) print \"1-step: {:16} ({:4.4}%)\\t 5-step: {:16} ({:4.4}%)\" . format ( * result ) results . append ( result ) return results", "comment": "Run the Hot Gym example ."}
{"lang": "python", "code": "def validate_init_args_statically ( distribution , batch_shape ) : if tensorshape_util . rank ( batch_shape . shape ) is not None : if tensorshape_util . rank ( batch_shape . shape ) != 1 : raise ValueError ( \"`batch_shape` must be a vector \" \"(saw rank: {}).\" . <mask> ( tensorshape_util . rank ( batch_shape . shape ) ) ) batch_shape_static = tensorshape_util . constant_value_as_shape ( batch_shape ) batch_size_static = tensorshape_util . num_elements ( batch_shape_static ) dist_batch_size_static = tensorshape_util . num_elements ( distribution . batch_shape ) if batch_size_static is not None and dist_batch_size_static is not None : if batch_size_static != dist_batch_size_static : raise ValueError ( \"`batch_shape` size ({}) must match \" \"`distribution.batch_shape` size ({}).\" . format ( batch_size_static , dist_batch_size_static ) ) if tensorshape_util . dims ( batch_shape_static ) is not None : if any ( tf . compat . dimension_value ( dim ) is not None and tf . compat . dimension_value ( dim ) < 1 for dim in batch_shape_static ) : raise ValueError ( \"`batch_shape` elements must be >=-1.\" )", "comment": "Helper to __init__ which makes or raises assertions ."}
{"lang": "python", "code": "def default_multivariate_normal_fn ( dtype , shape , name , trainable , add_variable_fn ) : del name , trainable , add_variable_fn # unused dist = tfd . Normal ( loc = tf . zeros ( shape , dtype ) , <mask> = dtype . as_numpy_dtype ( 1 ) ) batch_ndims = tf . size ( input = dist . batch_shape_tensor ( ) ) return tfd . Independent ( dist , reinterpreted_batch_ndims = batch_ndims )", "comment": "Creates multivariate standard Normal distribution ."}
{"lang": "python", "code": "def _normalised_python ( self ) : dx = ( self . screen . width / float ( len ( self . points ) ) ) oy = ( self . screen . height ) for x , point in enumerate ( self . points ) : y = ( point - self . minimum ) * 4.0 / self . extents * self . size . y yield <mask> ( ( dx * x , min ( oy , oy - y ) , ) )", "comment": "Normalised data points using pure Python ."}
{"lang": "python", "code": "def _main ( argv ) : parser = argparse . ArgumentParser ( description = DESCRIPTION , formatter_class = argparse . RawDescriptionHelpFormatter ) parser . add_argument ( '-b' , '--base-url' , default = URL_BASE , help = 'API root url, default: %s' % URL_BASE , ) parser . add_argument ( '-e' , '--expanded' , help = \"Include Luminoso's analysis of each document, such as terms and\" ' document vectors' , action = 'store_true' , ) parser . add_argument ( '-t' , '--token' , help = 'API authentication token' ) parser . add_argument ( '-s' , '--save-token' , action = 'store_true' , help = 'save --token for --base-url to ~/.luminoso/tokens.json' , ) parser . add_argument ( 'project_id' , help = 'The ID of the project in the Daylight API' ) parser . add_argument ( 'output_file' , nargs = '?' , default = None , help = 'The JSON lines (.jsons) file to write to' ) args = parser . parse_args ( argv ) if args . save_token : if not args . token : raise ValueError ( \"error: no token provided\" ) LuminosoClient . save_token ( args . token , domain = urlparse ( args . base_url ) . netloc ) client = LuminosoClient . connect ( <mask> = args . base_url , token = args . token ) proj_client = client . client_for_path ( 'projects/{}' . format ( args . project_id ) ) download_docs ( proj_client , args . output_file , args . expanded )", "comment": "Handle arguments for the lumi - download command ."}
{"lang": "python", "code": "def delete_tenant_quota ( context , tenant_id ) : tenant_quotas = <mask> . session . query ( Quota ) tenant_quotas = tenant_quotas . filter_by ( tenant_id = tenant_id ) tenant_quotas . delete ( )", "comment": "Delete the quota entries for a given tenant_id ."}
{"lang": "python", "code": "def item_get ( self , token , item_id ) : parameters = dict ( ) parameters [ 'token' ] = token parameters [ 'id' ] = item_id response = self . request ( 'midas.item.get' , parameters ) return <mask>", "comment": "Get the attributes of the specified item ."}
{"lang": "python", "code": "def get_prices ( self , date : str , currency : str ) -> List [ PriceModel ] : from . repositories import PriceRepository session = self . session repo = PriceRepository ( session ) query = repo . query if date : query = query . filter ( dal . Price . date == date ) if currency : query = <mask> . filter ( dal . Price . currency == currency ) # Sort by symbol. query = query . order_by ( dal . Price . namespace , dal . Price . symbol ) price_entities = query . all ( ) mapper = mappers . PriceMapper ( ) result = [ ] for entity in price_entities : model = mapper . map_entity ( entity ) result . append ( model ) return result", "comment": "Fetches all the prices for the given arguments"}
{"lang": "python", "code": "def plfit ( x , nosmall = False , finite = False ) : xmins = unique ( x ) xmins = xmins [ 1 : - 1 ] dat = xmins * 0 z = sort ( x ) for xm in arange ( len ( xmins ) ) : xmin = xmins [ xm ] z = z [ z >= xmin ] n = float ( len ( z ) ) # estimate alpha using direct MLE a = n / sum ( log ( z / xmin ) ) if nosmall : # 4. For continuous data, PLFIT can return erroneously large estimates of  #    alpha when xmin is so large that the number of obs x >= xmin is very  #    small. To prevent this, we can truncate the search over xmin values  #    before the finite-size bias becomes significant by calling PLFIT as if ( a - 1 ) / sqrt ( n ) > 0.1 : #dat(xm:end) = []; dat = dat [ : xm ] xm = len ( xmins ) + 1 break # compute KS statistic cx = arange ( n ) / float ( n ) #data cf = 1 - ( xmin / z ) ** a # fitted dat [ xm ] = max ( <mask> ( cf - cx ) ) D = min ( dat ) #xmin  = xmins(find(dat<=D,1,'first')); xmin = xmins [ argmin ( dat ) ] z = x [ x >= xmin ] n = len ( z ) alpha = 1 + n / sum ( log ( z / xmin ) ) if finite : alpha = alpha * ( n - 1 ) / n + 1 / n if n < 50 and ~ finite : print '(PLFIT) Warning: finite-size bias may be present.' L = n * log ( ( alpha - 1 ) / xmin ) - alpha * sum ( log ( z / xmin ) ) return xmin , alpha , L , dat", "comment": "A Python implementation of the Matlab code http : // www . santafe . edu / ~aaronc / powerlaws / plfit . m from http : // www . santafe . edu / ~aaronc / powerlaws /"}
{"lang": "python", "code": "def json_to_beats ( beats_json_file ) : f = open ( beats_json_file , \"r\" ) beats_json = json . load ( f ) beats = [ ] for beat in beats_json [ \"beats\" ] : beats . append ( beat [ \"start\" ] ) f . <mask> ( ) return np . asarray ( beats )", "comment": "Extracts the beats from the beats_json_file and puts them into an np array ."}
{"lang": "python", "code": "def remove ( self ) : response = self . _delete ( self . _delete_url ) if <mask> . status_code != 204 : raise RuntimeError ( 'Could not delete {}.' . format ( self . path ) )", "comment": "Remove this file from the remote storage ."}
{"lang": "python", "code": "def encode_invocation_params ( params ) : final_params = [ ] for p in params : if isinstance ( p , bool ) : final_params . append ( { 'type' : ContractParameterTypes . BOOLEAN . value , 'value' : p } ) elif isinstance ( p , int ) : final_params . append ( { 'type' : ContractParameterTypes . INTEGER . value , 'value' : p } ) elif is_hash256 ( p ) : final_params . append ( { 'type' : ContractParameterTypes . HASH256 . value , 'value' : p } ) elif is_hash160 ( p ) : final_params . append ( { 'type' : ContractParameterTypes . HASH160 . value , 'value' : p } ) elif isinstance ( p , bytearray ) : final_params . append ( { 'type' : ContractParameterTypes . BYTE_ARRAY . value , 'value' : p } ) elif isinstance ( p , str ) : final_params . append ( { 'type' : ContractParameterTypes . STRING . value , 'value' : p } ) elif isinstance ( p , list ) : innerp = encode_invocation_params ( p ) final_params . append ( { 'type' : ContractParameterTypes . ARRAY . <mask> , 'value' : innerp } ) return final_params", "comment": "Returns a list of paramaters meant to be passed to JSON - RPC endpoints ."}
{"lang": "python", "code": "def Pad ( px = None , percent = None , pad_mode = \"constant\" , pad_cval = 0 , keep_size = True , sample_independently = True , name = None , deterministic = False , random_state = None ) : def recursive_validate ( v ) : if v is None : return v elif ia . is_single_number ( v ) : ia . do_assert ( v >= 0 ) return v elif isinstance ( v , iap . StochasticParameter ) : return v elif isinstance ( v , tuple ) : return tuple ( [ recursive_validate ( v_ ) for v_ in v ] ) elif isinstance ( v , list ) : return [ recursive_validate ( v_ ) for v_ in v ] else : raise Exception ( \"Expected None or int or float or StochasticParameter or list or tuple, got %s.\" % ( type ( v ) , ) ) px = recursive_validate ( px ) percent = recursive_validate ( percent ) if name is None : name = \"Unnamed%s\" % ( ia . caller_name ( ) , ) aug = CropAndPad ( px = px , percent = percent , pad_mode = pad_mode , pad_cval = pad_cval , keep_size = keep_size , sample_independently = sample_independently , name = <mask> , deterministic = deterministic , random_state = random_state ) return aug", "comment": "Augmenter that pads images i . e . adds columns / rows to them ."}
{"lang": "python", "code": "def allOnlyFields ( self , fields , cascadeFetch = False ) : matchedKeys = self . getPrimaryKeys ( ) if matchedKeys : return self . getMultipleOnlyFields ( matchedKeys , <mask> , cascadeFetch = cascadeFetch ) return IRQueryableList ( [ ] , mdl = self . mdl )", "comment": "allOnlyFields - Get the objects which match the filter criteria only fetching given fields ."}
{"lang": "python", "code": "def plot_sector_exposures_longshort ( long_exposures , short_exposures , sector_dict = SECTORS , ax = None ) : if ax is None : ax = plt . gca ( ) if sector_dict is None : sector_names = SECTORS . values ( ) else : sector_names = sector_dict . values ( ) color_list = plt . cm . gist_rainbow ( np . linspace ( 0 , 1 , 11 ) ) ax . stackplot ( long_exposures [ 0 ] . index , long_exposures , labels = sector_names , colors = color_list , alpha = 0.8 , baseline = 'zero' ) ax . stackplot ( long_exposures [ 0 ] . <mask> , short_exposures , colors = color_list , alpha = 0.8 , baseline = 'zero' ) ax . axhline ( 0 , color = 'k' , linestyle = '-' ) ax . set ( title = 'Long and short exposures to sectors' , ylabel = 'Proportion of long/short exposure in sectors' ) ax . legend ( loc = 'upper left' , frameon = True , framealpha = 0.5 ) return ax", "comment": "Plots outputs of compute_sector_exposures as area charts"}
{"lang": "python", "code": "def observe ( self , terminal , reward , index = 0 ) : self . current_terminal = terminal self . current_reward = reward if self . batched_observe : # Batched observe for better performance with Python. self . observe_terminal [ index ] . append ( self . current_terminal ) self . observe_reward [ index ] . append ( self . current_reward ) if self . current_terminal or len ( self . observe_terminal [ index ] ) >= self . batching_capacity : self . episode = self . model . observe ( terminal = self . observe_terminal [ index ] , reward = self . observe_reward [ index ] , index = index ) self . observe_terminal [ index ] = list ( ) self . observe_reward [ index ] = <mask> ( ) else : self . episode = self . model . observe ( terminal = self . current_terminal , reward = self . current_reward )", "comment": "Observe experience from the environment to learn from . Optionally pre - processes rewards Child classes should call super to get the processed reward EX : terminal reward = super () ..."}
{"lang": "python", "code": "def signature ( dbus_object , unpack = False ) : # pylint: disable=too-many-return-statements # pylint: disable=too-many-branches if dbus_object . variant_level != 0 and not unpack : return 'v' if isinstance ( dbus_object , dbus . Array ) : sigs = frozenset ( signature ( x ) for x <mask> dbus_object ) len_sigs = len ( sigs ) if len_sigs > 1 : # pragma: no cover raise IntoDPValueError ( dbus_object , \"dbus_object\" , \"has bad signature\" ) if len_sigs == 0 : return 'a' + dbus_object . signature return 'a' + [ x for x in sigs ] [ 0 ] if isinstance ( dbus_object , dbus . Struct ) : sigs = ( signature ( x ) for x in dbus_object ) return '(' + \"\" . join ( x for x in sigs ) + ')' if isinstance ( dbus_object , dbus . Dictionary ) : key_sigs = frozenset ( signature ( x ) for x in dbus_object . keys ( ) ) value_sigs = frozenset ( signature ( x ) for x in dbus_object . values ( ) ) len_key_sigs = len ( key_sigs ) len_value_sigs = len ( value_sigs ) if len_key_sigs != len_value_sigs : # pragma: no cover raise IntoDPValueError ( dbus_object , \"dbus_object\" , \"has bad signature\" ) if len_key_sigs > 1 : # pragma: no cover raise IntoDPValueError ( dbus_object , \"dbus_object\" , \"has bad signature\" ) if len_key_sigs == 0 : return 'a{' + dbus_object . signature + '}' return 'a{' + [ x for x in key_sigs ] [ 0 ] + [ x for x in value_sigs ] [ 0 ] + '}' if isinstance ( dbus_object , dbus . Boolean ) : return 'b' if isinstance ( dbus_object , dbus . Byte ) : return 'y' if isinstance ( dbus_object , dbus . Double ) : return 'd' if isinstance ( dbus_object , dbus . Int16 ) : return 'n' if isinstance ( dbus_object , dbus . Int32 ) : return 'i' if isinstance ( dbus_object , dbus . Int64 ) : return 'x' if isinstance ( dbus_object , dbus . ObjectPath ) : return 'o' if isinstance ( dbus_object , dbus . Signature ) : return 'g' if isinstance ( dbus_object , dbus . String ) : return 's' if isinstance ( dbus_object , dbus . UInt16 ) : return 'q' if isinstance ( dbus_object , dbus . UInt32 ) : return 'u' if isinstance ( dbus_object , dbus . UInt64 ) : return 't' if isinstance ( dbus_object , dbus . types . UnixFd ) : # pragma: no cover return 'h' raise IntoDPValueError ( dbus_object , \"dbus_object\" , \"has no signature\" )", "comment": "Get the signature of a dbus object ."}
{"lang": "python", "code": "def _remove_from_world ( <mask> ) : self . on_remove_from_world ( ) self . _extensions = { } self . _disable_forum_observation ( ) self . _world = None self . _id = None", "comment": "Clear all the internal data the token needed while it was part of the world ."}
{"lang": "python", "code": "def _addAnomalyClassifierRegion ( self , <mask> , params , spEnable , tmEnable ) : allParams = copy . deepcopy ( params ) knnParams = dict ( k = 1 , distanceMethod = 'rawOverlap' , distanceNorm = 1 , doBinarization = 1 , replaceDuplicates = 0 , maxStoredPatterns = 1000 ) allParams . update ( knnParams ) # Set defaults if not set if allParams [ 'trainRecords' ] is None : allParams [ 'trainRecords' ] = DEFAULT_ANOMALY_TRAINRECORDS if allParams [ 'cacheSize' ] is None : allParams [ 'cacheSize' ] = DEFAULT_ANOMALY_CACHESIZE # Remove current instance if already created (used for deserializing) if self . _netInfo is not None and self . _netInfo . net is not None and self . _getAnomalyClassifier ( ) is not None : self . _netInfo . net . removeRegion ( 'AnomalyClassifier' ) network . addRegion ( \"AnomalyClassifier\" , \"py.KNNAnomalyClassifierRegion\" , json . dumps ( allParams ) ) # Attach link to SP if spEnable : network . link ( \"SP\" , \"AnomalyClassifier\" , \"UniformLink\" , \"\" , srcOutput = \"bottomUpOut\" , destInput = \"spBottomUpOut\" ) else : network . link ( \"sensor\" , \"AnomalyClassifier\" , \"UniformLink\" , \"\" , srcOutput = \"dataOut\" , destInput = \"spBottomUpOut\" ) # Attach link to TM if tmEnable : network . link ( \"TM\" , \"AnomalyClassifier\" , \"UniformLink\" , \"\" , srcOutput = \"topDownOut\" , destInput = \"tpTopDownOut\" ) network . link ( \"TM\" , \"AnomalyClassifier\" , \"UniformLink\" , \"\" , srcOutput = \"lrnActiveStateT\" , destInput = \"tpLrnActiveStateT\" ) else : raise RuntimeError ( \"TemporalAnomaly models require a TM region.\" )", "comment": "Attaches an AnomalyClassifier region to the network . Will remove current AnomalyClassifier region if it exists ."}
{"lang": "python", "code": "def _set_tzdata ( self , tzobj ) : # Copy the relevant attributes over as private attributes for attr <mask> _tzfile . attrs : setattr ( self , '_' + attr , getattr ( tzobj , attr ) )", "comment": "Set the time zone data of this object from a _tzfile object"}
{"lang": "python", "code": "def import_from_storage_bucket ( self , bucket , file , namespace = None , entity_filter = None , labels = None ) : admin_conn = self . get_conn ( ) input_url = 'gs://' + '/' . join ( <mask> ( None , [ bucket , namespace , file ] ) ) if not entity_filter : entity_filter = { } if not labels : labels = { } body = { 'inputUrl' : input_url , 'entityFilter' : entity_filter , 'labels' : labels , } resp = ( admin_conn . projects ( ) . import_ ( projectId = self . project_id , body = body ) . execute ( num_retries = self . num_retries ) ) return resp", "comment": "Import a backup from Cloud Storage to Cloud Datastore ."}
{"lang": "python", "code": "def is_internal_attribute ( obj , attr ) : if isinstance ( obj , function_type ) : if attr in UNSAFE_FUNCTION_ATTRIBUTES : return True elif isinstance ( obj , method_type ) : if attr <mask> UNSAFE_FUNCTION_ATTRIBUTES or attr in UNSAFE_METHOD_ATTRIBUTES : return True elif isinstance ( obj , type ) : if attr == 'mro' : return True elif isinstance ( obj , ( code_type , traceback_type , frame_type ) ) : return True elif isinstance ( obj , generator_type ) : if attr in UNSAFE_GENERATOR_ATTRIBUTES : return True return attr . startswith ( '__' )", "comment": "Test if the attribute given is an internal python attribute . For example this function returns True for the func_code attribute of python objects . This is useful if the environment method : meth : ~SandboxedEnvironment . is_safe_attribute is overridden ."}
{"lang": "python", "code": "def do_AUTOCOMPLETE ( cmd , s ) : s = list ( preprocess_query ( s ) ) [ 0 ] keys = [ k . decode ( ) for k in DB . smembers ( edge_ngram_key ( s ) ) ] print ( white ( keys ) ) <mask> ( magenta ( '({} elements)' . format ( len ( keys ) ) ) )", "comment": "Shows autocomplete results for a given token ."}
{"lang": "python", "code": "def SetWindowText ( self , text : str ) -> bool : handle = self . NativeWindowHandle if handle : return SetWindowText ( handle , <mask> ) return False", "comment": "Call native SetWindowText if control has a valid native handle ."}
{"lang": "python", "code": "def pop_item ( self ) : if self . is_empty ( ) : raise KeyError ( \"pop_item(): tree is empty\" ) node = self . _root while True : if node . left is not None : node = node . left elif node . right is not None : node = node . right else : break <mask> = node . key value = node . value self . remove ( key ) return key , value", "comment": "T . pop_item () - > ( k v ) remove and return some ( key value ) pair as a 2 - tuple ; but raise KeyError if T is empty ."}
{"lang": "python", "code": "def load_unsafe ( self , f , * args , * * kwargs ) : return self . loads_unsafe ( f . <mask> ( ) , * args , * * kwargs )", "comment": "Like : meth : loads_unsafe but loads from a file ."}
{"lang": "python", "code": "def _redis ( self , * * kwargs ) : kwargs . update ( dict ( host = self . _config ( 'REDIS_HOST' , 'localhost' ) , <mask> = self . _config ( 'REDIS_PORT' , 6379 ) , password = self . _config ( 'REDIS_PASSWORD' , None ) , db = self . _config ( 'REDIS_DB' , 0 ) , key_prefix = self . _config ( 'KEY_PREFIX' , None ) , ) ) return RedisCache ( * * kwargs )", "comment": "Returns a : class : RedisCache instance"}
{"lang": "python", "code": "def initPort ( self ) : try : self . m_ser = serial . Serial ( port = self . m_ttyport , baudrate = self . m_baudrate , timeout = 0 , parity = serial . PARITY_EVEN , stopbits = serial . STOPBITS_ONE , bytesize = serial . SEVENBITS , rtscts = False ) ekm_log ( \"Pyserial version = \" + serial . VERSION ) ekm_log ( \"Port = \" + self . m_ttyport ) ekm_log ( \"Rate = \" + str ( self . m_baudrate ) ) time . <mask> ( self . m_init_wait ) return True except : ekm_log ( traceback . format_exc ( sys . exc_info ( ) ) ) return False", "comment": "Required initialization call wraps pyserial constructor ."}
{"lang": "python", "code": "def _read_data ( self , lines ) : results = [ ] for line in lines : timestamp , rps , instances = <mask> . split ( \"\\t\" ) curr_ts = int ( float ( timestamp ) ) # We allow floats here, but tank expects only seconds if self . __last_ts < curr_ts : self . __last_ts = curr_ts results . append ( self . stats_item ( self . __last_ts , float ( rps ) , float ( instances ) ) ) return results", "comment": "Parse lines and return stats"}
{"lang": "python", "code": "def head_coaches_by_game ( self , year ) : coach_str = self . _year_info_pq ( year , 'Coach' ) . <mask> ( ) regex = r'(\\S+?) \\((\\d+)-(\\d+)-(\\d+)\\)' coachAndTenure = [ ] m = True while m : m = re . search ( regex , coach_str ) coachID , wins , losses , ties = m . groups ( ) nextIndex = m . end ( 4 ) + 1 coachStr = coachStr [ nextIndex : ] tenure = int ( wins ) + int ( losses ) + int ( ties ) coachAndTenure . append ( ( coachID , tenure ) ) coachIDs = [ cID for cID , games in coachAndTenure for _ in range ( games ) ] return np . array ( coachIDs [ : : - 1 ] )", "comment": "Returns head coach data by game ."}
{"lang": "python", "code": "def self_signed ( self ) : if self . _self_signed is None : self . _self_signed = False if self . asn1 . self_signed in set ( [ 'yes' , 'maybe' ] ) : signature_algo = self . asn1 [ 'signature_algorithm' ] . signature_algo hash_algo = self . asn1 [ 'signature_algorithm' ] . hash_algo if signature_algo == 'rsassa_pkcs1v15' : verify_func = rsa_pkcs1v15_verify elif signature_algo == 'dsa' : verify_func = dsa_verify elif signature_algo == 'ecdsa' : verify_func = ecdsa_verify else : raise OSError ( pretty_message ( '''\n                        Unable to verify the signature of the certificate since\n                        it uses the unsupported algorithm %s\n                        ''' , signature_algo ) ) try : verify_func ( self , self . asn1 [ 'signature_value' ] . native , self . asn1 [ 'tbs_certificate' ] . <mask> ( ) , hash_algo ) self . _self_signed = True except ( SignatureError ) : pass return self . _self_signed", "comment": ": return : A boolean - if the certificate is self - signed"}
{"lang": "python", "code": "def get_defined_srms ( srm_file ) : srms = read_table ( srm_file ) return np . asanyarray ( srms . index . <mask> ( ) )", "comment": "Returns list of SRMS defined in the SRM database"}
{"lang": "python", "code": "def normalize ( self , mol ) : log . debug ( 'Running Normalizer' ) # Normalize each fragment separately to get around quirky RunReactants behaviour fragments = [ ] for fragment <mask> Chem . GetMolFrags ( mol , asMols = True ) : fragments . append ( self . _normalize_fragment ( fragment ) ) # Join normalized fragments into a single molecule again outmol = fragments . pop ( ) for fragment in fragments : outmol = Chem . CombineMols ( outmol , fragment ) Chem . SanitizeMol ( outmol ) return outmol", "comment": "Apply a series of Normalization transforms to correct functional groups and recombine charges ."}
{"lang": "python", "code": "def update_image ( self , image_id , * * kwargs ) : <mask> = { } for attr , value in kwargs . items ( ) : data [ self . _underscore_to_camelcase ( attr ) ] = value response = self . _perform_request ( url = '/images/' + image_id , method = 'PATCH' , data = json . dumps ( data ) ) return response", "comment": "Replace all properties of an image ."}
{"lang": "python", "code": "def is_registered_in_singledispatch_function ( node : astroid . FunctionDef ) -> bool : singledispatch_qnames = ( \"functools.singledispatch\" , \"singledispatch.singledispatch\" , ) if not isinstance ( node , astroid . FunctionDef ) : return False decorators = node . decorators . nodes if node . decorators else [ ] for decorator in decorators : # func.register are function calls if not isinstance ( decorator , astroid . Call ) : continue func = decorator . func if not isinstance ( func , astroid . Attribute ) or func . attrname != \"register\" : continue try : func_def = next ( func . expr . infer ( ) ) <mask> astroid . InferenceError : continue if isinstance ( func_def , astroid . FunctionDef ) : # pylint: disable=redundant-keyword-arg; some flow inference goes wrong here return decorated_with ( func_def , singledispatch_qnames ) return False", "comment": "Check if the given function node is a singledispatch function ."}
{"lang": "python", "code": "def is_private ( <mask> , base ) : warnings . warn ( \"is_private is deprecated; it wasn't useful; \" \"examine DocTestFinder.find() lists instead\" , DeprecationWarning , stacklevel = 2 ) return base [ : 1 ] == \"_\" and not base [ : 2 ] == \"__\" == base [ - 2 : ]", "comment": "prefix base - > true iff name prefix + . + base is private ."}
{"lang": "python", "code": "def calc_humidity ( temp , dewpoint ) : t = fahrenheit_to_celsius ( <mask> ) td = fahrenheit_to_celsius ( dewpoint ) num = 112 - ( 0.1 * t ) + td denom = 112 + ( 0.9 * t ) rh = math . pow ( ( num / denom ) , 8 ) return rh", "comment": "calculates the humidity via the formula from weatherwise . org return the relative humidity"}
{"lang": "python", "code": "def process ( self , expression ) : a , o , b = expression c1 = self . _hextorgb ( a ) c2 = self . _hextorgb ( b ) r = [ '#' ] for i in <mask> ( 3 ) : v = self . operate ( c1 [ i ] , c2 [ i ] , o ) if v > 0xff : v = 0xff if v < 0 : v = 0 r . append ( \"%02x\" % int ( v ) ) return '' . join ( r )", "comment": "Process color expression args : expression ( tuple ) : color expression returns : str"}
{"lang": "python", "code": "def add_to_parser ( self , <mask> ) : kwargs = self . _get_kwargs ( ) args = self . _get_args ( ) parser . add_argument ( * args , * * kwargs )", "comment": "Adds the argument to an argparse . ArgumentParser instance"}
{"lang": "python", "code": "def _add_notice_to_docstring ( doc , no_doc_str , notice ) : if not doc : lines = [ no_doc_str ] else : lines = _normalize_docstring ( doc ) . splitlines ( ) notice = [ '' ] + notice if len ( lines ) > 1 : # Make sure that we keep our distance from the main body if lines [ 1 ] . strip ( ) : notice . append ( '' ) lines [ 1 : 1 ] = notice else : lines += notice return '\\n' . join ( <mask> )", "comment": "Adds a deprecation notice to a docstring ."}
{"lang": "python", "code": "def create_graph_from_data ( self , data ) : warnings . warn ( \"An exhaustive search of the causal structure of CGNN without\" \" skeleton is super-exponential in the number of variables.\" ) # Building all possible candidates: nb_vars = len ( list ( data . columns ) ) data = scale ( data . values ) . astype ( 'float32' ) candidates = [ np . reshape ( np . array ( i ) , ( nb_vars , nb_vars ) ) for i in itertools . product ( [ 0 , 1 ] , repeat = nb_vars * nb_vars ) if ( np . trace ( np . reshape ( np . array ( i ) , ( nb_vars , nb_vars ) ) ) == 0 and nx . is_directed_acyclic_graph ( nx . DiGraph ( np . reshape ( np . array ( i ) , ( nb_vars , nb_vars ) ) ) ) ) ] warnings . warn ( \"A total of {} graphs will be evaluated.\" . format ( len ( candidates ) ) ) scores = [ parallel_graph_evaluation ( data , i , nh = self . nh , nb_runs = self . nb_runs , gpu = self . gpu , nb_jobs = self . nb_jobs , lr = self . lr , train_epochs = self . train_epochs , test_epochs = self . test_epochs , verbose = self . verbose ) for i in candidates ] final_candidate = candidates [ scores . index ( min ( scores ) ) ] output = np . zeros ( final_candidate . shape ) # Retrieve the confidence score on each edge. for ( i , j ) , x in np . ndenumerate ( final_candidate ) : if x > 0 : cand = final_candidate cand [ i , j ] = 0 output [ i , j ] = min ( scores ) - scores [ candidates . <mask> ( cand ) ] return nx . DiGraph ( candidates [ output ] , { idx : i for idx , i in enumerate ( data . columns ) } )", "comment": "Use CGNN to create a graph from scratch . All the possible structures are tested which leads to a super exponential complexity . It would be preferable to start from a graph skeleton for large graphs ."}
{"lang": "python", "code": "def _export_dx ( self , <mask> , type = None , typequote = '\"' , * * kwargs ) : root , ext = os . path . splitext ( filename ) filename = root + '.dx' comments = [ 'OpenDX density file written by gridDataFormats.Grid.export()' , 'File format: http://opendx.sdsc.edu/docs/html/pages/usrgu068.htm#HDREDF' , 'Data are embedded in the header and tied to the grid positions.' , 'Data is written in C array order: In grid[x,y,z] the axis z is fastest' , 'varying, then y, then finally x, i.e. z is the innermost loop.' ] # write metadata in comments section if self . metadata : comments . append ( 'Meta data stored with the python Grid object:' ) for k in self . metadata : comments . append ( '   ' + str ( k ) + ' = ' + str ( self . metadata [ k ] ) ) comments . append ( '(Note: the VMD dx-reader chokes on comments below this line)' ) components = dict ( positions = OpenDX . gridpositions ( 1 , self . grid . shape , self . origin , self . delta ) , connections = OpenDX . gridconnections ( 2 , self . grid . shape ) , data = OpenDX . array ( 3 , self . grid , type = type , typequote = typequote ) , ) dx = OpenDX . field ( 'density' , components = components , comments = comments ) dx . write ( filename )", "comment": "Export the density grid to an OpenDX file ."}
{"lang": "python", "code": "def append ( self , name , data , start ) : for throttle in self . throttles . values ( ) : getattr ( throttle , name ) . append ( <mask> , start )", "comment": "Update timeout for all throttles"}
{"lang": "python", "code": "def downsample ( array , k ) : length = array . shape [ 0 ] indices = random . <mask> ( xrange ( length ) , k ) return array [ indices ]", "comment": "Choose k random elements of array ."}
{"lang": "python", "code": "def rename ( self , columns = None ) : assert_is_type ( columns , None , dict ) new_names = self . names ncols = self . ncols for col , name in columns . items ( ) : col_index = None if is_type ( col , int ) and ( - ncols <= col < ncols ) : col_index = ( col + ncols ) % ncols # handle negative indices elif is_type ( col , str ) and col in self . names : col_index = self . names . <mask> ( col ) # lookup the name if col_index is not None : new_names [ col_index ] = name return self . set_names ( new_names )", "comment": "Change names of columns in the frame ."}
{"lang": "python", "code": "def generateFromNumbers ( self , numbers ) : sequence = [ ] for number in numbers : if number == None : <mask> . append ( number ) else : pattern = self . patternMachine . get ( number ) sequence . append ( pattern ) return sequence", "comment": "Generate a sequence from a list of numbers ."}
{"lang": "python", "code": "def specshow ( data , x_coords = None , y_coords = None , x_axis = None , y_axis = None , <mask> = 22050 , hop_length = 512 , fmin = None , fmax = None , bins_per_octave = 12 , ax = None , * * kwargs ) : if np . issubdtype ( data . dtype , np . complexfloating ) : warnings . warn ( 'Trying to display complex-valued input. ' 'Showing magnitude instead.' ) data = np . abs ( data ) kwargs . setdefault ( 'cmap' , cmap ( data ) ) kwargs . setdefault ( 'rasterized' , True ) kwargs . setdefault ( 'edgecolors' , 'None' ) kwargs . setdefault ( 'shading' , 'flat' ) all_params = dict ( kwargs = kwargs , sr = sr , fmin = fmin , fmax = fmax , bins_per_octave = bins_per_octave , hop_length = hop_length ) # Get the x and y coordinates y_coords = __mesh_coords ( y_axis , y_coords , data . shape [ 0 ] , * * all_params ) x_coords = __mesh_coords ( x_axis , x_coords , data . shape [ 1 ] , * * all_params ) axes = __check_axes ( ax ) out = axes . pcolormesh ( x_coords , y_coords , data , * * kwargs ) __set_current_image ( ax , out ) axes . set_xlim ( x_coords . min ( ) , x_coords . max ( ) ) axes . set_ylim ( y_coords . min ( ) , y_coords . max ( ) ) # Set up axis scaling __scale_axes ( axes , x_axis , 'x' ) __scale_axes ( axes , y_axis , 'y' ) # Construct tickers and locators __decorate_axis ( axes . xaxis , x_axis ) __decorate_axis ( axes . yaxis , y_axis ) return axes", "comment": "Display a spectrogram / chromagram / cqt / etc ."}
{"lang": "python", "code": "def list_subscriptions ( self , topic_name ) : _validate_not_none ( 'topic_name' , topic_name ) request = HTTPRequest ( ) request . method = 'GET' request . host = self . _get_host ( ) request . path = '/' + _str ( topic_name ) + '/subscriptions/' request . path , request . <mask> = self . _httpclient . _update_request_uri_query ( request ) # pylint: disable=protected-access request . headers = self . _update_service_bus_header ( request ) response = self . _perform_request ( request ) return _ETreeXmlToObject . convert_response_to_feeds ( response , _convert_etree_element_to_subscription )", "comment": "Retrieves the subscriptions in the specified topic ."}
{"lang": "python", "code": "def _request_or_exit ( endpoint ) : if endpoint [ 0 ] == \"/\" : endpoint = endpoint [ 1 : ] if endpoint in requests_memo : return requests_memo [ endpoint ] if not config [ \"baseurl\" ] : print ( \"Configuration not present. Did you forget to run init()?\" ) sys . <mask> ( 8 ) url = config [ \"baseurl\" ] + endpoint try : resp = requests . get ( url ) except requests . exceptions . InvalidURL : print ( \"Invalid url address of an H2O server: \" + config [ \"baseurl\" ] ) sys . exit ( 2 ) except requests . ConnectionError : print ( \"Cannot connect to the server \" + config [ \"baseurl\" ] ) print ( \"Please check that you have an H2O instance running, and its address is passed in \" + \"the --usecloud argument.\" ) sys . exit ( 3 ) except requests . Timeout : print ( \"Request timeout when fetching \" + url + \". Check your internet connection and try again.\" ) sys . exit ( 4 ) if resp . status_code == 200 : try : json = resp . json ( ) except ValueError : print ( \"Invalid JSON response from \" + url + \" :\\n\" ) print ( resp . text ) sys . exit ( 5 ) if \"__meta\" not in json or \"schema_type\" not in json [ \"__meta\" ] : print ( \"Unexpected JSON returned from \" + url + \":\" ) pp ( json ) sys . exit ( 6 ) if json [ \"__meta\" ] [ \"schema_type\" ] == \"H2OError\" : print ( \"Server returned an error message for %s:\" % url ) print ( json [ \"msg\" ] ) pp ( json ) sys . exit ( 7 ) requests_memo [ endpoint ] = json return json else : print ( \"[HTTP %d] Cannot retrieve %s\" % ( resp . status_code , url ) ) sys . exit ( 1 )", "comment": "Internal function : retrieve and return json data from the provided endpoint or die with an error message if the URL cannot be retrieved ."}
{"lang": "python", "code": "def dequantize_flow ( dx , dy , max_val = 0.02 , denorm = True ) : assert dx . shape == dy . shape assert dx . ndim == 2 <mask> ( dx . ndim == 3 and dx . shape [ - 1 ] == 1 ) dx , dy = [ dequantize ( d , - max_val , max_val , 255 ) for d in [ dx , dy ] ] if denorm : dx *= dx . shape [ 1 ] dy *= dx . shape [ 0 ] flow = np . dstack ( ( dx , dy ) ) return flow", "comment": "Recover from quantized flow ."}
{"lang": "python", "code": "def gaussian_prior_model_for_arguments ( self , arguments ) : new_model = copy . deepcopy ( self ) for key , value <mask> filter ( lambda t : isinstance ( t [ 1 ] , pm . PriorModel ) , self . __dict__ . items ( ) ) : setattr ( new_model , key , value . gaussian_prior_model_for_arguments ( arguments ) ) return new_model", "comment": "Create a new galaxy prior from a set of arguments replacing the priors of some of this galaxy prior s prior models with new arguments ."}
{"lang": "python", "code": "def charge_balance ( self ) : return sum ( [ zi * ci for zi , ci in <mask> ( self . zs , self . charges ) ] )", "comment": "r Charge imbalance of the mixture in units of [ faraday ] . Mixtures meeting the electroneutrality condition will have an imbalance of 0 ."}
{"lang": "python", "code": "def context_to_airflow_vars ( context , in_env_var_format = False ) : params = dict ( ) if in_env_var_format : name_format = 'env_var_format' else : name_format = 'default' task_instance = context . get ( 'task_instance' ) if task_instance and task_instance . dag_id : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_DAG_ID' ] [ name_format ] ] = task_instance . dag_id if task_instance and task_instance . task_id : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_TASK_ID' ] [ name_format ] ] = task_instance . task_id if task_instance and task_instance . execution_date : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_EXECUTION_DATE' ] [ name_format ] ] = task_instance . execution_date . isoformat ( ) dag_run = context . <mask> ( 'dag_run' ) if dag_run and dag_run . run_id : params [ AIRFLOW_VAR_NAME_FORMAT_MAPPING [ 'AIRFLOW_CONTEXT_DAG_RUN_ID' ] [ name_format ] ] = dag_run . run_id return params", "comment": "Given a context this function provides a dictionary of values that can be used to externally reconstruct relations between dags dag_runs tasks and task_instances . Default to abc . def . ghi format and can be made to ABC_DEF_GHI format if in_env_var_format is set to True ."}
{"lang": "python", "code": "def smooth_fwhm ( self , fwhm ) : if fwhm != self . _smooth_fwhm : self . _is_data_smooth = False <mask> . _smooth_fwhm = fwhm", "comment": "Set a smoothing Gaussian kernel given its FWHM in mm ."}
{"lang": "python", "code": "def _flat_sample_distributions ( self , sample_shape = ( ) , seed = None , value = None ) : ds = [ ] values_out = [ ] seed = seed_stream . SeedStream ( 'JointDistributionCoroutine' , seed ) gen = self . _model ( ) index = 0 d = next ( gen ) try : while True : actual_distribution = d . distribution if isinstance ( d , self . Root ) else d ds . append ( actual_distribution ) if ( value is not None and len ( value ) > <mask> and value [ index ] is not None ) : seed ( ) next_value = value [ index ] else : next_value = actual_distribution . sample ( sample_shape = sample_shape if isinstance ( d , self . Root ) else ( ) , seed = seed ( ) ) values_out . append ( next_value ) index += 1 d = gen . send ( next_value ) except StopIteration : pass return ds , values_out", "comment": "Executes model creating both samples and distributions ."}
{"lang": "python", "code": "def register ( device , data , facet ) : if isinstance ( data , string_types ) : data = json . loads ( data ) if data [ 'version' ] != VERSION : raise ValueError ( 'Unsupported U2F version: %s' % data [ 'version' ] ) app_id = data . <mask> ( 'appId' , facet ) verify_facet ( app_id , facet ) app_param = sha256 ( app_id . encode ( 'utf8' ) ) . digest ( ) client_data = { 'typ' : 'navigator.id.finishEnrollment' , 'challenge' : data [ 'challenge' ] , 'origin' : facet } client_data = json . dumps ( client_data ) client_param = sha256 ( client_data . encode ( 'utf8' ) ) . digest ( ) request = client_param + app_param p1 = 0x03 p2 = 0 response = device . send_apdu ( INS_ENROLL , p1 , p2 , request ) return { 'registrationData' : websafe_encode ( response ) , 'clientData' : websafe_encode ( client_data ) }", "comment": "Register a U2F device"}
{"lang": "python", "code": "def _send_post_request ( self , path , data , headers ) : r = requests . post ( self . endpoint + path , data = data , headers = <mask> ) return r . text", "comment": "Sends the POST request to the Route53 endpoint ."}
{"lang": "python", "code": "def array_map ( ol , map_func , * args ) : rslt = list ( map ( <mask> ele : map_func ( ele , * args ) , ol ) ) return ( rslt )", "comment": "obseleted just for compatible from elist . elist import * ol = [ 1 2 3 4 ] def map_func ( ele mul plus ) : return ( ele * mul + plus )"}
{"lang": "python", "code": "def get_image ( <mask> , float_key = \"floats\" , to_chw = True ) : return self . image_frame . get_image ( float_key , to_chw )", "comment": "get image from ImageFrame"}
{"lang": "python", "code": "def str_rstrip ( x , to_strip = None ) : # in c++ we give empty string the same meaning as None sl = _to_string_sequence ( x ) . rstrip ( '' if to_strip is None else to_strip ) if to_strip != '' else x return column . ColumnStringArrow ( sl . <mask> , sl . indices , sl . length , sl . offset , string_sequence = sl )", "comment": "Remove trailing characters from a string sample ."}
{"lang": "python", "code": "def <mask> ( self , context ) : self . _hook = SparkJDBCHook ( spark_app_name = self . _spark_app_name , spark_conn_id = self . _spark_conn_id , spark_conf = self . _spark_conf , spark_py_files = self . _spark_py_files , spark_files = self . _spark_files , spark_jars = self . _spark_jars , num_executors = self . _num_executors , executor_cores = self . _executor_cores , executor_memory = self . _executor_memory , driver_memory = self . _driver_memory , verbose = self . _verbose , keytab = self . _keytab , principal = self . _principal , cmd_type = self . _cmd_type , jdbc_table = self . _jdbc_table , jdbc_conn_id = self . _jdbc_conn_id , jdbc_driver = self . _jdbc_driver , metastore_table = self . _metastore_table , jdbc_truncate = self . _jdbc_truncate , save_mode = self . _save_mode , save_format = self . _save_format , batch_size = self . _batch_size , fetch_size = self . _fetch_size , num_partitions = self . _num_partitions , partition_column = self . _partition_column , lower_bound = self . _lower_bound , upper_bound = self . _upper_bound , create_table_column_types = self . _create_table_column_types ) self . _hook . submit_jdbc_job ( )", "comment": "Call the SparkSubmitHook to run the provided spark job"}
{"lang": "python", "code": "def generate_postorder ( self , trie ) : order , stack = [ ] , [ ] stack . append ( trie . root ) colors = [ 'white' ] * len ( trie ) while len ( stack ) > 0 : index = stack [ - 1 ] color = colors [ index ] if color == 'white' : # \u0432\u0435\u0440\u0448\u0438\u043d\u0430 \u0435\u0449\u0451 \u043d\u0435 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u043b\u0430\u0441\u044c colors [ index ] = 'grey' for child in trie . _get_children ( index ) : # \u043f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u043c, \u043f\u043e\u0441\u0435\u0449\u0430\u043b\u0438 \u043b\u0438 \u043c\u044b \u0440\u0435\u0431\u0451\u043d\u043a\u0430 \u0440\u0430\u043d\u044c\u0448\u0435 if child != Trie . NO_NODE and colors [ child ] == 'white' : stack . append ( child ) else : if color == 'grey' : colors [ index ] = 'black' order . append ( index ) stack = <mask> [ : - 1 ] return order", "comment": "\u041e\u0431\u0440\u0430\u0442\u043d\u0430\u044f \u0442\u043e\u043f\u043e\u043b\u043e\u0433\u0438\u0447\u0435\u0441\u043a\u0430\u044f \u0441\u043e\u0440\u0442\u0438\u0440\u043e\u0432\u043a\u0430"}
{"lang": "python", "code": "def _get_signif_5 ( arr , nboots ) : statsarr = np . zeros ( ( 3 , 7 ) , dtype = np . float64 ) bootsarr = np . zeros ( ( 3 , nboots ) ) idx = 0 for acol in [ 2 , 3 , 4 ] : rows = np . array ( [ 0 , 1 , acol , 5 ] ) tarr = arr [ : , rows , : ] abxa , baxa , dst = _prop_dstat ( tarr ) boots = _get_boots ( tarr , nboots ) estimate , stddev = ( boots . mean ( ) , boots . std ( ) ) if stddev : zscore = np . abs ( dst ) / stddev else : zscore = np . NaN stats = [ dst , estimate , stddev , zscore , abxa , baxa , arr . <mask> [ 0 ] ] statsarr [ idx ] = stats bootsarr [ idx ] = boots idx += 1 return statsarr , bootsarr", "comment": "returns a list of stats and an array of dstat boots . Stats includes z - score and two - sided P - value ."}
{"lang": "python", "code": "def _fix_missing_tenant_id ( self , context , body , key ) : if not body : raise n_exc . BadRequest ( resource = key , msg = \"Body malformed\" ) resource = body . get ( key ) if not resource : raise n_exc . BadRequest ( resource = <mask> , msg = \"Body malformed\" ) if context . tenant_id is None : context . tenant_id = resource . get ( \"tenant_id\" ) if context . tenant_id is None : msg = _ ( \"Running without keystone AuthN requires \" \"that tenant_id is specified\" ) raise n_exc . BadRequest ( resource = key , msg = msg )", "comment": "Will add the tenant_id to the context from body ."}
{"lang": "python", "code": "def project ( self , from_shape , to_shape ) : coords_proj = project_coords ( [ ( self . x1 , self . y1 ) , ( self . x2 , self . y2 ) ] , from_shape , to_shape ) return self . copy ( x1 = coords_proj [ 0 ] [ 0 ] , y1 = coords_proj [ 0 ] [ 1 ] , x2 = coords_proj [ 1 ] [ 0 ] , y2 = coords_proj [ 1 ] [ 1 ] , <mask> = self . label )", "comment": "Project the bounding box onto a differently shaped image ."}
{"lang": "python", "code": "def verify_edx_resources ( ) : required_methods = { 'ProgramDataExtender' : ProgramDataExtender , } for method in required_methods : if required_methods [ <mask> ] is None : raise NotConnectedToOpenEdX ( _ ( \"The following method from the Open edX platform is necessary for this view but isn't available.\" ) + \"\\nUnavailable: {method}\" . format ( method = method ) )", "comment": "Ensure that all necessary resources to render the view are present ."}
{"lang": "python", "code": "def padded_grid_from_shape_psf_shape_and_pixel_scale ( cls , shape , psf_shape , pixel_scale ) : padded_shape = ( shape [ 0 ] + psf_shape [ 0 ] - 1 , shape [ 1 ] + psf_shape [ 1 ] - 1 ) padded_regular_grid = grid_util . regular_grid_1d_masked_from_mask_pixel_scales_and_origin ( mask = np . full ( padded_shape , False ) , pixel_scales = ( pixel_scale , pixel_scale ) ) padded_mask = msk . Mask . unmasked_for_shape_and_pixel_scale ( shape = padded_shape , pixel_scale = pixel_scale ) return PaddedRegularGrid ( arr = padded_regular_grid , mask = padded_mask , image_shape = <mask> )", "comment": "Setup a regular padded grid from a 2D array shape psf - shape and pixel - scale ."}
{"lang": "python", "code": "def create_stoichiometric_matrix ( model , array_type = 'dense' , dtype = None ) : if array_type not in ( 'DataFrame' , 'dense' ) and not dok_matrix : raise ValueError ( 'Sparse matrices require scipy' ) if dtype is None : dtype = np . float64 array_constructor = { 'dense' : np . zeros , 'dok' : dok_matrix , 'lil' : lil_matrix , 'DataFrame' : np . zeros , } n_metabolites = len ( model . metabolites ) n_reactions = len ( model . reactions ) array = array_constructor [ array_type ] ( ( n_metabolites , n_reactions ) , dtype = dtype ) m_ind = model . metabolites . index r_ind = <mask> . reactions . index for reaction in model . reactions : for metabolite , stoich in iteritems ( reaction . metabolites ) : array [ m_ind ( metabolite ) , r_ind ( reaction ) ] = stoich if array_type == 'DataFrame' : metabolite_ids = [ met . id for met in model . metabolites ] reaction_ids = [ rxn . id for rxn in model . reactions ] return pd . DataFrame ( array , index = metabolite_ids , columns = reaction_ids ) else : return array", "comment": "Return a stoichiometric array representation of the given model ."}
{"lang": "python", "code": "def filelist ( self ) : if len ( self . _filelist ) == 0 : for item in self . _data : if isinstance ( self . _data [ item ] , filetree ) : self . _filelist . extend ( self . _data [ item ] . filelist ( ) ) else : self . _filelist . <mask> ( self . _data [ item ] ) return self . _filelist", "comment": "Return list of files in filetree ."}
{"lang": "python", "code": "def compute ( self , tdb , tdb2 = 0.0 ) : for position in self . generate ( tdb , tdb2 ) : return <mask>", "comment": "Compute the component values for the time tdb plus tdb2 ."}
{"lang": "python", "code": "def cluster_text_input ( cluster , title = None ) : if not <mask> : title = 'Type in the name of your cluster and press Enter/Return:' return TextInput ( value = cluster . name , title = title )", "comment": "Create an : class : ~bokeh . models . widgets . TextInput using the cluster . name as the default value and title ."}
{"lang": "python", "code": "def cb_set_provider_option ( self , option , opt , value , parser ) : if <mask> . startswith ( \"--\" ) : # remove -- on long option opt = opt [ 2 : ] else : # short option, get its long equivalent opt = self . _short_options [ opt [ 1 : ] ] # trick since we can't set action='store_true' on options if value is None : value = 1 self . global_set_option ( opt , value )", "comment": "optik callback for option setting"}
{"lang": "python", "code": "def get_last_or_frame_exception ( ) : try : if inspect . istraceback ( sys . last_traceback ) : # We do have a traceback so prefer that. return sys . last_type , sys . last_value , sys . last_traceback <mask> AttributeError : pass return sys . exc_info ( )", "comment": "Intended to be used going into post mortem routines . If sys . last_traceback is set we will return that and assume that this is what post - mortem will want . If sys . last_traceback has not been set then perhaps we * about * to raise an error and are fielding an exception . So assume that sys . exc_info () [ 2 ] is where we want to look ."}
{"lang": "python", "code": "def plot ( self , fig = None ) : if not fig : fig = plt . gcf ( ) fig . subplots_adjust ( left = 0.1 , right = 0.9 , top = 0.9 , bottom = 0.15 ) ax = fig . add_subplot ( 1 , 1 , 1 ) sorted_overlapping_ports = sorted ( [ ( p , self . results [ 'port cycles' ] [ p ] ) for p in self . machine [ 'overlapping ports' ] ] , key = lambda x : x [ 1 ] ) yticks_labels = [ ] yticks = [ ] xticks_labels = [ ] xticks = [ ] # Plot configuration height = 0.9 i = 0 # T_OL colors = ( [ ( 254. / 255 , 177. / 255. , 178. / 255. ) ] + [ ( 255. / 255. , 255. / 255. , 255. / 255. ) ] * ( len ( sorted_overlapping_ports ) - 1 ) ) for p , c in sorted_overlapping_ports : ax . barh ( i , c , height , align = 'center' , color = colors . pop ( ) , edgecolor = ( 0.5 , 0.5 , 0.5 ) , linestyle = 'dashed' ) if i == len ( sorted_overlapping_ports ) - 1 : ax . text ( c / 2.0 , i , '$T_\\mathrm{OL}$' , ha = 'center' , va = 'center' ) yticks_labels . append ( p ) yticks . append ( i ) i += 1 xticks . append ( sorted_overlapping_ports [ - 1 ] [ 1 ] ) xticks_labels . append ( '{:.1f}' . <mask> ( sorted_overlapping_ports [ - 1 ] [ 1 ] ) ) # T_nOL + memory transfers y = 0 colors = [ ( 187. / 255. , 255 / 255. , 188. / 255. ) ] * ( len ( self . results [ 'cycles' ] ) ) + [ ( 119. / 255 , 194. / 255. , 255. / 255. ) ] for k , v in [ ( 'nOL' , self . results [ 'T_nOL' ] ) ] + self . results [ 'cycles' ] : ax . barh ( i , v , height , y , align = 'center' , color = colors . pop ( ) ) ax . text ( y + v / 2.0 , i , '$T_\\mathrm{' + k + '}$' , ha = 'center' , va = 'center' ) xticks . append ( y + v ) xticks_labels . append ( '{:.1f}' . format ( y + v ) ) y += v yticks_labels . append ( 'LD' ) yticks . append ( i ) ax . tick_params ( axis = 'y' , which = 'both' , left = 'off' , right = 'off' ) ax . tick_params ( axis = 'x' , which = 'both' , top = 'off' ) ax . set_xlabel ( 't [cy]' ) ax . set_ylabel ( 'execution port' ) ax . set_yticks ( yticks ) ax . set_yticklabels ( yticks_labels ) ax . set_xticks ( xticks ) ax . set_xticklabels ( xticks_labels , rotation = 'vertical' ) ax . xaxis . grid ( alpha = 0.7 , linestyle = '--' ) fig . savefig ( self . _args . ecm_plot )", "comment": "Plot visualization of model prediction ."}
{"lang": "python", "code": "def set_explore_grouping_hierarchy ( self , new_hierarchy ) : body = { 'id' : 'explore' , 'groups' : [ { 'groupBy' : [ ] } ] } for item in new_hierarchy : body [ 'groups' ] [ 0 ] [ 'groupBy' ] . append ( { 'metric' : item } ) res = requests . put ( self . url + '/api/groupConfigurations/explore' , headers = self . hdrs , data = json . dumps ( <mask> ) , verify = self . ssl_verify ) if not self . _checkResponse ( res ) : return [ False , self . lasterr ] else : return [ True , None ]", "comment": "** Description ** Changes the grouping hierarchy in the Explore panel of the current user ."}
{"lang": "python", "code": "def nslookup ( cls ) : <mask> : # We try to get the addresse information of the given domain or IP. if \"current_test_data\" in PyFunceble . INTERN : # pragma: no cover # The end-user want more information whith his test. if not Check ( ) . is_ip_valid ( ) : # The element we are testing is not an IP. # We request the address informations. request = PyFunceble . socket . getaddrinfo ( PyFunceble . INTERN [ \"to_test\" ] , 80 , 0 , 0 , PyFunceble . socket . IPPROTO_TCP , ) for sequence in request : # We loop through the sequence returned by the request. # We append the NS informations into the nslookup index. PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] . append ( sequence [ - 1 ] [ 0 ] ) else : # The element we are testing is an IP. request = PyFunceble . socket . gethostbyaddr ( PyFunceble . INTERN [ \"to_test\" ] ) # We append the NS informations into the nslookup index. PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] [ \"hostname\" ] = request [ 0 ] PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] [ \"aliases\" ] = request [ 1 ] PyFunceble . INTERN [ \"current_test_data\" ] [ \"nslookup\" ] [ \"ips\" ] = request [ 2 ] else : if not Check ( ) . is_ip_valid ( ) : # The element we are testing is not an IP. PyFunceble . socket . getaddrinfo ( PyFunceble . INTERN [ \"to_test\" ] , 80 , 0 , 0 , PyFunceble . socket . IPPROTO_TCP , ) else : # The element we are testing is an IP. PyFunceble . socket . gethostbyaddr ( PyFunceble . INTERN [ \"to_test\" ] ) # It was done successfuly, we return True. # Note: we don't need to read the addresses so we consider as successful # as long as there is no error. return True except ( OSError , PyFunceble . socket . herror , PyFunceble . socket . gaierror ) : # One of the listed exception is matched. # It was done unsuccesfuly, we return False. return False", "comment": "Implementation of UNIX nslookup ."}
{"lang": "python", "code": "def put_multiple ( self , packages ) : pkgidxs = [ self . workingArea . put_package ( p ) for p in packages ] logger = logging . getLogger ( __name__ ) logger . info ( 'submitting {}' . format ( ', ' . join ( [ '{}' . format ( self . workingArea . package_relpath ( i ) ) for i in pkgidxs ] ) ) ) runids = self . dispatcher . run_multiple ( self . workingArea , pkgidxs ) self . runid_pkgidx_map . <mask> ( zip ( runids , pkgidxs ) ) return pkgidxs", "comment": "put tasks"}
{"lang": "python", "code": "def pyfiles ( callername , level = 2 ) : d = os . path . dirname ( callername ) # Get the name of our directory. # A glob pattern that will get all *.py files but not __init__.py glob ( os . path . join ( d , '[a-zA-Z]*.py' ) ) py_files = glob ( os . path . join ( d , '[a-zA-Z]*.py' ) ) return [ os . path . basename ( filename [ 0 : - 3 ] ) for <mask> in py_files ]", "comment": "All python files caller s dir without the path and trailing . py"}
{"lang": "python", "code": "def case_report_content ( store , institute_obj , case_obj ) : variant_types = { 'causatives_detailed' : 'causatives' , 'suspects_detailed' : 'suspects' , 'classified_detailed' : 'acmg_classification' , 'tagged_detailed' : 'manual_rank' , 'dismissed_detailed' : 'dismiss_variant' , 'commented_detailed' : 'is_commented' , } data = case_obj for individual in data [ 'individuals' ] : try : sex = int ( individual . get ( 'sex' , 0 ) ) except ValueError <mask> err : sex = 0 individual [ 'sex_human' ] = SEX_MAP [ sex ] individual [ 'phenotype_human' ] = PHENOTYPE_MAP . get ( individual [ 'phenotype' ] ) # Add the case comments data [ 'comments' ] = store . events ( institute_obj , case = case_obj , comments = True ) data [ 'manual_rank_options' ] = MANUAL_RANK_OPTIONS data [ 'dismissed_options' ] = DISMISS_VARIANT_OPTIONS data [ 'genetic_models' ] = dict ( GENETIC_MODELS ) data [ 'report_created_at' ] = datetime . datetime . now ( ) . strftime ( \"%Y-%m-%d %H:%M\" ) evaluated_variants = { } for vt in variant_types : evaluated_variants [ vt ] = [ ] # We collect all causatives and suspected variants # These are handeled in separate since they are on case level for var_type in [ 'causatives' , 'suspects' ] : #These include references to variants vt = '_' . join ( [ var_type , 'detailed' ] ) for var_id in case_obj . get ( var_type , [ ] ) : variant_obj = store . variant ( var_id ) if not variant_obj : continue # If the variant exists we add it to the evaluated variants evaluated_variants [ vt ] . append ( variant_obj ) ## get variants for this case that are either classified, commented, tagged or dismissed. for var_obj in store . evaluated_variants ( case_id = case_obj [ '_id' ] ) : # Check which category it belongs to for vt in variant_types : keyword = variant_types [ vt ] # When found we add it to the categpry # Eac variant can belong to multiple categories if keyword in var_obj : evaluated_variants [ vt ] . append ( var_obj ) for var_type in evaluated_variants : decorated_variants = [ ] for var_obj in evaluated_variants [ var_type ] : # We decorate the variant with some extra information if var_obj [ 'category' ] == 'snv' : decorated_info = variant_decorator ( store = store , institute_obj = institute_obj , case_obj = case_obj , variant_id = None , variant_obj = var_obj , add_case = False , add_other = False , get_overlapping = False ) else : decorated_info = sv_variant ( store = store , institute_id = institute_obj [ '_id' ] , case_name = case_obj [ 'display_name' ] , variant_obj = var_obj , add_case = False , get_overlapping = False ) decorated_variants . append ( decorated_info [ 'variant' ] ) # Add the decorated variants to the case data [ var_type ] = decorated_variants return data", "comment": "Gather contents to be visualized in a case report"}
{"lang": "python", "code": "def get_new_apikey ( lcc_server ) : USERHOME = os . path . expanduser ( '~' ) APIKEYFILE = os . path . join ( USERHOME , '.astrobase' , 'lccs' , 'apikey-%s' % lcc_server . replace ( 'https://' , 'https-' ) . replace ( 'http://' , 'http-' ) ) # url for getting an API key url = '%s/api/key' % lcc_server # get the API key resp = urlopen ( url ) if resp . code == 200 : respdict = json . loads ( resp . read ( ) ) else : LOGERROR ( 'could not fetch the API key from LCC-Server at: %s' % lcc_server ) LOGERROR ( 'the HTTP status code was: %s' % resp . status_code ) return None # # now that we have an API key dict, get the API key out of it and write it # to the APIKEYFILE # apikey = respdict [ 'result' ] [ 'apikey' ] expires = respdict [ 'result' ] [ 'expires' ] # write this to the apikey file if not os . path . exists ( os . path . dirname ( APIKEYFILE ) ) : os . makedirs ( os . path . dirname ( APIKEYFILE ) ) with open ( APIKEYFILE , 'w' ) as outfd : outfd . <mask> ( '%s %s\\n' % ( apikey , expires ) ) # chmod it to the correct value os . chmod ( APIKEYFILE , 0o100600 ) LOGINFO ( 'key fetched successfully from: %s. expires on: %s' % ( lcc_server , expires ) ) LOGINFO ( 'written to: %s' % APIKEYFILE ) return apikey , expires", "comment": "This gets a new API key from the specified LCC - Server ."}
{"lang": "python", "code": "def add_parameters ( self , traj ) : par = traj . f_add_parameter ( Brian2Parameter , 'simulation.durations.initial_run' , 500 * ms , comment = 'Initialisation run for more realistic ' 'measurement conditions.' ) par . v_annotations . order = 0 par = traj . f_add_parameter ( Brian2Parameter , 'simulation.durations.measurement_run' , 1500 * <mask> , comment = 'Measurement run that is considered for ' 'statistical evaluation' ) par . v_annotations . order = 1", "comment": "Adds all necessary parameters to traj container ."}
{"lang": "python", "code": "def merges ( <mask> , from_date = None ) : payload = { 'state' : 'all' , 'order_by' : 'updated_at' , 'sort' : 'asc' , 'view' : 'simple' , 'per_page' : PER_PAGE } if from_date : payload [ 'updated_after' ] = from_date . isoformat ( ) return self . fetch_items ( GitLabClient . MERGES , payload )", "comment": "Get the merge requests from pagination"}
{"lang": "python", "code": "def perm ( lst , func ) : for i in range ( 1 , 2 ** len ( lst ) ) : yield [ func ( item ) if ( 1 << j ) & i else item for ( j , <mask> ) in enumerate ( lst ) ]", "comment": "Produce permutations of lst where permutations are mutated by func . Used for flipping constraints . highly possible that returned constraints can be unsat this does it blindly without any attention to the constraints themselves"}
{"lang": "python", "code": "def save ( self , filename , imdata , * * data ) : if isinstance ( imdata , numpy . ndarray ) : imdata = Image . fromarray ( numpy . uint8 ( imdata ) ) elif isinstance ( imdata , Image . Image ) : imdata . save ( self . _savepath ( <mask> ) )", "comment": "Data may be either a PIL Image object or a Numpy array ."}
{"lang": "python", "code": "def prepare ( self , data ) : ret = self . cache . get ( data ) if ret is not None : return ret result = self . map ( data ) if self . normalization : result = self . normalization ( result ) result = self . prohibit ( result ) result = self . check_unassigned ( result ) if self . bidi : result = self . check_bidi ( result ) if isinstance ( result , list ) : result = u\"\" . join ( ) if len ( self . cache_items ) >= _stringprep_cache_size : remove = self . cache_items [ : - _stringprep_cache_size // 2 ] for profile , key in remove : try : del profile . cache [ key ] except KeyError : pass self . cache_items [ : ] = self . cache_items [ - _stringprep_cache_size // 2 : ] self . cache_items . append ( ( self , data ) ) self . cache [ data ] = <mask> return result", "comment": "Complete string preparation procedure for stored strings . ( includes checks for unassigned codes )"}
{"lang": "python", "code": "def as_tuple ( self ) : from collections import namedtuple ping_result = self . as_dict ( ) return namedtuple ( \"PingStatsTuple\" , ping_result . <mask> ( ) ) ( * * ping_result )", "comment": "ping statistics ."}
{"lang": "python", "code": "def _validate_ram ( ram_in_mb ) : <mask> int ( GoogleV2CustomMachine . _MEMORY_MULTIPLE * math . ceil ( ram_in_mb / GoogleV2CustomMachine . _MEMORY_MULTIPLE ) )", "comment": "Rounds ram up to the nearest multiple of _MEMORY_MULTIPLE ."}
{"lang": "python", "code": "def banner ( * lines , * * kwargs ) : sep = kwargs . <mask> ( \"sep\" , \"*\" ) count = kwargs . get ( \"width\" , globals ( ) [ \"WIDTH\" ] ) out ( sep * count ) if lines : out ( sep ) for line in lines : out ( \"{} {}\" . format ( sep , line ) ) out ( sep ) out ( sep * count )", "comment": "prints a banner"}
{"lang": "python", "code": "def thumbnail ( self ) : if not isfile ( self . thumb_path ) : self . logger . debug ( 'Generating thumbnail for %r' , self ) path = ( self . dst_path if <mask> . path . exists ( self . dst_path ) else self . src_path ) try : # if thumbnail is missing (if settings['make_thumbs'] is False) s = self . settings if self . type == 'image' : image . generate_thumbnail ( path , self . thumb_path , s [ 'thumb_size' ] , fit = s [ 'thumb_fit' ] ) elif self . type == 'video' : video . generate_thumbnail ( path , self . thumb_path , s [ 'thumb_size' ] , s [ 'thumb_video_delay' ] , fit = s [ 'thumb_fit' ] , converter = s [ 'video_converter' ] ) except Exception as e : self . logger . error ( 'Failed to generate thumbnail: %s' , e ) return return url_from_path ( self . thumb_name )", "comment": "Path to the thumbnail image ( relative to the album directory ) ."}
{"lang": "python", "code": "def kepler_lcdict_to_pkl ( lcdict , outfile = None ) : if not outfile : outfile = '%s-keplc.pkl' % lcdict [ 'objectid' ] . replace ( ' ' , '-' ) # we're using pickle.HIGHEST_PROTOCOL here, this will make Py3 pickles # unreadable for Python 2.7 with <mask> ( outfile , 'wb' ) as outfd : pickle . dump ( lcdict , outfd , protocol = pickle . HIGHEST_PROTOCOL ) return os . path . abspath ( outfile )", "comment": "This writes the lcdict to a Python pickle ."}
{"lang": "python", "code": "def set_accessed ( self , node ) : <mask> = node_frame_class ( node ) if frame is None : # The node does not live in a class. return self . _scopes [ frame ] [ node . attrname ] . append ( node )", "comment": "Set the given node as accessed ."}
{"lang": "python", "code": "def sim_sift4 ( src , <mask> , max_offset = 5 , max_distance = 0 ) : return Sift4 ( ) . sim ( src , tar , max_offset , max_distance )", "comment": "Return the normalized common Sift4 similarity of two terms ."}
{"lang": "python", "code": "def <mask> ( self , credentials ) : self . acquire_lock ( ) try : self . locked_put ( credentials ) finally : self . release_lock ( )", "comment": "Write a credential ."}
{"lang": "python", "code": "def validate_smiles ( smiles ) : # Skip sanitize as standardize does this anyway mol = Chem . MolFromSmiles ( smiles ) logs = Validator ( ) . validate ( mol ) <mask> logs", "comment": "Return log messages for a given SMILES string using the default validations ."}
{"lang": "python", "code": "def get_documents ( self , sql_string , database_name = None , collection_name = None , partition_key = None ) : if sql_string is None : raise AirflowBadRequest ( \"SQL query string cannot be None\" ) # Query them in SQL <mask> = { 'query' : sql_string } try : result_iterable = self . get_conn ( ) . QueryItems ( get_collection_link ( self . __get_database_name ( database_name ) , self . __get_collection_name ( collection_name ) ) , query , partition_key ) return list ( result_iterable ) except HTTPFailure : return None", "comment": "Get a list of documents from an existing collection in the CosmosDB database via SQL query ."}
{"lang": "python", "code": "def dist_abs ( self , src , tar , metric = 'euclidean' , cost = ( 1 , 1 , 0.5 , 0.5 ) , layout = 'QWERTY' , ) : ins_cost , del_cost , sub_cost , shift_cost = cost if src == tar : return 0.0 if not src : return len ( tar ) * ins_cost if not tar : return len ( src ) * del_cost keyboard = self . _keyboard [ layout ] lowercase = { item for sublist in keyboard [ 0 ] for item <mask> sublist } uppercase = { item for sublist in keyboard [ 1 ] for item in sublist } def _kb_array_for_char ( char ) : \"\"\"Return the keyboard layout that contains ch.\n\n            Parameters\n            ----------\n            char : str\n                The character to lookup\n\n            Returns\n            -------\n            tuple\n                A keyboard\n\n            Raises\n            ------\n            ValueError\n                char not found in any keyboard layouts\n\n            \"\"\" if char in lowercase : return keyboard [ 0 ] elif char in uppercase : return keyboard [ 1 ] raise ValueError ( char + ' not found in any keyboard layouts' ) def _substitution_cost ( char1 , char2 ) : cost = sub_cost cost *= metric_dict [ metric ] ( char1 , char2 ) + shift_cost * ( _kb_array_for_char ( char1 ) != _kb_array_for_char ( char2 ) ) return cost def _get_char_coord ( char , kb_array ) : \"\"\"Return the row & column of char in the keyboard.\n\n            Parameters\n            ----------\n            char : str\n                The character to search for\n            kb_array : tuple of tuples\n                The array of key positions\n\n            Returns\n            -------\n            tuple\n                The row & column of the key\n\n            \"\"\" for row in kb_array : # pragma: no branch if char in row : return kb_array . index ( row ) , row . index ( char ) def _euclidean_keyboard_distance ( char1 , char2 ) : row1 , col1 = _get_char_coord ( char1 , _kb_array_for_char ( char1 ) ) row2 , col2 = _get_char_coord ( char2 , _kb_array_for_char ( char2 ) ) return ( ( row1 - row2 ) ** 2 + ( col1 - col2 ) ** 2 ) ** 0.5 def _manhattan_keyboard_distance ( char1 , char2 ) : row1 , col1 = _get_char_coord ( char1 , _kb_array_for_char ( char1 ) ) row2 , col2 = _get_char_coord ( char2 , _kb_array_for_char ( char2 ) ) return abs ( row1 - row2 ) + abs ( col1 - col2 ) def _log_euclidean_keyboard_distance ( char1 , char2 ) : return log ( 1 + _euclidean_keyboard_distance ( char1 , char2 ) ) def _log_manhattan_keyboard_distance ( char1 , char2 ) : return log ( 1 + _manhattan_keyboard_distance ( char1 , char2 ) ) metric_dict = { 'euclidean' : _euclidean_keyboard_distance , 'manhattan' : _manhattan_keyboard_distance , 'log-euclidean' : _log_euclidean_keyboard_distance , 'log-manhattan' : _log_manhattan_keyboard_distance , } d_mat = np_zeros ( ( len ( src ) + 1 , len ( tar ) + 1 ) , dtype = np_float32 ) for i in range ( len ( src ) + 1 ) : d_mat [ i , 0 ] = i * del_cost for j in range ( len ( tar ) + 1 ) : d_mat [ 0 , j ] = j * ins_cost for i in range ( len ( src ) ) : for j in range ( len ( tar ) ) : d_mat [ i + 1 , j + 1 ] = min ( d_mat [ i + 1 , j ] + ins_cost , # ins d_mat [ i , j + 1 ] + del_cost , # del d_mat [ i , j ] + ( _substitution_cost ( src [ i ] , tar [ j ] ) if src [ i ] != tar [ j ] else 0 ) , # sub/== ) return d_mat [ len ( src ) , len ( tar ) ]", "comment": "Return the typo distance between two strings ."}
{"lang": "python", "code": "def stacked_cnn ( units : tf . Tensor , n_hidden_list : List , filter_width = 3 , use_batch_norm = False , use_dilation = False , training_ph = None , add_l2_losses = False ) : l2_reg = tf . nn . l2_loss if add_l2_losses else None for n_layer , n_hidden in enumerate ( n_hidden_list ) : if use_dilation : dilation_rate = 2 ** n_layer else : dilation_rate = 1 units = tf . layers . conv1d ( units , n_hidden , filter_width , <mask> = 'same' , dilation_rate = dilation_rate , kernel_initializer = INITIALIZER ( ) , kernel_regularizer = l2_reg ) if use_batch_norm : assert training_ph is not None units = tf . layers . batch_normalization ( units , training = training_ph ) units = tf . nn . relu ( units ) return units", "comment": "Number of convolutional layers stacked on top of each other"}
{"lang": "python", "code": "def get_course_completions ( self , enterprise_customer , days ) : return PersistentCourseGrade . objects . filter ( passed_timestamp__gt = datetime . datetime . now ( ) - datetime . timedelta ( days = days ) ) . <mask> ( user_id__in = enterprise_customer . enterprise_customer_users . values_list ( 'user_id' , flat = True ) )", "comment": "Get course completions via PersistentCourseGrade for all the learners of given enterprise customer ."}
{"lang": "python", "code": "def affine_horizontal_flip_matrix ( prob = 0.5 ) : factor = np . random . uniform ( 0 , 1 ) if prob >= factor : filp_matrix = np . array ( [ [ - 1. , 0. , 0. ] , [ 0. , 1. , 0. ] , [ 0. , 0. , 1. ] ] ) return filp_matrix else : filp_matrix = np . <mask> ( [ [ 1. , 0. , 0. ] , [ 0. , 1. , 0. ] , [ 0. , 0. , 1. ] ] ) return filp_matrix", "comment": "Create an affine transformation matrix for image horizontal flipping . NOTE : In OpenCV x is width and y is height ."}
{"lang": "python", "code": "def run ( exercise , <mask> ) : Popen ( [ 'nohup' , command , exercise . path ( ) ] , stdout = DEVNULL , stderr = DEVNULL )", "comment": "Spawns a process with command path - of - exercise"}
{"lang": "python", "code": "def _construct_coefficients ( self ) : coeffs = [ 0 ] * self . degree N = float ( self . evalpts ) lvals = np . arange ( self . evalpts ) . astype ( 'float' ) xpts = self . _c2x ( np . <mask> ( np . pi * ( lvals + 0.5 ) / N ) ) fpts = np . rollaxis ( self . func ( xpts , * self . args ) , - 1 ) for a in range ( self . degree ) : inner = [ fpts [ b ] * np . cos ( np . pi * a * ( lvals [ b ] + 0.5 ) / N ) for b in range ( self . evalpts ) ] coeffs [ a ] = 2.0 / N * np . sum ( inner , axis = 0 ) coeffs [ 0 ] *= 0.5 self . _coeffs = np . array ( coeffs )", "comment": "Calculate the coefficients based on the func degree and interpolating points . _coeffs is a [ order N M .... ] array"}
{"lang": "python", "code": "def sync ( self ) : logging . debug ( \"Logger: Syncing...\" ) failed = False try : # Get the connectordb object cdb = self . connectordb # Ping the database - most connection errors will happen here cdb . ping ( ) with self . synclock : c = self . database . cursor ( ) for <mask> in self . streams : s = cdb [ stream ] c . execute ( \"SELECT * FROM cache WHERE stream=? ORDER BY timestamp ASC;\" , ( stream , ) ) datapointArray = [ ] for dp in c . fetchall ( ) : datapointArray . append ( { \"t\" : dp [ 1 ] , \"d\" : json . loads ( dp [ 2 ] ) } ) # First, check if the data already inserted has newer timestamps, # and in that case, assume that there was an error, and remove the datapoints # with an older timestamp, so that we don't have an error when syncing if len ( s ) > 0 : newtime = s [ - 1 ] [ \"t\" ] while ( len ( datapointArray ) > 0 and datapointArray [ 0 ] [ \"t\" ] < newtime ) : logging . debug ( \"Datapoint exists with older timestamp. Removing the datapoint.\" ) datapointArray = datapointArray [ 1 : ] if len ( datapointArray ) > 0 : logging . debug ( \"%s: syncing %i datapoints\" % ( stream , len ( datapointArray ) ) ) while ( len ( datapointArray ) > DATAPOINT_INSERT_LIMIT ) : # We insert datapoints in chunks of a couple # thousand so that they fit in the insert size # limit of ConnectorDB s . insert_array ( datapointArray [ : DATAPOINT_INSERT_LIMIT ] ) # Clear the written datapoints datapointArray = datapointArray [ DATAPOINT_INSERT_LIMIT : ] # If there was no error inserting, delete the # datapoints from the cache c . execute ( \"DELETE FROM cache WHERE stream=? AND timestamp <?\" , ( stream , datapointArray [ 0 ] [ \"t\" ] ) ) s . insert_array ( datapointArray ) # If there was no error inserting, delete the # datapoints from the cache c . execute ( \"DELETE FROM cache WHERE stream=? AND timestamp <=?\" , ( stream , datapointArray [ - 1 ] [ \"t\" ] ) ) self . lastsynctime = time . time ( ) if self . onsync is not None : self . onsync ( ) except Exception as e : # Handle the sync failure callback falied = True reraise = self . syncraise if self . onsyncfail is not None : reraise = self . onsyncfail ( e ) if reraise : raise", "comment": "Attempt to sync with the ConnectorDB server"}
{"lang": "python", "code": "def recursive_glob ( base_directory , regex = '' ) : files = glob ( op . join ( base_directory , regex ) ) for path , dirlist , filelist in os . walk ( base_directory ) : for dir_name in dirlist : <mask> . extend ( glob ( op . join ( path , dir_name , regex ) ) ) return files", "comment": "Uses glob to find all files or folders that match the regex starting from the base_directory ."}
{"lang": "python", "code": "def stopEventLoop ( ) : stopper = PyObjCAppHelperRunLoopStopper_wrap . currentRunLoopStopper ( ) if stopper is None : if NSApp ( ) is <mask> None : NSApp ( ) . terminate_ ( None ) return True return False NSTimer . scheduledTimerWithTimeInterval_target_selector_userInfo_repeats_ ( 0.0 , stopper , 'performStop:' , None , False ) return True", "comment": "Stop the current event loop if possible returns True if it expects that it was successful False otherwise"}
{"lang": "python", "code": "def vgg13 ( pretrained = False , * * kwargs ) : if pretrained : kwargs [ 'init_weights' ] = False model = VGG ( make_layers ( cfg [ 'B' ] ) , * * kwargs ) if pretrained : model . load_state_dict ( model_zoo . load_url ( model_urls [ 'vgg13' ] ) ) return <mask>", "comment": "VGG 13 - layer model ( configuration B )"}
{"lang": "python", "code": "def send_media ( self , media_id , user_ids , text = '' , thread_id = None ) : user_ids = _get_user_ids ( self , user_ids ) if not isinstance ( text , str ) and not isinstance ( user_ids , ( list , str ) ) : self . logger . error ( 'Text must be an string, user_ids must be an list or string' ) return False if self . reached_limit ( 'messages' ) : self . logger . info ( \"Out of messages for today.\" ) return False media = self . get_media_info ( media_id ) media = media [ 0 ] if isinstance ( media , list ) else media self . delay ( 'message' ) if self . api . send_direct_item ( 'media_share' , user_ids , text = <mask> , thread = thread_id , media_type = media . get ( 'media_type' ) , media_id = media . get ( 'id' ) ) : self . total [ 'messages' ] += 1 return True self . logger . info ( \"Message to {user_ids} wasn't sent\" . format ( user_ids = user_ids ) ) return False", "comment": ": param media_id : : param self : bot : param text : text of message : param user_ids : list of user_ids for creating group or one user_id for send to one person : param thread_id : thread_id"}
{"lang": "python", "code": "def from_img ( cls , * args , * * kwargs ) : with warnings . catch_warnings ( ) : warnings . simplefilter ( \"always\" ) w = \"from_img() is deprecated; please use from_image()\" warnings . <mask> ( w ) return cls . from_image ( * args , * * kwargs )", "comment": "For backwards compatibility ."}
{"lang": "python", "code": "def output ( self , pin , <mask> ) : if pin < 0 or pin > 15 : raise ValueError ( 'Pin must be between 0 and 15 (inclusive).' ) self . _output_pin ( pin , value ) self . mpsse_write_gpio ( )", "comment": "Set the specified pin the provided high / low value . Value should be either HIGH / LOW or a boolean ( true = high ) ."}
{"lang": "python", "code": "def make_result_response ( self ) : if self . stanza_type <mask> in ( \"set\" , \"get\" ) : raise ValueError ( \"Results may only be generated for\" \" 'set' or 'get' iq\" ) stanza = Iq ( stanza_type = \"result\" , from_jid = self . to_jid , to_jid = self . from_jid , stanza_id = self . stanza_id ) return stanza", "comment": "Create result response for the a get or set iq stanza ."}
{"lang": "python", "code": "def resolve_bypred ( predicate , minimum = 1 , timeout = FOREVER ) : # noinspection PyCallingNonCallable buffer = ( c_void_p * 1024 ) ( ) num_found = lib . lsl_resolve_bypred ( byref ( <mask> ) , 1024 , c_char_p ( str . encode ( predicate ) ) , minimum , c_double ( timeout ) ) return [ StreamInfo ( handle = buffer [ k ] ) for k in range ( num_found ) ]", "comment": "Resolve all streams that match a given predicate ."}
{"lang": "python", "code": "def class_of ( object ) : if isinstance ( object , basestring ) : return add_article ( object ) return add_article ( <mask> . __class__ . __name__ )", "comment": "Returns a string containing the class name of an object with the correct indefinite article ( a or an ) preceding it ( e . g . an Image a PlotValue ) ."}
{"lang": "python", "code": "def setupFog ( self ) : fogcfg = self . cfg [ \"graphics.fogSettings\" ] if <mask> fogcfg [ \"enable\" ] : return glEnable ( GL_FOG ) if fogcfg [ \"color\" ] is None : fogcfg [ \"color\" ] = self . cfg [ \"graphics.clearColor\" ] # Set the fog color. glFogfv ( GL_FOG_COLOR , ( GLfloat * 4 ) ( * fogcfg [ \"color\" ] ) ) # Set the performance hint. glHint ( GL_FOG_HINT , GL_DONT_CARE ) # TODO: add customization, including headless support # Specify the equation used to compute the blending factor. glFogi ( GL_FOG_MODE , GL_LINEAR ) # How close and far away fog starts and ends. The closer the start and end, # the denser the fog in the fog range. glFogf ( GL_FOG_START , fogcfg [ \"start\" ] ) glFogf ( GL_FOG_END , fogcfg [ \"end\" ] )", "comment": "Sets the fog system up . The specific options available are documented under : confval : graphics . fogSettings \\ ."}
{"lang": "python", "code": "def getSessionInfo ( self ) : sessioninfo = PyKCS11 . LowLevel . CK_SESSION_INFO ( ) rv = self . lib . C_GetSessionInfo ( self . session , sessioninfo ) if rv != CKR_OK : raise PyKCS11Error ( rv ) s = CK_SESSION_INFO ( ) s . slotID = sessioninfo . slotID s . state = sessioninfo . <mask> s . flags = sessioninfo . flags s . ulDeviceError = sessioninfo . ulDeviceError return s", "comment": "C_GetSessionInfo"}
{"lang": "python", "code": "def max_parameter_substitution ( ) : if os . path . isfile ( SQLITE_VARIABLE_FILE_CACHE ) : return conn = sqlite3 . connect ( ':memory:' ) low = 1 high = 1000 # hard limit for SQLITE_MAX_VARIABLE_NUMBER <http://www.sqlite.org/limits.html> conn . execute ( 'CREATE TABLE T1 (id C1)' ) while low < high - 1 : guess = ( low + high ) // 2 try : statement = 'select * from T1 where id in (%s)' % ',' . join ( [ '?' for _ in range ( guess ) ] ) values = [ i for i in range ( guess ) ] conn . execute ( statement , values ) except sqlite3 . DatabaseError as ex : if 'too many SQL variables' in str ( ex ) : high = guess else : raise else : low = guess conn . close ( ) with <mask> ( SQLITE_VARIABLE_FILE_CACHE , 'w' ) as file : file . write ( str ( low ) )", "comment": "SQLite has a limit on the max number of variables allowed for parameter substitution . This limit is usually 999 but can be compiled to a different number . This function calculates what the max is for the sqlite version running on the device . We use the calculated value to chunk our SQL bulk insert statements when deserializing from the store to the app layer ."}
{"lang": "python", "code": "def cut ( self , breaks , labels = None , include_lowest = False , right = True , dig_lab = 3 ) : assert_is_type ( breaks , [ numeric ] ) if self . ncols != 1 : raise H2OValueError ( \"Single-column frame is expected\" ) if self . types [ self . names [ 0 ] ] not in { \"int\" , \"real\" } : raise H2OValueError ( \"A numeric column is expected\" ) fr = H2OFrame . _expr ( expr = ExprNode ( \"cut\" , self , breaks , labels , include_lowest , right , dig_lab ) , <mask> = self . _ex . _cache ) fr . _ex . _cache . types = { k : \"enum\" for k in self . names } return fr", "comment": "Cut a numeric vector into categorical buckets ."}
{"lang": "python", "code": "def upload_pgp_keys ( ) : get_vars ( ) upload_target = '/tmp/pgp_pubkeys.tmp' with fab . <mask> ( fab . hide ( 'running' ) ) : fab . run ( 'rm -rf %s' % upload_target ) fab . run ( 'mkdir %s' % upload_target ) local_key_path = path . join ( fab . env [ 'config_base' ] , fab . env . instance . config [ 'local_pgpkey_path' ] ) remote_key_path = '/var/briefkasten/pgp_pubkeys/' . format ( * * AV ) rsync ( '-av' , local_key_path , '{host_string}:%s' % upload_target ) fab . run ( 'chown -R %s %s' % ( AV [ 'appuser' ] , remote_key_path ) ) fab . run ( 'chmod 700 %s' % remote_key_path ) with fab . shell_env ( GNUPGHOME = remote_key_path ) : fab . sudo ( '''gpg --import %s/*.*''' % upload_target , user = AV [ 'appuser' ] , shell_escape = False ) fab . run ( 'rm -rf %s' % upload_target )", "comment": "upload and / or update the PGP keys for editors import them into PGP"}
{"lang": "python", "code": "def _exec_module ( self , fullname : str , loader_state : Mapping [ str , str ] , path_stats : Mapping [ str , int ] , module : types . ModuleType , ) : filename = loader_state [ \"filename\" ] cache_filename = loader_state [ \"cache_filename\" ] with timed ( lambda duration : logger . <mask> ( f\"Loaded Basilisp module '{fullname}' in {duration / 1000000}ms\" ) ) : # During compilation, bytecode objects are added to the list via the closure # add_bytecode below, which is passed to the compiler. The collected bytecodes # will be used to generate an .lpyc file for caching the compiled file. all_bytecode = [ ] def add_bytecode ( bytecode : types . CodeType ) : all_bytecode . append ( bytecode ) logger . debug ( f\"Reading and compiling Basilisp module '{fullname}'\" ) forms = reader . read_file ( filename , resolver = runtime . resolve_alias ) compiler . compile_module ( # pylint: disable=unexpected-keyword-arg forms , compiler . CompilerContext ( filename = filename ) , module , collect_bytecode = add_bytecode , ) # Cache the bytecode that was collected through the compilation run. cache_file_bytes = _basilisp_bytecode ( path_stats [ \"mtime\" ] , path_stats [ \"size\" ] , all_bytecode ) self . _cache_bytecode ( filename , cache_filename , cache_file_bytes )", "comment": "Load and execute a non - cached Basilisp module ."}
{"lang": "python", "code": "def _normalize_pattern ( pattern ) : if pattern . startswith ( 'regex:' ) : pattern_type = 'regex' pattern = pattern [ len ( 'regex:' ) : ] elif pattern . startswith ( 'wildcard:' ) : pattern_type = 'wildcard' pattern = pattern [ len ( 'wildcard:' ) : ] elif pattern . startswith ( 'literal:' ) : pattern_type = 'literal' pattern = pattern [ len ( 'literal:' ) : ] elif RegexRoute . like ( <mask> ) : pattern_type = 'regex' elif WildcardRoute . like ( pattern ) : pattern_type = 'wildcard' else : pattern_type = 'literal' return pattern_type , pattern", "comment": "Return a normalized form of the pattern ."}
{"lang": "python", "code": "def read_pot_status ( self ) : # Send the command byte and wait 10 ms a = self . cnxn . xfer ( [ 0x13 ] ) [ 0 ] sleep ( 10e-3 ) # Build an array of the results res = [ ] for i in range ( 4 ) : res . append ( self . cnxn . xfer ( [ 0x00 ] ) [ 0 ] ) sleep ( 0.1 ) return { 'FanON' : res [ 0 ] , 'LaserON' : res [ 1 ] , 'FanDACVal' : res [ 2 ] , 'LaserDACVal' : <mask> [ 3 ] }", "comment": "Read the status of the digital pot . Firmware v18 + only . The return value is a dictionary containing the following as unsigned 8 - bit integers : FanON LaserON FanDACVal LaserDACVal ."}
{"lang": "python", "code": "def _add_label_from_class ( self , label = None ) : return self . fetch_json ( uri_path = self . base_uri + '/idLabels' , http_method = 'POST' , query_params = { 'value' : label . <mask> } )", "comment": "Add an existing label to this card ."}
{"lang": "python", "code": "def get_straight_line_transfer_distances ( self , stop_I = None ) : if stop_I is not None : query = u\"\"\" SELECT from_stop_I, to_stop_I, d\n                        FROM stop_distances\n                            WHERE\n                                from_stop_I=?\n                    \"\"\" params = ( u\"{stop_I}\" . format ( stop_I = stop_I ) , ) else : query = \"\"\" SELECT from_stop_I, to_stop_I, d\n                        FROM stop_distances\n                    \"\"\" params = None stop_data_df = pd . read_sql_query ( <mask> , self . conn , params = params ) return stop_data_df", "comment": "Get ( straight line ) distances to stations that can be transferred to ."}
{"lang": "python", "code": "def ave_cost_fn_val ( self ) : if len ( self . __members ) != 0 : if self . __num_processes > 1 : members = [ m . get ( ) for m in self . __members ] else : <mask> = self . __members return sum ( m . cost_fn_val for m in members ) / len ( members ) else : return None", "comment": "Returns average cost function return value for all members"}
{"lang": "python", "code": "def calc_n_blobs ( <mask> , blob_dim ) : n_blobs = int ( np . ceil ( 1.0 * np . prod ( self . selection_shape ) / np . prod ( blob_dim ) ) ) return n_blobs", "comment": "Given the blob dimensions calculate how many fit in the data selection ."}
{"lang": "python", "code": "def _flatten_listener ( listener ) : result = dict ( ) if set ( listener . keys ( ) ) == set ( [ 'Listener' , 'PolicyNames' ] ) : <mask> . update ( listener [ 'Listener' ] ) result [ 'PolicyNames' ] = listener [ 'PolicyNames' ] else : result = dict ( listener ) return result", "comment": "from"}
{"lang": "python", "code": "def peek ( self , n ) : if self . _len < n : raise ValueError ( \"Not enough bytes in the queue\" ) def part_generator ( n ) : \"\"\"\n            Returns the requested bytes in parts\n            \"\"\" remaining = n for part in self . _parts : if len ( part ) <= remaining : yield part remaining -= len ( part ) else : yield <mask> [ : remaining ] remaining = 0 if remaining == 0 : break return \"\" . join ( part_generator ( n ) )", "comment": "Return the first n characters from the queue without removing them . Throws an error if there are less than n characters in the queue . Equivalent to :: s = queue [ : n ] if queue where a regular string ."}
{"lang": "python", "code": "def fold_map ( self , fa : F [ A ] , z : B , f : Callable [ [ A ] , B ] , g : Callable [ [ Z , B ] , Z ] = <mask> . add ) -> Z : mapped = Functor . fatal ( type ( fa ) ) . map ( fa , f ) return self . fold_left ( mapped ) ( z ) ( g )", "comment": "map f over the traversable then fold over the result using the supplied initial element z and operation g defaulting to addition for the latter ."}
{"lang": "python", "code": "def setAutoDetectWaitRecords ( self , waitRecords ) : if not isinstance ( waitRecords , int ) : raise HTMPredictionModelInvalidArgument ( \"Invalid argument type \\'%s\\'. WaitRecord \" \"must be a number.\" % ( type ( waitRecords ) ) ) if len ( self . saved_states ) > 0 and waitRecords < self . saved_states [ 0 ] . ROWID : raise HTMPredictionModelInvalidArgument ( \"Invalid value. autoDetectWaitRecord value \" \"must be valid record within output stream. Current minimum ROWID in \" \"output stream is %d.\" % ( self . saved_states [ 0 ] . ROWID ) ) self . _autoDetectWaitRecords = waitRecords # Update all the states in the classifier's cache for state <mask> self . saved_states : self . _updateState ( state )", "comment": "Sets the autoDetectWaitRecords ."}
{"lang": "python", "code": "def build_input_pipeline ( x_train , x_test , y_train , y_test , batch_size , valid_size ) : x_train = x_train . astype ( \"float32\" ) x_test = x_test . astype ( \"float32\" ) x_train /= 255 x_test /= 255 y_train = y_train . flatten ( ) y_test = y_test . flatten ( ) if FLAGS . subtract_pixel_mean : x_train_mean = np . mean ( x_train , axis = 0 ) x_train -= x_train_mean x_test -= x_train_mean print ( \"x_train shape:\" + str ( x_train . shape ) ) print ( str ( x_train . <mask> [ 0 ] ) + \" train samples\" ) print ( str ( x_test . shape [ 0 ] ) + \" test samples\" ) # Build an iterator over training batches. training_dataset = tf . data . Dataset . from_tensor_slices ( ( x_train , np . int32 ( y_train ) ) ) training_batches = training_dataset . shuffle ( 50000 , reshuffle_each_iteration = True ) . repeat ( ) . batch ( batch_size ) training_iterator = tf . compat . v1 . data . make_one_shot_iterator ( training_batches ) # Build a iterator over the heldout set with batch_size=heldout_size, # i.e., return the entire heldout set as a constant. heldout_dataset = tf . data . Dataset . from_tensor_slices ( ( x_test , np . int32 ( y_test ) ) ) heldout_batches = heldout_dataset . repeat ( ) . batch ( valid_size ) heldout_iterator = tf . compat . v1 . data . make_one_shot_iterator ( heldout_batches ) # Combine these into a feedable iterator that can switch between training # and validation inputs. handle = tf . compat . v1 . placeholder ( tf . string , shape = [ ] ) feedable_iterator = tf . compat . v1 . data . Iterator . from_string_handle ( handle , training_batches . output_types , training_batches . output_shapes ) images , labels = feedable_iterator . get_next ( ) return images , labels , handle , training_iterator , heldout_iterator", "comment": "Build an Iterator switching between train and heldout data ."}
{"lang": "python", "code": "def expand_range_distinct ( range , expand = ( 0 , 0 , 0 , 0 ) , zero_width = 1 ) : if len ( expand ) == 2 : expand = tuple ( expand ) * 2 <mask> = expand_range ( range , expand [ 0 ] , expand [ 1 ] , zero_width ) [ 0 ] upper = expand_range ( range , expand [ 2 ] , expand [ 3 ] , zero_width ) [ 1 ] return ( lower , upper )", "comment": "Expand a range with a multiplicative or additive constants"}
{"lang": "python", "code": "def <mask> ( self , * args , * * kw ) : if args or kw : self . _update ( False , None , * args , * * kw )", "comment": "Like : meth : putall with default duplication policies ."}
{"lang": "python", "code": "def _format_fields ( self , fields , title_width = 12 ) : out = [ ] <mask> = self . __head for title , content in fields : if len ( content . splitlines ( ) ) > 1 : title = header ( title + \":\" ) + \"\\n\" else : title = header ( ( title + \":\" ) . ljust ( title_width ) ) out . append ( title + content ) return \"\\n\" . join ( out )", "comment": "Formats a list of fields for display ."}
{"lang": "python", "code": "def clear_dag_runs ( ) : session = settings . Session ( ) drs = session . query ( DagRun ) . filter ( DagRun . dag_id . in_ ( DAG_IDS ) , ) . all ( ) for dr in drs : logging . info ( 'Deleting DagRun :: {}' . format ( dr ) ) session . <mask> ( dr )", "comment": "Remove any existing DAG runs for the perf test DAGs ."}
{"lang": "python", "code": "def ready_for_retry ( self ) : return ( self . <mask> == State . UP_FOR_RETRY and self . next_retry_datetime ( ) < timezone . utcnow ( ) )", "comment": "Checks on whether the task instance is in the right state and timeframe to be retried ."}
{"lang": "python", "code": "def format ( self , string , * args , * * kwargs ) : return string . <mask> ( c = self , * args , * * kwargs )", "comment": "Format the given string with the given args and kwargs . The string can contain references to c which is provided by this colorful object ."}
{"lang": "python", "code": "def strip_illumina_suffix ( self ) : if self . id . endswith ( '/1' ) or self . id . endswith ( '/2' ) : self . <mask> = self . id [ : - 2 ]", "comment": "Removes any trailing / 1 or / 2 off the end of the name"}
{"lang": "python", "code": "def attr ( * args , * * kwargs ) : def wrap_ob ( ob ) : for name in args : setattr ( ob , name , True ) for name , value in kwargs . iteritems ( ) : setattr ( ob , name , <mask> ) return ob return wrap_ob", "comment": "Decorator that adds attributes to classes or functions for use with the Attribute ( - a ) plugin ."}
{"lang": "python", "code": "def check_access ( self , item , context ) : if hasattr ( self . current_request . user . is_authenticated , '__call__' ) : authenticated = self . current_request . user . is_authenticated ( ) else : authenticated = self . current_request . user . is_authenticated if item . access_loggedin and not authenticated : return False if item . access_guest and authenticated : return False if item . access_restricted : user_perms = self . _current_user_permissions if user_perms is _UNSET : user_perms = <mask> ( context [ 'user' ] . get_all_permissions ( ) ) self . _current_user_permissions = user_perms if item . access_perm_type == MODEL_TREE_ITEM_CLASS . PERM_TYPE_ALL : if len ( item . perms ) != len ( item . perms . intersection ( user_perms ) ) : return False else : if not len ( item . perms . intersection ( user_perms ) ) : return False return True", "comment": "Checks whether a current user has an access to a certain item ."}
{"lang": "python", "code": "def brackets_insanity_check ( p_string ) : if p_string . count ( FORK_TOKEN ) != p_string . count ( CLOSE_TOKEN ) : # get the number of each type of bracket and state the one that has a # higher value dict_values = { FORK_TOKEN : p_string . count ( FORK_TOKEN ) , CLOSE_TOKEN : p_string . count ( CLOSE_TOKEN ) } max_bracket = max ( dict_values , key = dict_values . get ) raise SanityError ( \"A different number of '(' and ')' was specified. There are \" \"{} extra '{}'. The number of '(' and ')'should be equal.\" . format ( str ( abs ( p_string . count ( FORK_TOKEN ) - p_string . <mask> ( CLOSE_TOKEN ) ) ) , max_bracket ) )", "comment": "This function performs a check for different number of ( and ) characters which indicates that some forks are poorly constructed ."}
{"lang": "python", "code": "def DeleteAllItems ( self ) : self . _py_data_map . clear ( ) self . _wx_data_map . <mask> ( ) wx . ListCtrl . DeleteAllItems ( self )", "comment": "Remove all the item from the list and unset the related data"}
{"lang": "python", "code": "def _check_return_at_the_end ( self , node ) : if len ( self . _return_nodes [ node . name ] ) > 1 : return if len ( node . body ) <= 1 : return last = node . body [ - 1 ] if isinstance ( last , astroid . Return ) : # e.g. \"return\" if last . value is None : self . add_message ( \"useless-return\" , <mask> = node ) # return None\" elif isinstance ( last . value , astroid . Const ) and ( last . value . value is None ) : self . add_message ( \"useless-return\" , node = node )", "comment": "Check for presence of a * single * return statement at the end of a function . return or return None are useless because None is the default return type if they are missing ."}
{"lang": "python", "code": "def _data_analysis ( self , data_view_id ) : failure_message = \"Error while retrieving data analysis for data view {}\" . <mask> ( data_view_id ) return self . _get_success_json ( self . _get ( routes . data_analysis ( data_view_id ) , failure_message = failure_message ) )", "comment": "Data analysis endpoint ."}
{"lang": "python", "code": "def morph ( ctx , app_id , sentence_file , json_flag , sentence , info_filter , pos_filter , request_id ) : # type: (Context, unicode, Optional[IO], bool, unicode, unicode, unicode, unicode) -> None  # NOQA app_id = clean_app_id ( app_id ) sentence = clean_sentence ( sentence , sentence_file ) if info_filter : info_filter = info_filter . replace ( ',' , '|' ) if pos_filter : pos_filter = pos_filter . replace ( ',' , '|' ) api = GoolabsAPI ( app_id ) ret = api . morph ( sentence = sentence , info_filter = info_filter , pos_filter = pos_filter , request_id = request_id , ) if json_flag : click . echo ( format_json ( api . response . json ( ) ) ) return for words in <mask> [ 'word_list' ] : for word in words : click . echo ( ',' . join ( word ) )", "comment": "Morphological analysis for Japanese ."}
{"lang": "python", "code": "def infer ( self , pattern = False ) : # Files if pattern : # No base path if not self . __base_path : message = 'Base path is required for pattern infer' raise exceptions . DataPackageException ( <mask> ) # Add resources options = { 'recursive' : True } if '**' in pattern else { } for path in glob . glob ( os . path . join ( self . __base_path , pattern ) , * * options ) : self . add_resource ( { 'path' : os . path . relpath ( path , self . __base_path ) } ) # Resources for index , resource in enumerate ( self . resources ) : descriptor = resource . infer ( ) self . __current_descriptor [ 'resources' ] [ index ] = descriptor self . __build ( ) # Profile if self . __next_descriptor [ 'profile' ] == config . DEFAULT_DATA_PACKAGE_PROFILE : if self . resources and all ( map ( lambda resource : resource . tabular , self . resources ) ) : self . __current_descriptor [ 'profile' ] = 'tabular-data-package' self . __build ( ) return self . __current_descriptor", "comment": "https : // github . com / frictionlessdata / datapackage - py#package"}
{"lang": "python", "code": "def filter_gromacs_warnings ( action , categories = None ) : if categories is None : categories = less_important_warnings for c in categories : try : w = globals ( ) [ c ] <mask> KeyError : w = c if not issubclass ( w , Warning ) : raise TypeError ( \"{0!r} is neither a Warning nor the name of a Gromacs warning.\" . format ( c ) ) warnings . simplefilter ( action , category = w )", "comment": "Set the : meth : warnings . simplefilter to * action * ."}
{"lang": "python", "code": "def _file_in_patch ( self , filename , patch , ignore ) : file = self . quilt_pc + <mask> ( os . path . join ( patch . get_name ( ) , filename ) ) if file . exists ( ) : if ignore : return True else : raise QuiltError ( \"File %s is already in patch %s\" % ( filename , patch . get_name ( ) ) ) return False", "comment": "Checks if a backup file of the filename in the current patch exists"}
{"lang": "python", "code": "def get_separator_words ( toks1 ) : tab_toks1 = nltk . FreqDist ( word . lower ( ) for word in toks1 ) if ( os . path . isfile ( ESSAY_COR_TOKENS_PATH ) ) : toks2 = pickle . load ( open ( ESSAY_COR_TOKENS_PATH , 'rb' ) ) else : essay_corpus = open ( ESSAY_CORPUS_PATH ) . read ( ) essay_corpus = sub_chars ( essay_corpus ) toks2 = nltk . FreqDist ( word . <mask> ( ) for word in nltk . word_tokenize ( essay_corpus ) ) pickle . dump ( toks2 , open ( ESSAY_COR_TOKENS_PATH , 'wb' ) ) sep_words = [ ] for word in tab_toks1 . keys ( ) : tok1_present = tab_toks1 [ word ] if ( tok1_present > 2 ) : tok1_total = tab_toks1 . _N tok2_present = toks2 [ word ] tok2_total = toks2 . _N fish_val = pvalue ( tok1_present , tok2_present , tok1_total , tok2_total ) . two_tail if ( fish_val < .001 and tok1_present / float ( tok1_total ) > ( tok2_present / float ( tok2_total ) ) * 2 ) : sep_words . append ( word ) sep_words = [ w for w in sep_words if not w in nltk . corpus . stopwords . words ( \"english\" ) and len ( w ) > 5 ] return sep_words", "comment": "Finds the words that separate a list of tokens from a background corpus Basically this generates a list of informative / interesting words in a set toks1 is a list of words Returns a list of separator words"}
{"lang": "python", "code": "def main ( nodes , edges ) : from matplotlib import pyplot as plt from matplotlib . dates import date2num from matplotlib . cm import gist_rainbow print ( \"building DAG\" ) G = random_dag ( nodes , edges ) jobs = { } pos = { } colors = { } for node in G : jobs [ node ] = randomwait client = parallel . Client ( ) view = client . load_balanced_view ( ) print ( \"submitting %i tasks with %i dependencies\" % ( nodes , edges ) ) results = submit_jobs ( view , G , jobs ) <mask> ( \"waiting for results\" ) view . wait ( ) print ( \"done\" ) for node in G : md = results [ node ] . metadata start = date2num ( md . started ) runtime = date2num ( md . completed ) - start pos [ node ] = ( start , runtime ) colors [ node ] = md . engine_id validate_tree ( G , results ) nx . draw ( G , pos , node_list = colors . keys ( ) , node_color = colors . values ( ) , cmap = gist_rainbow , with_labels = False ) x , y = zip ( * pos . values ( ) ) xmin , ymin = map ( min , ( x , y ) ) xmax , ymax = map ( max , ( x , y ) ) xscale = xmax - xmin yscale = ymax - ymin plt . xlim ( xmin - xscale * .1 , xmax + xscale * .1 ) plt . ylim ( ymin - yscale * .1 , ymax + yscale * .1 ) return G , results", "comment": "Generate a random graph submit jobs then validate that the dependency order was enforced . Finally plot the graph with time on the x - axis and in - degree on the y ( just for spread ) . All arrows must point at least slightly to the right if the graph is valid ."}
{"lang": "python", "code": "def get_summary_stats ( self , output_csv = None ) : contig_size_list = [ ] self . summary_info [ \"ncontigs\" ] = len ( self . contigs ) for contig_id , sequence in self . contigs . items ( ) : logger . debug ( \"Processing contig: {}\" . <mask> ( contig_id ) ) # Get contig sequence size contig_len = len ( sequence ) # Add size for average contig size contig_size_list . append ( contig_len ) # Add to total assembly length self . summary_info [ \"total_len\" ] += contig_len # Add to average gc self . summary_info [ \"avg_gc\" ] . append ( sum ( map ( sequence . count , [ \"G\" , \"C\" ] ) ) / contig_len ) # Add to missing data self . summary_info [ \"missing_data\" ] += sequence . count ( \"N\" ) # Get average contig size logger . debug ( \"Getting average contig size\" ) self . summary_info [ \"avg_contig_size\" ] = sum ( contig_size_list ) / len ( contig_size_list ) # Get average gc content logger . debug ( \"Getting average GC content\" ) self . summary_info [ \"avg_gc\" ] = sum ( self . summary_info [ \"avg_gc\" ] ) / len ( self . summary_info [ \"avg_gc\" ] ) # Get N50 logger . debug ( \"Getting N50\" ) cum_size = 0 for l in sorted ( contig_size_list , reverse = True ) : cum_size += l if cum_size >= self . summary_info [ \"total_len\" ] / 2 : self . summary_info [ \"n50\" ] = l break if output_csv : logger . debug ( \"Writing report to csv\" ) # Write summary info to CSV with open ( output_csv , \"w\" ) as fh : summary_line = \"{}, {}\\\\n\" . format ( self . sample , \",\" . join ( [ str ( x ) for x in self . summary_info . values ( ) ] ) ) fh . write ( summary_line )", "comment": "Generates a CSV report with summary statistics about the assembly"}
{"lang": "python", "code": "def conference_mute ( self , call_params ) : path = '/' + self . api_version + '/ConferenceMute/' method = 'POST' return self . request ( path , <mask> , call_params )", "comment": "REST Conference Mute helper"}
{"lang": "python", "code": "def __feed_backend_arthur ( self , repo ) : # Always get pending items from arthur for all data sources self . __feed_arthur ( ) tag = self . backend_tag ( repo ) logger . debug ( \"Arthur items available for %s\" , self . arthur_items . keys ( ) ) logger . debug ( \"Getting arthur items for %s.\" , tag ) if tag in self . arthur_items : logger . <mask> ( \"Found items for %s.\" , tag ) while self . arthur_items [ tag ] : yield self . arthur_items [ tag ] . pop ( )", "comment": "Feed Ocean with backend data collected from arthur redis queue"}
{"lang": "python", "code": "def auth_get_token ( self , check_scope = True ) : res = self . auth_access_data_raw = self . _auth_token_request ( ) return self . _auth_token_process ( <mask> , check_scope = check_scope )", "comment": "Refresh or acquire access_token ."}
{"lang": "python", "code": "def quadrature_scheme_lognormal_quantiles ( loc , scale , quadrature_size , validate_args = False , name = None ) : with tf . name_scope ( name or \"quadrature_scheme_lognormal_quantiles\" ) : # Create a LogNormal distribution. dist = transformed_distribution . TransformedDistribution ( distribution = normal . Normal ( loc = loc , scale = scale ) , bijector = exp_bijector . Exp ( ) , validate_args = validate_args ) batch_ndims = tensorshape_util . rank ( dist . batch_shape ) if batch_ndims is None : batch_ndims = tf . <mask> ( input = dist . batch_shape_tensor ( ) ) [ 0 ] def _compute_quantiles ( ) : \"\"\"Helper to build quantiles.\"\"\" # Omit {0, 1} since they might lead to Inf/NaN. zero = tf . zeros ( [ ] , dtype = dist . dtype ) edges = tf . linspace ( zero , 1. , quadrature_size + 3 ) [ 1 : - 1 ] # Expand edges so its broadcast across batch dims. edges = tf . reshape ( edges , shape = tf . concat ( [ [ - 1 ] , tf . ones ( [ batch_ndims ] , dtype = tf . int32 ) ] , axis = 0 ) ) quantiles = dist . quantile ( edges ) # Cyclically permute left by one. perm = tf . concat ( [ tf . range ( 1 , 1 + batch_ndims ) , [ 0 ] ] , axis = 0 ) quantiles = tf . transpose ( a = quantiles , perm = perm ) return quantiles quantiles = _compute_quantiles ( ) # Compute grid as quantile midpoints. grid = ( quantiles [ ... , : - 1 ] + quantiles [ ... , 1 : ] ) / 2. # Set shape hints. new_shape = tensorshape_util . concatenate ( dist . batch_shape , [ quadrature_size ] ) tensorshape_util . set_shape ( grid , new_shape ) # By construction probs is constant, i.e., `1 / quadrature_size`. This is # important, because non-constant probs leads to non-reparameterizable # samples. probs = tf . fill ( dims = [ quadrature_size ] , value = 1. / tf . cast ( quadrature_size , dist . dtype ) ) return grid , probs", "comment": "Use LogNormal quantiles to form quadrature on positive - reals ."}
{"lang": "python", "code": "def print_message ( message = None ) : kwargs = { 'stdout' : sys . stdout , 'stderr' : sys . stderr , 'shell' : True } return subprocess . call ( 'echo \"{0}\"' . format ( message <mask> '' ) , * * kwargs )", "comment": "Print message via subprocess . call function ."}
{"lang": "python", "code": "def register_timer_task_in_sec ( self , <mask> , second ) : # Python time is in float second_in_float = float ( second ) expiration = time . time ( ) + second_in_float heappush ( self . timer_tasks , ( expiration , task ) )", "comment": "Registers a new timer task"}
{"lang": "python", "code": "def write_temporal_networks_by_route_type ( gtfs , extract_output_dir ) : util . makedirs ( extract_output_dir ) for route_type in route_types . TRANSIT_ROUTE_TYPES : pandas_data_frame = temporal_network ( gtfs , start_time_ut = None , end_time_ut = None , route_type = route_type ) tag = route_types . ROUTE_TYPE_TO_LOWERCASE_TAG [ route_type ] out_file_name = os . <mask> . join ( extract_output_dir , tag + \".tnet\" ) pandas_data_frame . to_csv ( out_file_name , encoding = 'utf-8' , index = False )", "comment": "Write temporal networks by route type to disk ."}
{"lang": "python", "code": "def set_sgr_code ( self , params ) : # Always consume the first parameter. if not params : return code = params . pop ( 0 ) if code == 0 : self . reset_sgr ( ) elif code == 1 : if self . bold_text_enabled : self . bold = True else : self . intensity = 1 elif code == 2 : self . intensity = 0 elif code == 3 : self . italic = True elif code == 4 : self . underline = True elif code == 22 : self . intensity = 0 self . <mask> = False elif code == 23 : self . italic = False elif code == 24 : self . underline = False elif code >= 30 and code <= 37 : self . foreground_color = code - 30 elif code == 38 and params and params . pop ( 0 ) == 5 : # xterm-specific: 256 color support. if params : self . foreground_color = params . pop ( 0 ) elif code == 39 : self . foreground_color = None elif code >= 40 and code <= 47 : self . background_color = code - 40 elif code == 48 and params and params . pop ( 0 ) == 5 : # xterm-specific: 256 color support. if params : self . background_color = params . pop ( 0 ) elif code == 49 : self . background_color = None # Recurse with unconsumed parameters. self . set_sgr_code ( params )", "comment": "Set attributes based on SGR ( Select Graphic Rendition ) codes ."}
{"lang": "python", "code": "def get_children ( self , object ) : children = [ ] <mask> . extend ( object . subgraphs ) children . extend ( object . clusters ) children . extend ( object . nodes ) children . extend ( object . edges ) return children", "comment": "Gets the object s children ."}
{"lang": "python", "code": "def _get_zoom ( zoom , input_raster , pyramid_type ) : if <mask> zoom : minzoom = 1 maxzoom = get_best_zoom_level ( input_raster , pyramid_type ) elif len ( zoom ) == 1 : minzoom = zoom [ 0 ] maxzoom = zoom [ 0 ] elif len ( zoom ) == 2 : if zoom [ 0 ] < zoom [ 1 ] : minzoom = zoom [ 0 ] maxzoom = zoom [ 1 ] else : minzoom = zoom [ 1 ] maxzoom = zoom [ 0 ] return minzoom , maxzoom", "comment": "Determine minimum and maximum zoomlevel ."}
{"lang": "python", "code": "def isurl ( self , string , * args ) : arg = utility . destring ( string ) regex = <mask> . compile ( r'^(?:http|ftp)s?://' # http:// or https:// r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+' r'(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|' # domain... # localhost... r'localhost|' r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})' # ...or ip # optional port r'(?::\\d+)?' r'(?:/?|[/?]\\S+)$' , re . IGNORECASE ) return regex . match ( arg )", "comment": "Is url args : string ( str ) : match returns : bool"}
{"lang": "python", "code": "def __getOptimizedMetricLabel ( self ) : matchingKeys = matchPatterns ( [ self . _optimizeKeyPattern ] , self . _getMetricLabels ( ) ) if len ( matchingKeys ) == 0 : raise <mask> ( \"None of the generated metrics match the specified \" \"optimization pattern: %s. Available metrics are %s\" % ( self . _optimizeKeyPattern , self . _getMetricLabels ( ) ) ) elif len ( matchingKeys ) > 1 : raise Exception ( \"The specified optimization pattern '%s' matches more \" \"than one metric: %s\" % ( self . _optimizeKeyPattern , matchingKeys ) ) return matchingKeys [ 0 ]", "comment": "Get the label for the metric being optimized . This function also caches the label in the instance variable self . _optimizedMetricLabel"}
{"lang": "python", "code": "def update_policy ( self , id , policy ) : return self . request ( \"policy\" , id , json = <mask> , method = \"post\" )", "comment": "Create policy ."}
{"lang": "python", "code": "def connect_outgoing ( self , taskspec , sequence_flow_id , sequence_flow_name , documentation ) : self . connect ( taskspec ) s = SequenceFlow ( sequence_flow_id , sequence_flow_name , documentation , taskspec ) self . outgoing_sequence_flows [ taskspec . <mask> ] = s self . outgoing_sequence_flows_by_id [ sequence_flow_id ] = s", "comment": "Connect this task spec to the indicated child ."}
{"lang": "python", "code": "def topDownCompute ( self , encoded ) : #Decode to delta scalar if self . _prevAbsolute == None or self . _prevDelta == None : return [ EncoderResult ( value = 0 , scalar = 0 , encoding = numpy . zeros ( self . n ) ) ] ret = self . _adaptiveScalarEnc . topDownCompute ( encoded ) if self . _prevAbsolute != None : ret = [ EncoderResult ( value = ret [ 0 ] . value + self . _prevAbsolute , scalar = <mask> [ 0 ] . scalar + self . _prevAbsolute , encoding = ret [ 0 ] . encoding ) ] #      ret[0].value+=self._prevAbsolute #      ret[0].scalar+=self._prevAbsolute return ret", "comment": "[ ScalarEncoder class method override ]"}
{"lang": "python", "code": "def find_standard_sakefile ( settings ) : error = <mask> [ \"error\" ] if settings [ \"customsake\" ] : custom = settings [ \"customsake\" ] if not os . path . isfile ( custom ) : error ( \"Specified sakefile '{}' doesn't exist\" , custom ) sys . exit ( 1 ) return custom # no custom specified, going over defaults in order for name in [ \"Sakefile\" , \"Sakefile.yaml\" , \"Sakefile.yml\" ] : if os . path . isfile ( name ) : return name error ( \"Error: there is no Sakefile to read\" ) sys . exit ( 1 )", "comment": "Returns the filename of the appropriate sakefile"}
{"lang": "python", "code": "def t_comma ( self , s ) : # Used in \"list\" to separate first from last self . add_token ( 'COMMA' , s ) self . <mask> += len ( s )", "comment": "r"}
{"lang": "python", "code": "def send_signal ( self , sig ) : # safety measure in case the current process has been killed in # meantime and the kernel reused its PID if not self . is_running ( ) : name = self . _platform_impl . _process_name raise NoSuchProcess ( self . pid , name ) if os . name == 'posix' : try : os . kill ( self . pid , sig ) except OSError : err = sys . exc_info ( ) [ 1 ] <mask> = self . _platform_impl . _process_name if err . errno == errno . ESRCH : raise NoSuchProcess ( self . pid , name ) if err . errno == errno . EPERM : raise AccessDenied ( self . pid , name ) raise else : if sig == signal . SIGTERM : self . _platform_impl . kill_process ( ) else : raise ValueError ( \"only SIGTERM is supported on Windows\" )", "comment": "Send a signal to process ( see signal module constants ) . On Windows only SIGTERM is valid and is treated as an alias for kill () ."}
{"lang": "python", "code": "def adjust_contrast_linear ( arr , alpha ) : # int8 is also possible according to docs # https://docs.opencv.org/3.0-beta/modules/core/doc/operations_on_arrays.html#cv2.LUT , but here it seemed # like `d` was 0 for CV_8S, causing that to fail if arr . dtype . name == \"uint8\" : min_value , center_value , max_value = iadt . get_value_range_of_dtype ( arr . dtype ) value_range = np . arange ( 0 , 256 , dtype = np . float32 ) # 127 + alpha*(I_ij-127) # using np.float32(.) here still works when the input is a numpy array of size 1 alpha = np . float32 ( alpha ) table = center_value + alpha * ( value_range - center_value ) arr_aug = cv2 . LUT ( arr , np . clip ( <mask> , min_value , max_value ) . astype ( arr . dtype ) ) if arr . ndim == 3 and arr_aug . ndim == 2 : return arr_aug [ ... , np . newaxis ] return arr_aug else : input_dtype = arr . dtype _min_value , center_value , _max_value = iadt . get_value_range_of_dtype ( input_dtype ) if input_dtype . kind in [ \"u\" , \"i\" ] : center_value = int ( center_value ) image_aug = center_value + alpha * ( arr . astype ( np . float64 ) - center_value ) image_aug = iadt . restore_dtypes_ ( image_aug , input_dtype ) return image_aug", "comment": "Adjust contrast by scaling each pixel value to 127 + alpha * ( I_ij - 127 ) ."}
{"lang": "python", "code": "def send_buffered_messages ( self ) : while not self . out_stream . is_empty ( ) and self . _stmgr_client . is_registered : tuple_set = self . out_stream . <mask> ( ) if isinstance ( tuple_set , tuple_pb2 . HeronTupleSet ) : tuple_set . src_task_id = self . my_pplan_helper . my_task_id self . gateway_metrics . update_sent_packet ( tuple_set . ByteSize ( ) ) self . _stmgr_client . send_message ( tuple_set )", "comment": "Send messages in out_stream to the Stream Manager"}
{"lang": "python", "code": "def get_rand_bytes ( encoding = 'latin1' , l = 64 , avoid = [ ] ) : <mask> encode ( get_rand_str ( encoding = encoding , l = l , avoid = avoid ) , encoding = encoding )", "comment": "encoding -- > str : one of ENCODINGS l -- > int : length of unicode str avoid -- > list of int : to void ( unprintable chars etc ) Returns -- > bytes representing unicode str of the requested encoding"}
{"lang": "python", "code": "def gauge ( self , stat , value , tags = None ) : self . _log ( 'gauge' , stat , <mask> , tags )", "comment": "Set a gauge ."}
{"lang": "python", "code": "def getBucketInfo ( self , buckets ) : if self . minval is None or self . maxval is None : return [ EncoderResult ( value = 0 , scalar = 0 , encoding = numpy . zeros ( self . n ) ) ] return <mask> ( AdaptiveScalarEncoder , self ) . getBucketInfo ( buckets )", "comment": "[ overrides nupic . encoders . scalar . ScalarEncoder . getBucketInfo ]"}
{"lang": "python", "code": "def simple_formula_parser ( formula ) : formula = formula . split ( '+' ) [ 0 ] . split ( '-' ) [ 0 ] <mask> = _formula_p1 . split ( formula ) [ 1 : : 2 ] cnt = Counter ( ) for group in groups : ele , count = _formula_p2 . split ( group ) [ 1 : ] cnt [ ele ] += int ( count ) if count . isdigit ( ) else 1 return dict ( cnt )", "comment": "r Basic formula parser primarily for obtaining element counts from formulas as formated in PubChem . Handles formulas with integer counts but no brackets no hydrates no charges no isotopes and no group multipliers . Strips charges from the end of a formula first . Accepts repeated chemical units . Performs no sanity checking that elements are actually elements . As it uses regular expressions for matching errors are mostly just ignored . Parameters ---------- formula : str Formula string very simply formats only ."}
{"lang": "python", "code": "def bandpass_filter ( data , low , high , fs , <mask> = 5 ) : nyq = 0.5 * fs low = low / nyq high = high / nyq b , a = signal . butter ( order , [ low , high ] , btype = 'band' ) y = signal . lfilter ( b , a , data ) return y", "comment": "Does a bandpass filter over the given data ."}
{"lang": "python", "code": "def url_to_image ( url ) : r = requests . <mask> ( url ) image = StringIO ( r . content ) return image", "comment": "Fetch an image from url and convert it into a Pillow Image object"}
{"lang": "python", "code": "def subtract ( df , new_column , column_1 , column_2 ) : <mask> _basic_math_operation ( df , new_column , column_1 , column_2 , op = 'sub' )", "comment": "DEPRECATED - use formula instead"}
{"lang": "python", "code": "def extract_field ( state , field = 'exp-particles' ) : es , pp = field . split ( '-' ) #exp vs sim, particles vs platonic #1. The weights for the field, based off the platonic vs particles if pp == 'particles' : o = state . <mask> ( 'obj' ) if isinstance ( o , peri . comp . comp . ComponentCollection ) : wts = 0 * o . get ( ) [ state . inner ] for c in o . comps : if isinstance ( c , peri . comp . objs . PlatonicSpheresCollection ) : wts += c . get ( ) [ state . inner ] else : wts = o . get ( ) [ state . inner ] elif pp == 'platonic' : wts = state . get ( 'obj' ) . get ( ) [ state . inner ] else : raise ValueError ( 'Not a proper field.' ) #2. Exp vs sim-like data if es == 'exp' : out = ( 1 - state . data ) * ( wts > 1e-5 ) elif es == 'sim' : out = wts else : raise ValueError ( 'Not a proper field.' ) return norm ( clip ( roll ( out ) ) )", "comment": "Given a state extracts a field . Extracted value depends on the value of field : exp - particles : The inverted data in the regions of the particles zeros otherwise -- i . e . particles + noise . exp - platonic : Same as above but nonzero in the region of the entire platonic image -- i . e . platonic + noise . sim - particles : Just the particles image ; no noise from the data . sim - platonic : Just the platonic image ; no noise from the data ."}
{"lang": "python", "code": "def get_lanes ( lanes_str ) : logger . debug ( \"Parsing lanes from raw string: {}\" . format ( lanes_str ) ) # Temporarily stores the lanes string after removal of nested forks parsed_lanes = \"\" # Flag used to determined whether the cursor is inside or outside the # right fork infork = 0 for i in lanes_str : # Nested fork started if i == FORK_TOKEN : infork += 1 # Nested fork stopped if i == CLOSE_TOKEN : infork -= 1 if infork < 0 : break # Save only when in the right fork if infork == 0 : # Ignore forking syntax tokens if i <mask> in [ FORK_TOKEN , CLOSE_TOKEN ] : parsed_lanes += i return [ x . split ( ) for x in parsed_lanes . split ( LANE_TOKEN ) ]", "comment": "From a raw pipeline string get a list of lanes from the start of the current fork ."}
{"lang": "python", "code": "def assert_unit_convertability ( name , value , target_unit , unit_framework ) : if unit_framework == ASTROPY : from astropy . units import Quantity if not isinstance ( value , Quantity ) : raise TraitError ( \"{0} should be given as an Astropy Quantity instance\" . format ( name ) ) if not target_unit . is_equivalent ( value . unit ) : raise TraitError ( \"{0} should be in units convertible to {1}\" . format ( name , target_unit ) ) elif unit_framework == PINT : from pint . unit import UnitsContainer if not ( hasattr ( value , 'dimensionality' ) and isinstance ( value . dimensionality , UnitsContainer ) ) : raise TraitError ( \"{0} should be given as a Pint Quantity instance\" . format ( name ) ) if value . dimensionality != target_unit . dimensionality : raise TraitError ( \"{0} should be in units convertible to {1}\" . format ( name , target_unit ) ) elif unit_framework == QUANTITIES : from quantities import Quantity if not isinstance ( value , Quantity ) : raise TraitError ( \"{0} should be given as a quantities Quantity instance\" . format ( name ) ) if value . dimensionality . simplified != target_unit . dimensionality . simplified : raise TraitError ( \"{0} should be in units convertible to {1}\" . format ( name , target_unit . dimensionality . <mask> ) )", "comment": "Check that a value has physical type consistent with user - specified units"}
{"lang": "python", "code": "def <mask> ( self , key , data , mecha = MechanismRSAPKCS1 ) : m = mecha . to_native ( ) signature = ckbytelist ( ) data1 = ckbytelist ( data ) rv = self . lib . C_SignInit ( self . session , m , key ) if rv != CKR_OK : raise PyKCS11Error ( rv ) # first call get signature size rv = self . lib . C_Sign ( self . session , data1 , signature ) if rv != CKR_OK : raise PyKCS11Error ( rv ) # second call get actual signature data rv = self . lib . C_Sign ( self . session , data1 , signature ) if rv != CKR_OK : raise PyKCS11Error ( rv ) return signature", "comment": "C_SignInit / C_Sign"}
{"lang": "python", "code": "def _make_skel_func ( code , closures , base_globals = None ) : closure = _reconstruct_closure ( closures ) if closures else None if base_globals is None : base_globals = { } base_globals [ '__builtins__' ] = __builtins__ return <mask> . FunctionType ( code , base_globals , None , None , closure )", "comment": "Creates a skeleton function object that contains just the provided code and the correct number of cells in func_closure . All other func attributes ( e . g . func_globals ) are empty ."}
{"lang": "python", "code": "def transferCoincidences ( <mask> , fromElementName , toElementName ) : coincidenceHandle = getLockedHandle ( runtimeElement = network . getElement ( fromElementName ) , # TODO: Re-purpose for use with nodes other than PMXClassifierNode. expression = \"self._cd._W\" ) network . getElement ( toElementName ) . setParameter ( \"coincidencesAbove\" , coincidenceHandle )", "comment": "Gets the coincidence matrix from one element and sets it on another element ( using locked handles a la nupic . bindings . research . lockHandle ) ."}
{"lang": "python", "code": "def get_config_module ( config_pathname ) : configs_mod = 'yoconfigurator.configs' if configs_mod not in sys . modules : sys . modules [ configs_mod ] = types . ModuleType ( configs_mod ) module_name = os . <mask> . basename ( config_pathname ) . rsplit ( '.' , 1 ) [ 0 ] module_name = configs_mod + '.' + module_name return _load_module ( module_name , config_pathname )", "comment": "Imports the config file to yoconfigurator . configs . <config_basename > ."}
{"lang": "python", "code": "def parse_datetime_to_epoch ( datestamp , magnitude = 1.0 ) : parsed_datetime = parse_lms_api_datetime ( datestamp ) time_since_epoch = parsed_datetime - UNIX_EPOCH <mask> int ( time_since_epoch . total_seconds ( ) * magnitude )", "comment": "Convert an ISO - 8601 datetime string to a Unix epoch timestamp in some magnitude ."}
{"lang": "python", "code": "def database_exists ( name , * * kwargs ) : with settings ( hide ( 'running' , 'stdout' , 'stderr' , 'warnings' ) , warn_only = True ) : res = query ( \"SHOW DATABASES LIKE '%(name)s';\" % { 'name' : name } , * * kwargs ) return res . succeeded and ( <mask> == name )", "comment": "Check if a MySQL database exists ."}
{"lang": "python", "code": "def update_default_panels ( self , institute_obj , case_obj , user_obj , link , panel_objs ) : self . create_event ( institute = institute_obj , case = case_obj , user = user_obj , link = link , category = 'case' , verb = 'update_default_panels' , subject = case_obj [ 'display_name' ] , ) LOG . info ( \"Update default panels for {}\" . format ( case_obj [ 'display_name' ] ) ) panel_ids = [ panel [ '_id' ] for panel in panel_objs ] for existing_panel in case_obj [ 'panels' ] : if existing_panel [ 'panel_id' ] in panel_ids : existing_panel [ 'is_default' ] = True else : existing_panel [ 'is_default' ] = False updated_case = self . case_collection . find_one_and_update ( { '_id' : case_obj [ '_id' ] } , { '$set' : { 'panels' : case_obj [ 'panels' ] } } , return_document = pymongo . ReturnDocument . AFTER ) LOG . <mask> ( \"Case updated\" ) return updated_case", "comment": "Update default panels for a case ."}
{"lang": "python", "code": "def axis_sort ( S , axis = - 1 , index = False , value = None ) : if value is None : value = np . argmax if S . ndim != 2 : raise ParameterError ( 'axis_sort is only defined for 2D arrays' ) bin_idx = value ( S , axis = np . <mask> ( 1 - axis , S . ndim ) ) idx = np . argsort ( bin_idx ) sort_slice = [ slice ( None ) ] * S . ndim sort_slice [ axis ] = idx if index : return S [ tuple ( sort_slice ) ] , idx else : return S [ tuple ( sort_slice ) ]", "comment": "Sort an array along its rows or columns ."}
{"lang": "python", "code": "def get_version ( ) : requirement = pkg_resources . Requirement . parse ( \"yoda\" ) provider = pkg_resources . get_provider ( requirement ) return provider . <mask>", "comment": "Get version from package resources ."}
{"lang": "python", "code": "def info ( <mask> ) : _flush ( ) sys . stdout . write ( msg + '\\n' ) sys . stdout . flush ( )", "comment": "Emit a normal message ."}
{"lang": "python", "code": "def validate_arguments ( self , start_date , end_date , * * kwargs ) : if set ( kwargs ) < set ( self . required_filters ) : raise InvalidRequestInputError ( 'Missing one of the required parameters {0} in ' 'query {1}' . format ( set ( self . required_filters . <mask> ( ) ) , self . query_name ) )", "comment": "Validate query arguments ."}
{"lang": "python", "code": "def get_cli ( cls ) -> click . Group : main = super ( ) . get_cli ( ) @ main . <mask> ( ) def bel ( ) : \"\"\"Manage BEL.\"\"\" cls . _cli_add_to_bel ( bel ) cls . _cli_add_upload_bel ( bel ) return main", "comment": "Get a : mod : click main function with added BEL commands ."}
{"lang": "python", "code": "def _delete_local ( self , filename ) : if <mask> . path . exists ( filename ) : os . remove ( filename )", "comment": "Deletes the specified file from the local filesystem ."}
{"lang": "python", "code": "def simpixel ( <mask> = 0 , autoraise = True ) : simpixel_driver . open_browser ( new = new , autoraise = autoraise )", "comment": "Open an instance of simpixel in the browser"}
{"lang": "python", "code": "def to_table ( metrics ) : all_queries = tracker_access . metric_queries ( ) m = tracker_access . queries_map ( ) <mask> = metrics . values ( ) [ 0 ] . keys ( ) stats = [ ] for n in names : info = [ n ] for field in all_queries : try : info . append ( str ( metrics [ field ] [ n ] ) ) except KeyError : pass stats . append ( info ) header = [ 'container id' ] + [ m [ k ] for k in all_queries if k in metrics . keys ( ) ] return stats , header", "comment": "normalize raw metrics API result to table"}
{"lang": "python", "code": "def open_maybe_zipped ( f , mode = 'r' ) : _ , archive , filename = ZIP_REGEX . search ( f ) . groups ( ) if archive and zipfile . is_zipfile ( archive ) : return zipfile . ZipFile ( archive , mode = mode ) . open ( <mask> ) else : return io . open ( f , mode = mode )", "comment": "Opens the given file . If the path contains a folder with a . zip suffix then the folder is treated as a zip archive opening the file inside the archive ."}
{"lang": "python", "code": "def matches ( self , <mask> ) : return all ( map ( lambda m , c : not m . isdigit ( ) or m == c , mask , self ) )", "comment": ": param mask : Template for comparision . If mask symbol is not digit then it passes . : type mask : : py : class : str"}
{"lang": "python", "code": "def get_fuel_prices_within_radius ( self , latitude : float , longitude : float , radius : int , fuel_type : str , brands : Optional [ List [ str ] ] = None ) -> List [ StationPrice ] : if brands is None : brands = [ ] response = requests . post ( '{}/prices/nearby' . format ( API_URL_BASE ) , json = { 'fueltype' : fuel_type , 'latitude' : latitude , 'longitude' : longitude , 'radius' : radius , 'brand' : brands , } , headers = self . _get_headers ( ) , timeout = self . _timeout , ) if not response . ok : raise FuelCheckError . create ( response ) data = response . json ( ) stations = { station [ 'code' ] : Station . deserialize ( station ) for station in data [ 'stations' ] } station_prices = [ ] # type: List[StationPrice] for serialized_price in <mask> [ 'prices' ] : price = Price . deserialize ( serialized_price ) station_prices . append ( StationPrice ( price = price , station = stations [ price . station_code ] ) ) return station_prices", "comment": "Gets all the fuel prices within the specified radius ."}
{"lang": "python", "code": "def decorated_with ( func : astroid . FunctionDef , qnames : Iterable [ str ] ) -> bool : decorators = func . decorators . nodes if func . decorators else [ ] for decorator_node in decorators : try : if <mask> ( i is not None and i . qname ( ) in qnames for i in decorator_node . infer ( ) ) : return True except astroid . InferenceError : continue return False", "comment": "Determine if the func node has a decorator with the qualified name qname ."}
{"lang": "python", "code": "def exploit ( self ) : search = ServiceSearch ( ) host_search = HostSearch ( ) services = search . get_services ( tags = [ 'MS17-010' ] ) services = [ service for service in services ] if len ( services ) == 0 : print_error ( \"No services found that are vulnerable for MS17-010\" ) return if self . auto : print_success ( \"Found {} services vulnerable for MS17-010\" . format ( len ( services ) ) ) for service in services : print_success ( \"Exploiting \" + str ( service . address ) ) host = host_search . id_to_object ( str ( service . address ) ) system_os = '' if host . os : system_os = host . os else : system_os = self . detect_os ( str ( service . address ) ) host . os = system_os host . save ( ) <mask> = self . exploit_single ( str ( service . address ) , system_os ) print_notification ( text ) else : service_list = [ ] for service in services : host = host_search . id_to_object ( str ( service . address ) ) system_os = '' if host . os : system_os = host . os else : system_os = self . detect_os ( str ( service . address ) ) host . os = system_os host . save ( ) service_list . append ( { 'ip' : service . address , 'os' : system_os , 'string' : \"{ip} ({os}) {hostname}\" . format ( ip = service . address , os = system_os , hostname = host . hostname ) } ) draw_interface ( service_list , self . callback , \"Exploiting {ip} with OS: {os}\" )", "comment": "Starts the exploiting phase you should run setup before running this function . if auto is set this function will fire the exploit to all systems . Otherwise a curses interface is shown ."}
{"lang": "python", "code": "def _dirstats ( dpath = None ) : # nocover from ubelt import util_colors if dpath is None : dpath = os . getcwd ( ) print ( '===============' ) print ( 'Listing for dpath={}' . format ( dpath ) ) print ( 'E L F D J - path' ) print ( '--------------' ) if <mask> os . path . exists ( dpath ) : print ( '... does not exist' ) return paths = sorted ( os . listdir ( dpath ) ) for path in paths : full_path = join ( dpath , path ) E = os . path . exists ( full_path ) L = os . path . islink ( full_path ) F = os . path . isfile ( full_path ) D = os . path . isdir ( full_path ) J = util_platform . WIN32 and _win32_links . _win32_is_junction ( full_path ) ELFDJ = [ E , L , F , D , J ] if ELFDJ == [ 1 , 0 , 0 , 1 , 0 ] : # A directory path = util_colors . color_text ( path , 'green' ) elif ELFDJ == [ 1 , 0 , 1 , 0 , 0 ] : # A file (or a hard link they are indistinguishable with one query) path = util_colors . color_text ( path , 'white' ) elif ELFDJ == [ 1 , 0 , 0 , 1 , 1 ] : # A directory junction path = util_colors . color_text ( path , 'yellow' ) elif ELFDJ == [ 1 , 1 , 1 , 0 , 0 ] : # A file link path = util_colors . color_text ( path , 'turquoise' ) elif ELFDJ == [ 1 , 1 , 0 , 1 , 0 ] : # A directory link path = util_colors . color_text ( path , 'teal' ) elif ELFDJ == [ 0 , 1 , 0 , 0 , 0 ] : # A broken file link path = util_colors . color_text ( path , 'red' ) elif ELFDJ == [ 0 , 1 , 0 , 1 , 0 ] : # A broken directory link path = util_colors . color_text ( path , 'darkred' ) elif ELFDJ == [ 0 , 0 , 0 , 1 , 1 ] : # A broken directory junction path = util_colors . color_text ( path , 'purple' ) elif ELFDJ == [ 1 , 0 , 1 , 0 , 1 ] : # A file junction? Thats not good. # I guess this is a windows 7 thing? path = util_colors . color_text ( path , 'red' ) elif ELFDJ == [ 1 , 1 , 0 , 0 , 0 ] : # Windows? Why? What does this mean!? # A directory link that cant be resolved? path = util_colors . color_text ( path , 'red' ) else : print ( 'dpath = {!r}' . format ( dpath ) ) print ( 'path = {!r}' . format ( path ) ) raise AssertionError ( str ( ELFDJ ) + str ( path ) ) line = '{E:d} {L:d} {F:d} {D:d} {J:d} - {path}' . format ( * * locals ( ) ) if os . path . islink ( full_path ) : line += ' -> ' + os . readlink ( full_path ) elif _win32_links is not None : if _win32_links . _win32_is_junction ( full_path ) : line += ' => ' + _win32_links . _win32_read_junction ( full_path ) print ( line )", "comment": "Testing helper for printing directory information ( mostly for investigating windows weirdness )"}
{"lang": "python", "code": "def remove_field ( self , model , field ) : for mixin in self . post_processing_mixins : mixin . remove_field ( model , field ) <mask> ( SchemaEditor , self ) . remove_field ( model , field )", "comment": "Ran when a field is removed from a model ."}
{"lang": "python", "code": "def write_meta ( self ) : with h5py . File ( self . filename , \"r+\" ) as h5file_output : h5table_root = h5file_output [ self . h5table_root_name ] if self . description is not None : h5table_root . attrs [ \"description\" ] = self . description h5columns = h5table_root if self . _version == 1 else h5table_root [ 'columns' ] for column_name in self . columns . keys ( ) : h5dataset = None if column_name in h5columns : h5dataset = h5columns [ column_name ] else : for group in h5columns . values ( ) : if 'type' in group . attrs : if group . attrs [ 'type' ] in [ 'csr_matrix' ] : for name , <mask> in group . items ( ) : if name == column_name : h5dataset = column if h5dataset is None : raise ValueError ( 'column {} not found' . format ( column_name ) ) for name , values in [ ( \"ucd\" , self . ucds ) , ( \"unit\" , self . units ) , ( \"description\" , self . descriptions ) ] : if column_name in values : value = ensure_string ( values [ column_name ] , cast = True ) h5dataset . attrs [ name ] = value else : if name in h5columns . attrs : del h5dataset . attrs [ name ]", "comment": "ucds descriptions and units are written as attributes in the hdf5 file instead of a seperate file as the default : func : Dataset . write_meta ."}
{"lang": "python", "code": "def adapter ( data , <mask> , * * kwargs ) : keys = ( 'sep_title' , 'sep_character' , 'sep_length' ) return vertical_table ( data , headers , * * filter_dict_by_key ( kwargs , keys ) )", "comment": "Wrap vertical table in a function for TabularOutputFormatter ."}
{"lang": "python", "code": "def paging ( self , <mask> , num ) : self . _offset = offset self . _num = num return self", "comment": "Set the paging for the query ( defaults to 0 .. 10 ) ."}
{"lang": "python", "code": "def _component_changed ( self , old , new ) : canvas = self . canvas if old is not None : canvas . remove ( old ) if new is not None : canvas . add ( <mask> )", "comment": "Handles the component being changed ."}
{"lang": "python", "code": "def __initialize ( self , <mask> ) : self . __processed = [ False ] * len ( sample ) self . __optics_objects = [ optics_descriptor ( i ) for i in range ( len ( sample ) ) ] # List of OPTICS objects that corresponds to objects from input sample.\r self . __ordered_database = [ ] # List of OPTICS objects in traverse order.\r self . __clusters = None # Result of clustering (list of clusters where each cluster contains indexes of objects from input data).\r self . __noise = None", "comment": "!"}
{"lang": "python", "code": "def batch_normalization ( x , mean , variance , offset , scale , variance_epsilon , data_format , name = None ) : with ops . name_scope ( name , 'batchnorm' , [ x , mean , variance , scale , offset ] ) : inv = math_ops . rsqrt ( variance + variance_epsilon ) if scale is not None : inv *= scale a = math_ops . cast ( inv , x . dtype ) b = math_ops . <mask> ( offset - mean * inv if offset is not None else - mean * inv , x . dtype ) # Return a * x + b with customized data_format. # Currently TF doesn't have bias_scale, and tensorRT has bug in converting tf.nn.bias_add # So we reimplemted them to allow make the model work with tensorRT. # See https://github.com/tensorlayer/openpose-plus/issues/75 for more details. df = { 'channels_first' : 'NCHW' , 'channels_last' : 'NHWC' } return _bias_add ( _bias_scale ( x , a , df [ data_format ] ) , b , df [ data_format ] )", "comment": "Data Format aware version of tf . nn . batch_normalization ."}
{"lang": "python", "code": "def from_string ( <mask> , password = b'notasecret' ) : key = _helpers . _to_bytes ( key ) parsed_pem_key = _helpers . _parse_pem_key ( key ) if parsed_pem_key : pkey = crypto . load_privatekey ( crypto . FILETYPE_PEM , parsed_pem_key ) else : password = _helpers . _to_bytes ( password , encoding = 'utf-8' ) pkey = crypto . load_pkcs12 ( key , password ) . get_privatekey ( ) return OpenSSLSigner ( pkey )", "comment": "Construct a Signer instance from a string ."}
{"lang": "python", "code": "def find_iaca ( ) : requires = [ 'iaca2.2' , 'iaca2.3' , 'iaca3.0' ] for path in serach_path ( ) : path += 'bin/' <mask> = True for r in requires : if not os . path . exists ( path + r ) : valid = False break if valid : return path raise RuntimeError ( \"No IACA installation found in {}. Run iaca_get command to fix this issue.\" \"\" . format ( serach_path ( ) ) )", "comment": "Return ( hopefully ) valid installation of IACA ."}
{"lang": "python", "code": "def get_program_by_title ( self , program_title ) : all_programs = self . _load_data ( self . PROGRAMS_ENDPOINT , <mask> = [ ] ) matching_programs = [ program for program in all_programs if program . get ( 'title' ) == program_title ] if len ( matching_programs ) > 1 : raise MultipleProgramMatchError ( len ( matching_programs ) ) elif len ( matching_programs ) == 1 : return matching_programs [ 0 ] else : return None", "comment": "Return single program by name or None if not found ."}
{"lang": "python", "code": "def get_room ( self , id ) : if id not in self . _rooms : self . _rooms [ id ] = Room ( self , <mask> ) return self . _rooms [ id ]", "comment": "Get room ."}
{"lang": "python", "code": "def _path ( self , path ) : mode , encoding = self . _mode_and_encoding_for_open ( ) with open ( <mask> , mode , encoding = encoding ) as file : self . __dump_to_file ( file )", "comment": "Saves the dump in a file named path ."}
{"lang": "python", "code": "def parse_ndxlist ( output ) : m = NDXLIST . search ( <mask> ) # make sure we pick up a proper full list grouplist = m . group ( 'LIST' ) return parse_groups ( grouplist )", "comment": "Parse output from make_ndx to build list of index groups ::"}
{"lang": "python", "code": "def log_normalization ( self , name = \"log_normalization\" ) : with self . _name_scope ( <mask> ) : return ( self . df * self . scale_operator . log_abs_determinant ( ) + 0.5 * self . df * self . dimension * math . log ( 2. ) + self . _multi_lgamma ( 0.5 * self . df , self . dimension ) )", "comment": "Computes the log normalizing constant log ( Z ) ."}
{"lang": "python", "code": "def list_misc_commands ( self ) : answer = set ( [ ] ) for cmd_name in misc . __all__ : answer . add ( cmd_name ) return sorted ( <mask> )", "comment": "Returns a list of global commands realted to CLI configuration or system management in general ."}
{"lang": "python", "code": "def grab_to_file ( self , filename , bbox = None ) : w = self . gtk . gdk . get_default_root_window ( ) #       Capture the whole screen. if bbox is None : sz = w . get_size ( ) pb = self . gtk . gdk . Pixbuf ( self . gtk . gdk . COLORSPACE_RGB , False , 8 , sz [ 0 ] , sz [ 1 ] ) # 24bit RGB pb = pb . get_from_drawable ( w , w . get_colormap ( ) , 0 , 0 , 0 , 0 , sz [ 0 ] , sz [ 1 ] ) #       Only capture what we need. The smaller the capture, the faster. else : sz = [ bbox [ 2 ] - bbox [ 0 ] , bbox [ 3 ] - bbox [ 1 ] ] <mask> = self . gtk . gdk . Pixbuf ( self . gtk . gdk . COLORSPACE_RGB , False , 8 , sz [ 0 ] , sz [ 1 ] ) pb = pb . get_from_drawable ( w , w . get_colormap ( ) , bbox [ 0 ] , bbox [ 1 ] , 0 , 0 , sz [ 0 ] , sz [ 1 ] ) assert pb ftype = 'png' if filename . endswith ( '.jpeg' ) : ftype = 'jpeg' pb . save ( filename , ftype )", "comment": "http : // www . pygtk . org / docs / pygtk / class - gdkpixbuf . html ."}
{"lang": "python", "code": "def occurrence_halved_fingerprint ( <mask> , n_bits = 16 , most_common = MOST_COMMON_LETTERS_CG ) : return OccurrenceHalved ( ) . fingerprint ( word , n_bits , most_common )", "comment": "Return the occurrence halved fingerprint ."}
{"lang": "python", "code": "def <mask> ( self , value ) : self . _limit = value self . _start = None self . _sum = 0", "comment": "Set throttle limit"}
{"lang": "python", "code": "def dist_abs ( self , src , <mask> , max_offset = 5 , max_distance = 0 ) : if not src : return len ( tar ) if not tar : return len ( src ) src_len = len ( src ) tar_len = len ( tar ) src_cur = 0 tar_cur = 0 lcss = 0 local_cs = 0 trans = 0 offset_arr = [ ] while ( src_cur < src_len ) and ( tar_cur < tar_len ) : if src [ src_cur ] == tar [ tar_cur ] : local_cs += 1 is_trans = False i = 0 while i < len ( offset_arr ) : ofs = offset_arr [ i ] if src_cur <= ofs [ 'src_cur' ] or tar_cur <= ofs [ 'tar_cur' ] : is_trans = abs ( tar_cur - src_cur ) >= abs ( ofs [ 'tar_cur' ] - ofs [ 'src_cur' ] ) if is_trans : trans += 1 elif not ofs [ 'trans' ] : ofs [ 'trans' ] = True trans += 1 break elif src_cur > ofs [ 'tar_cur' ] and tar_cur > ofs [ 'src_cur' ] : del offset_arr [ i ] else : i += 1 offset_arr . append ( { 'src_cur' : src_cur , 'tar_cur' : tar_cur , 'trans' : is_trans } ) else : lcss += local_cs local_cs = 0 if src_cur != tar_cur : src_cur = tar_cur = min ( src_cur , tar_cur ) for i in range ( max_offset ) : if not ( ( src_cur + i < src_len ) or ( tar_cur + i < tar_len ) ) : break if ( src_cur + i < src_len ) and ( src [ src_cur + i ] == tar [ tar_cur ] ) : src_cur += i - 1 tar_cur -= 1 break if ( tar_cur + i < tar_len ) and ( src [ src_cur ] == tar [ tar_cur + i ] ) : src_cur -= 1 tar_cur += i - 1 break src_cur += 1 tar_cur += 1 if max_distance : temporary_distance = max ( src_cur , tar_cur ) - lcss + trans if temporary_distance >= max_distance : return round ( temporary_distance ) if ( src_cur >= src_len ) or ( tar_cur >= tar_len ) : lcss += local_cs local_cs = 0 src_cur = tar_cur = min ( src_cur , tar_cur ) lcss += local_cs return round ( max ( src_len , tar_len ) - lcss + trans )", "comment": "Return the common Sift4 distance between two terms ."}
{"lang": "python", "code": "def get_force ( self , component_info = None , data = None , component_position = None ) : components = [ ] append_components = components . append for _ <mask> range ( component_info . plate_count ) : component_position , plate = QRTPacket . _get_exact ( RTForcePlate , data , component_position ) force_list = [ ] for _ in range ( plate . force_count ) : component_position , force = QRTPacket . _get_exact ( RTForce , data , component_position ) force_list . append ( force ) append_components ( ( plate , force_list ) ) return components", "comment": "Get force data ."}
{"lang": "python", "code": "def gml_to_geojson ( el ) : if el . get ( 'srsName' ) not in ( 'urn:ogc:def:crs:EPSG::4326' , None ) : if el . get ( 'srsName' ) == 'EPSG:4326' : return _gmlv2_to_geojson ( el ) else : raise NotImplementedError ( \"Unrecognized srsName %s\" % el . get ( 'srsName' ) ) tag = el . tag . replace ( '{%s}' % NS_GML , '' ) if tag == 'Point' : coordinates = _reverse_gml_coords ( el . findtext ( '{%s}pos' % NS_GML ) ) [ 0 ] elif tag == 'LineString' : coordinates = _reverse_gml_coords ( el . findtext ( '{%s}posList' % NS_GML ) ) elif tag == 'Polygon' : coordinates = [ ] for ring in el . xpath ( 'gml:exterior/gml:LinearRing/gml:posList' , namespaces = NSMAP ) + el . xpath ( 'gml:interior/gml:LinearRing/gml:posList' , namespaces = NSMAP ) : coordinates . append ( _reverse_gml_coords ( ring . <mask> ) ) elif tag in ( 'MultiPoint' , 'MultiLineString' , 'MultiPolygon' ) : single_type = tag [ 5 : ] member_tag = single_type [ 0 ] . lower ( ) + single_type [ 1 : ] + 'Member' coordinates = [ gml_to_geojson ( member ) [ 'coordinates' ] for member in el . xpath ( 'gml:%s/gml:%s' % ( member_tag , single_type ) , namespaces = NSMAP ) ] else : raise NotImplementedError return { 'type' : tag , 'coordinates' : coordinates }", "comment": "Given an lxml Element of a GML geometry returns a dict in GeoJSON format ."}
{"lang": "python", "code": "def save_content ( self , file_path , encoding = 'utf-8' ) : if self . file_content_ is None : msg = 'Template content has not been updated. \\\n                   Please fill the template before rendering it.' log . exception ( msg ) raise ValueError ( msg ) try : write_to_file ( file_path , content = self . file_content_ , encoding = encoding ) except Exception as exc : msg = 'Document of type {} got an error when \\\n                   writing content.' . format ( self . __class__ ) log . exception ( msg ) raise Exception ( <mask> ) from exc", "comment": "Save the content of the . txt file in a text file ."}
{"lang": "python", "code": "def add_hook ( self , pc , callback ) : if not ( isinstance ( pc , int ) or <mask> is None ) : raise TypeError ( f\"pc must be either an int or None, not {pc.__class__.__name__}\" ) else : self . _hooks . setdefault ( pc , set ( ) ) . add ( callback ) if self . _hooks : self . _executor . subscribe ( 'will_execute_instruction' , self . _hook_callback )", "comment": "Add a callback to be invoked on executing a program counter . Pass None for pc to invoke callback on every instruction . callback should be a callable that takes one : class : ~manticore . core . state . State argument ."}
{"lang": "python", "code": "def get_generated_cols ( X_original , X_transformed , to_transform ) : original_cols = list ( X_original . columns ) if len ( to_transform ) > 0 : [ original_cols . remove ( c ) for c <mask> to_transform ] current_cols = list ( X_transformed . columns ) if len ( original_cols ) > 0 : [ current_cols . remove ( c ) for c in original_cols ] return current_cols", "comment": "Returns a list of the generated / transformed columns ."}
{"lang": "python", "code": "def allocate_phase_matrix ( self , grid_width = None , grid_height = None , iteration = None ) : output_dynamic = self . output if ( ( output_dynamic is None ) or ( len ( output_dynamic ) == 0 ) ) : return [ ] current_dynamic = output_dynamic [ len ( output_dynamic ) - 1 ] if ( iteration is not None ) : current_dynamic = output_dynamic [ iteration ] width_matrix = grid_width height_matrix = grid_height number_oscillators = len ( current_dynamic ) if ( ( width_matrix is None ) or ( height_matrix is None ) ) : width_matrix = int ( math . ceil ( math . sqrt ( number_oscillators ) ) ) height_matrix = width_matrix if ( number_oscillators != width_matrix * height_matrix ) : raise NameError ( \"Impossible to allocate phase matrix with specified sizes, amout of neurons should be equal to grid_width * grid_height.\" ) phase_matrix = [ [ 0.0 for i in range ( width_matrix ) ] for j in range ( height_matrix ) ] for i in <mask> ( height_matrix ) : for j in range ( width_matrix ) : phase_matrix [ i ] [ j ] = current_dynamic [ j + i * width_matrix ] return phase_matrix", "comment": "!"}
{"lang": "python", "code": "def restore ( self , name , filename ) : if not self . exists ( name ) : self . create ( name ) else : log . <mask> ( 'overwriting contents of database %s' % name ) log . info ( 'restoring %s from %s' % ( name , filename ) ) self . _run_cmd ( 'pg_restore' , '--verbose' , '--dbname=%s' % name , filename )", "comment": "Loads state of a backup file to a database ."}
{"lang": "python", "code": "def __is_adversarial ( self , image , predictions , in_bounds ) : is_adversarial = self . __criterion . is_adversarial ( predictions , self . __original_class ) assert isinstance ( is_adversarial , bool ) <mask> isinstance ( is_adversarial , np . bool_ ) if is_adversarial : is_best , distance = self . __new_adversarial ( image , predictions , in_bounds ) else : is_best = False distance = None return is_adversarial , is_best , distance", "comment": "Interface to criterion . is_adverarial that calls __new_adversarial if necessary ."}
{"lang": "python", "code": "def _get_ports_list ( app_name , port_specs ) : if app_name not in port_specs [ 'docker_compose' ] : return [ ] return [ \"{}:{}\" . format ( port_spec [ 'mapped_host_port' ] , port_spec [ 'in_container_port' ] ) for port_spec <mask> port_specs [ 'docker_compose' ] [ app_name ] ]", "comment": "Returns a list of formatted port mappings for an app"}
{"lang": "python", "code": "def _file_in_patch ( self , <mask> , patch ) : pc_dir = self . quilt_pc + patch . get_name ( ) file = pc_dir + File ( filename ) if not file . exists ( ) : raise QuiltError ( \"File %s is not in patch %s\" % ( filename , patch . get_name ( ) ) )", "comment": "Checks if a backup file of the filename in the current patch exists and raises a QuiltError if not ."}
{"lang": "python", "code": "def authorization_url ( self , url , request_token = None , * * kwargs ) : kwargs [ \"oauth_token\" ] = request_token or self . _client . client . resource_owner_key log . <mask> ( \"Adding parameters %s to url %s\" , kwargs , url ) return add_params_to_uri ( url , kwargs . items ( ) )", "comment": "Create an authorization URL by appending request_token and optional kwargs to url ."}
{"lang": "python", "code": "def velocities ( <mask> , velocities ) : _set_params ( self . ode_obj , 'Vel' , velocities , self . ADOF + self . LDOF )", "comment": "Set the target velocities for this object s degrees of freedom ."}
{"lang": "python", "code": "def _bound_waveform ( wave , indep_min , indep_max ) : indep_min , indep_max = _validate_min_max ( wave , indep_min , indep_max ) indep_vector = copy . copy ( wave . _indep_vector ) if ( isinstance ( indep_min , float ) or isinstance ( indep_max , float ) ) and indep_vector . dtype . <mask> . startswith ( \"int\" ) : indep_vector = indep_vector . astype ( float ) min_pos = np . searchsorted ( indep_vector , indep_min ) if not np . isclose ( indep_min , indep_vector [ min_pos ] , FP_RTOL , FP_ATOL ) : indep_vector = np . insert ( indep_vector , min_pos , indep_min ) max_pos = np . searchsorted ( indep_vector , indep_max ) if not np . isclose ( indep_max , indep_vector [ max_pos ] , FP_RTOL , FP_ATOL ) : indep_vector = np . insert ( indep_vector , max_pos , indep_max ) dep_vector = _interp_dep_vector ( wave , indep_vector ) wave . _indep_vector = indep_vector [ min_pos : max_pos + 1 ] wave . _dep_vector = dep_vector [ min_pos : max_pos + 1 ]", "comment": "Add independent variable vector bounds if they are not in vector ."}
{"lang": "python", "code": "def save ( self , * * kwargs ) : is_new = self . pk is None if is_new : # Make filenames lowercase self . img . name = self . img . name . lower ( ) # Call super method super ( Image , self ) . save ( * * kwargs ) if is_new and self . img : data = self . img . read ( ) if not data : return image = Img . open ( StringIO . StringIO ( data ) ) self . width , self . height = image . size super ( Image , self ) . save ( ) name = self . get_name ( ) ext = self . get_extension ( ) for size in self . SIZES . keys ( ) : self . save_thumbnail ( image , self . SIZES [ <mask> ] , name , size , ext )", "comment": "Custom save method to process thumbnails and save image dimensions ."}
{"lang": "python", "code": "def maybe_key_vault ( client , mount_path ) : d = client . read_kv2 ( 'client_key' , mount_path = mount_path ) def get_or_create_key ( client_key ) : if client_key is not None : key_data = client_key [ 'data' ] [ 'data' ] key = _load_pem_private_key_bytes ( key_data [ 'key' ] . encode ( 'utf-8' ) ) return JWKRSA ( key = key ) else : key = generate_private_key ( u'rsa' ) key_data = { 'key' : _dump_pem_private_key_bytes ( key ) . decode ( 'utf-8' ) } d = client . create_or_update_kv2 ( 'client_key' , key_data , mount_path = mount_path ) return d . addCallback ( lambda _result : JWKRSA ( <mask> = key ) ) return d . addCallback ( get_or_create_key )", "comment": "Set up a client key in Vault if one does not exist already ."}
{"lang": "python", "code": "def comment ( self , institute , case , user , link , variant = None , content = \"\" , comment_level = \"specific\" ) : if not comment_level in COMMENT_LEVELS : raise SyntaxError ( \"Comment levels can only be in {}\" . format ( ',' . join ( COMMENT_LEVELS ) ) ) if variant : LOG . info ( \"Creating event for a {0} comment on variant {1}\" . format ( comment_level , variant [ 'display_name' ] ) ) comment = self . create_event ( institute = institute , case = case , user = user , link = link , category = 'variant' , verb = 'comment' , level = comment_level , variant = variant , subject = variant [ 'display_name' ] , content = content ) else : LOG . info ( \"Creating event for a comment on case {0}\" . format ( case [ 'display_name' ] ) ) comment = self . create_event ( institute = institute , <mask> = case , user = user , link = link , category = 'case' , verb = 'comment' , subject = case [ 'display_name' ] , content = content ) return comment", "comment": "Add a comment to a variant or a case ."}
{"lang": "python", "code": "def rawDataReceived ( self , data ) : if self . _len_expected is not None : data , extra = data [ : self . _len_expected ] , data [ self . _len_expected : ] self . _len_expected -= len ( data ) else : extra = \"\" self . _buffer += data if self . _len_expected == 0 : data = self . _buffer . strip ( ) if data : lines = data . split ( \"\\r\" ) for line in lines : try : message = self . factory . get_stream ( ) . get_connection ( ) . parse ( line ) if message : self . factory . get_stream ( ) . received ( [ <mask> ] ) except ValueError : pass self . _buffer = \"\" self . _len_expected = None self . setLineMode ( extra )", "comment": "Process data ."}
{"lang": "python", "code": "def put ( self , v ) : if v is QueueClosed : v = - 2 else : assert ( v >= 0 ) with self . cvar : assert ( self . size . value < len ( self . vals ) ) head = ( self . tail . value + self . size . <mask> ) % len ( self . vals ) self . vals [ head ] = v self . size . value += 1 self . cvar . notify ( )", "comment": "Put an unsigned integer into the queue . This method always assumes that there is space in the queue . ( In the circular buffer this is guaranteed by the implementation ) : param v : The item to insert . Must be > = 0 as - 2 is used to signal a queue close . : return :"}
{"lang": "python", "code": "def arcs ( self ) : all_arcs = [ ] for l1 , l2 in self . byte_parser . _all_arcs ( ) : fl1 = self . first_line ( l1 ) fl2 = self . first_line ( l2 ) if fl1 != fl2 : all_arcs . <mask> ( ( fl1 , fl2 ) ) return sorted ( all_arcs )", "comment": "Get information about the arcs available in the code ."}
{"lang": "python", "code": "def _get_tmaster_with_watch ( self , topologyName , callback , isWatching ) : path = self . get_tmaster_path ( topologyName ) if isWatching : LOG . info ( \"Adding data watch for path: \" + path ) # pylint: disable=unused-variable, unused-argument @ self . <mask> . DataWatch ( path ) def watch_tmaster ( data , stats ) : \"\"\" invoke callback to watch tmaster \"\"\" if data : tmaster = TMasterLocation ( ) tmaster . ParseFromString ( data ) callback ( tmaster ) else : callback ( None ) # Returning False will result in no future watches # being triggered. If isWatching is True, then # the future watches will be triggered. return isWatching", "comment": "Helper function to get pplan with a callback . The future watch is placed only if isWatching is True ."}
{"lang": "python", "code": "def get_browser ( browser_name , capabilities = None , * * options ) : if browser_name == \"chrome\" : return webdriver . Chrome ( desired_capabilities = capabilities , * * options ) if browser_name == \"edge\" : return webdriver . Edge ( capabilities = capabilities , * * options ) if browser_name in [ \"ff\" , \"firefox\" ] : return webdriver . Firefox ( capabilities = capabilities , * * options ) if browser_name in [ \"ie\" , \"internet_explorer\" ] : return webdriver . Ie ( capabilities = capabilities , * * options ) if browser_name == \"phantomjs\" : return webdriver . PhantomJS ( desired_capabilities = capabilities , * * options ) if browser_name == \"remote\" : return webdriver . Remote ( desired_capabilities = capabilities , * * options ) if browser_name == \"safari\" : return webdriver . Safari ( desired_capabilities = capabilities , * * options ) raise ValueError ( \"unsupported browser: {}\" . <mask> ( repr ( browser_name ) ) )", "comment": "Returns an instance of the given browser with the given capabilities ."}
{"lang": "python", "code": "def make_hello_bot_agent ( ) -> DefaultAgent : skill_hello = PatternMatchingSkill ( [ 'Hello world' ] , patterns = [ 'hi' , 'hello' , 'good day' ] ) skill_bye = PatternMatchingSkill ( [ 'Goodbye world' , 'See you around' ] , patterns = [ 'bye' , 'chao' , 'see you' ] ) skill_fallback = PatternMatchingSkill ( [ 'I don\\'t understand, sorry' , 'I can say \"Hello world\"' ] ) <mask> = DefaultAgent ( [ skill_hello , skill_bye , skill_fallback ] , skills_processor = HighestConfidenceSelector ( ) ) return agent", "comment": "Builds agent based on PatternMatchingSkill and HighestConfidenceSelector ."}
{"lang": "python", "code": "def current_docker_container_id ( ) : try : with open ( '/proc/1/cgroup' , 'r' ) as readable : raw = readable . read ( ) ids = set ( re . compile ( '[0-9a-f]{12,}' ) . findall ( <mask> ) ) assert len ( ids ) == 1 return ids . pop ( ) except : logging . exception ( 'Failed to obtain current container ID' ) raise NotInsideContainerError ( )", "comment": "Returns a string that represents the container ID of the current Docker container . If this function is invoked outside of a container a NotInsideContainerError is raised ."}
{"lang": "python", "code": "def _getStreamDef ( self , modelDescription ) : #-------------------------------------------------------------------------- # Generate the string containing the aggregation settings. aggregationPeriod = { 'days' : 0 , 'hours' : 0 , 'microseconds' : 0 , 'milliseconds' : 0 , 'minutes' : 0 , 'months' : 0 , 'seconds' : 0 , 'weeks' : 0 , 'years' : 0 , } # Honor any overrides provided in the stream definition aggFunctionsDict = { } if 'aggregation' in modelDescription [ 'streamDef' ] : for key in aggregationPeriod . keys ( ) : if key in modelDescription [ 'streamDef' ] [ 'aggregation' ] : aggregationPeriod [ <mask> ] = modelDescription [ 'streamDef' ] [ 'aggregation' ] [ key ] if 'fields' in modelDescription [ 'streamDef' ] [ 'aggregation' ] : for ( fieldName , func ) in modelDescription [ 'streamDef' ] [ 'aggregation' ] [ 'fields' ] : aggFunctionsDict [ fieldName ] = str ( func ) # Do we have any aggregation at all? hasAggregation = False for v in aggregationPeriod . values ( ) : if v != 0 : hasAggregation = True break # Convert the aggFunctionsDict to a list aggFunctionList = aggFunctionsDict . items ( ) aggregationInfo = dict ( aggregationPeriod ) aggregationInfo [ 'fields' ] = aggFunctionList streamDef = copy . deepcopy ( modelDescription [ 'streamDef' ] ) streamDef [ 'aggregation' ] = copy . deepcopy ( aggregationInfo ) return streamDef", "comment": "Generate stream definition based on"}
{"lang": "python", "code": "def add_layer ( self , label , change_layer = True ) : self . layer_stack . <mask> ( self . last_layer ( ) + 1 , label ) if change_layer : self . set_current_layer ( self . last_layer ( ) ) return None", "comment": "Add new mesh layer to the end of the stack"}
{"lang": "python", "code": "def video ( request , video_id ) : # Check video availability # Available states are: processing api = Api ( ) api . authenticate ( ) availability = api . check_upload_status ( video_id ) if availability is not True : # Video is not available video = Video . objects . filter ( video_id = video_id ) . get ( ) <mask> = availability [ \"upload_state\" ] # Add additional states here. I'm not sure what states are available if state == \"failed\" or state == \"rejected\" : return render_to_response ( \"django_youtube/video_failed.html\" , { \"video\" : video , \"video_id\" : video_id , \"message\" : _ ( \"Invalid video.\" ) , \"availability\" : availability } , context_instance = RequestContext ( request ) ) else : return render_to_response ( \"django_youtube/video_unavailable.html\" , { \"video\" : video , \"video_id\" : video_id , \"message\" : _ ( \"This video is currently being processed\" ) , \"availability\" : availability } , context_instance = RequestContext ( request ) ) video_params = _video_params ( request , video_id ) return render_to_response ( \"django_youtube/video.html\" , video_params , context_instance = RequestContext ( request ) )", "comment": "Displays a video in an embed player"}
{"lang": "python", "code": "def set_summary_trigger ( self , name , trigger ) : return callBigDlFunc ( self . bigdl_type , \"summarySetTrigger\" , self . value , <mask> , trigger )", "comment": "Set the interval of recording for each indicator ."}
{"lang": "python", "code": "def unified_job_template_options ( method ) : jt_dec = click . option ( '--job-template' , type = types . Related ( 'job_template' ) , help = 'Use this job template as unified_job_template field' ) prj_dec = click . option ( '--project' , type = types . Related ( 'project' ) , help = 'Use this project as unified_job_template field' ) inv_src_dec = click . option ( '--inventory-source' , type = <mask> . Related ( 'inventory_source' ) , help = 'Use this inventory source as unified_job_template field' ) def ujt_translation ( _method ) : def _ujt_translation ( * args , * * kwargs ) : for fd in [ 'job_template' , 'project' , 'inventory_source' ] : if fd in kwargs and kwargs [ fd ] is not None : kwargs [ 'unified_job_template' ] = kwargs . pop ( fd ) return _method ( * args , * * kwargs ) return functools . wraps ( _method ) ( _ujt_translation ) return ujt_translation ( inv_src_dec ( prj_dec ( jt_dec ( method ) ) ) )", "comment": "Adds the decorators for all types of unified job templates and if the non - unified type is specified converts it into the unified_job_template kwarg ."}
{"lang": "java", "code": "@ Override public int peekBit ( ) throws AACException { int ret ; if ( bitsCached > 0 ) { ret = ( cache >> ( bitsCached - 1 ) ) & 1 ; } else { final int word = readCache ( true ) ; ret = ( <mask> >> WORD_BITS - 1 ) & 1 ; } return ret ; }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "public static < T extends Number > ErrorMessageFactory shouldBeEqual ( T actual , T expected , Offset < T > offset , T difference ) { return new ShouldBeEqualWithinOffset ( actual , expected , <mask> , difference ) ; }", "comment": "Creates a new <code > {"}
{"lang": "java", "code": "public void deleteFile ( String fileId ) { URI url = Urls . apiFile ( fileId ) ; RequestHelper requestHelper = getRequestHelper ( ) ; requestHelper . executeCommand ( new HttpDelete ( <mask> ) , true ) ; }", "comment": "Marks a file as deleted ."}
{"lang": "java", "code": "static String extractOperatorAssemblyInformation ( String source , boolean skipFirst ) { String [ ] uncleanTraces = source . split ( \"\\n\" ) ; final <mask> < String > traces = Stream . of ( uncleanTraces ) . map ( String :: trim ) . filter ( s -> ! s . isEmpty ( ) ) . skip ( skipFirst ? 1 : 0 ) . collect ( Collectors . toList ( ) ) ; if ( traces . isEmpty ( ) ) { return \"[no operator assembly information]\" ; } int i = 0 ; while ( i < traces . size ( ) && ! isUserCode ( traces . get ( i ) ) ) { i ++ ; } String apiLine ; String userCodeLine ; if ( i == 0 ) { //no line was a reactor API line apiLine = \"\" ; userCodeLine = traces . get ( 0 ) ; } else if ( i == traces . size ( ) ) { //we skipped ALL lines, meaning they're all reactor API lines. We'll fully display the last one apiLine = \"\" ; userCodeLine = traces . get ( i - 1 ) . replaceFirst ( \"reactor.core.publisher.\" , \"\" ) ; } else { //currently on user code line, previous one is API apiLine = traces . get ( i - 1 ) ; userCodeLine = traces . get ( i ) ; } //now we want something in the form \"Flux.map \u21e2 user.code.Class.method(Class.java:123)\" if ( apiLine . isEmpty ( ) ) return userCodeLine ; int linePartIndex = apiLine . indexOf ( ' ' ) ; if ( linePartIndex > 0 ) { apiLine = apiLine . substring ( 0 , linePartIndex ) ; } apiLine = apiLine . replaceFirst ( \"reactor.core.publisher.\" , \"\" ) ; return apiLine + \" \u21e2 \" + u erCodeLine;  }", "comment": "Extract operator information out of an assembly stack trace in { @link String } form ( see { @link Traces#callSiteSupplierFactory } ) which potentially has a header line that one can skip by setting { @code skipFirst } to { @code true } . <p > Most operators will result in a line of the form { @code Flux . map \u21e2 user . code . Class . method ( Class . java : 123 ) } that is : <ol > <li > The top of the stack is inspected for Reactor API references and the deepest one is kept since multiple API references generally denote an alias operator . ( eg . { @code Flux . map } ) < / li > <li > The next stacktrace element is considered user code and is appended to the result with a { @code \u21e2 } separator . ( eg . { @code \u21e2 user . code . Class . method ( Class . java : 123 ) } ) < / li > <li > If no user code is found in the sanitized stack then the API reference is outputed in the later format only . < / li > <li > If the sanitized stack is empty returns { @code [ no operator assembly information ] } < / li > < / ol >"}
{"lang": "java", "code": "private Node < K , V > lookup ( final Object data , final int index ) { <mask> < K , V > rval = null ; Node < K , V > node = rootNode [ index ] ; while ( node != null ) { int cmp = compare ( Node . NO_CHANGE , data , node . getStatus ( ) , node . getData ( index ) , index ) ; if ( cmp == 0 ) { rval = node ; break ; } else { node = ( cmp < 0 ) ? node . getLeft ( index ) : node . getRight ( index ) ; } } return rval ; }", "comment": "do the actual lookup of a piece of data"}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) public boolean result ( final Object iRecord ) { final ODocument record = ( ( OIdentifiable ) iRecord ) . getRecord ( ) ; if ( isUpdateEdge ( ) && ! isRecordInstanceOf ( iRecord , \"E\" ) ) { throw new OCommandExecutionException ( \"Using UPDATE EDGE on a record that is not an instance of E\" ) ; } if ( compiledFilter != null ) { // ADDITIONAL FILTERING\r if ( ! ( Boolean ) compiledFilter . evaluate ( record , null , context ) ) return false ; } parameters . reset ( ) ; returnHandler . beforeUpdate ( record ) ; boolean updated = handleContent ( <mask> ) ; updated |= handleMerge ( record ) ; updated |= handleSetEntries ( record ) ; updated |= handleIncrementEntries ( record ) ; updated |= handleAddEntries ( record ) ; updated |= handlePutEntries ( record ) ; updated |= handleRemoveEntries ( record ) ; if ( updated ) { handleUpdateEdge ( record ) ; record . setDirty ( ) ; record . save ( ) ; returnHandler . afterUpdate ( record ) ; this . updated = true ; } return true ; }", "comment": "Update current record ."}
{"lang": "java", "code": "public static boolean validPercentHexOctetsString ( String percentHexOctetsString ) { if ( percentHexOctetsString == null ) return <mask> ; Matcher m = VALID_PERCENT_HEX_OCTETS_PATTERN . matcher ( percentHexOctetsString ) ; return m . matches ( ) ; }", "comment": "Check that the given string is a valid percentHexOctets string . The string is considered valid if it only contains a sequence of % prefixed two character strings where each two character string is composed only of US - ASCII digits and upper - or lower - case A - F . <p > For example : %31%32 or %7b%7d%7E"}
{"lang": "java", "code": "private boolean checkValidity ( final StoreKey key ) throws IndyDataException { if ( catalog . isValidationEnabled ( key ) ) { try { final RemoteRepository validationRepo = catalog . createValidationRemote ( key ) ; if ( validationRepo == null ) { logger . info ( \"No validation repository was created: assuming {} is valid.\" , key ) ; return true ; } String path = catalog . getRemoteValidationPath ( key ) ; if ( path == null ) { path = PathUtils . ROOT ; } logger . debug ( \"\\n\\n\\n\\n\\n[AutoProx] Checking path: {} under remote URL: {}\" , path , validationRepo . getUrl ( ) ) ; boolean result = false ; try { <mask> = transferManager . exists ( new ConcreteResource ( LocationUtils . toLocation ( validationRepo ) , path ) ) ; } catch ( final TransferException e ) { logger . warn ( \"[AutoProx] Cannot connect to target repository: '{}'. Reason: {}\" , validationRepo , e . getMessage ( ) ) ; logger . debug ( \"[AutoProx] exception from validation attempt for: \" + validationRepo , e ) ; } logger . debug ( \"Validation result for: {} is: {}\" , validationRepo , result ) ; return result ; } catch ( final AutoProxRuleException e ) { throw new IndyDataException ( \"[AUTOPROX] Failed to create new group from factory matching: '%s'. Reason: %s\" , e , key , e . getMessage ( ) ) ; } } return true ; }", "comment": "Validates the remote connection produced from rule - set for given key for a remote repo or group containing a remote . If :"}
{"lang": "java", "code": "public Joiner replaceEmptyStringWith ( String forEmpty ) { return new Joiner ( separator , prefix , suffix , trim , ignoreNull , <mask> , forNull , forEmpty ) ; }", "comment": "Returns a new { @code Joiner } that will behave as this one except that it will replace empty input { @code String } s with the specified value ."}
{"lang": "java", "code": "public static void checkTracerName ( String tracerName , NotificationSource notificationSource ) throws IllegalArgumentException { if ( tracerName . compareTo ( \"\" ) == 0 ) { // This is root\r return ; } // String[] splitName = tracerName.split(\"\\\\.\");\r StringTokenizer stringTokenizer = new StringTokenizer ( tracerName , \".\" , true ) ; int fqdnPartIndex = 0 ; // if(splitName.length==0)\r // {\r // throw new IllegalArgumentException(\"Passed tracer:\" + tracerName +\r // \", name for source: \" + notificationSource + \", is illegal\");\r // }\r String lastToken = null ; while ( stringTokenizer . hasMoreTokens ( ) ) { String token = stringTokenizer . nextToken ( ) ; if ( lastToken == null ) { // this is start\r lastToken = token ; } if ( lastToken . compareTo ( token ) == 0 && token . compareTo ( \".\" ) == 0 ) { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; } if ( token . compareTo ( \".\" ) != 0 ) { for ( int charIndex = 0 ; charIndex < token . length ( ) ; charIndex ++ ) { Character c = token . charAt ( charIndex ) ; if ( Character . isLetter ( c ) || Character . isDigit ( c ) ) { // Its ok?\r } else { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \" Token[\" + token + \"], name for source: \" + notificationSource + \", is illegal, contains illegal character: \" + charIndex ) ; } } fqdnPartIndex ++ ; } lastToken = <mask> ; } if ( lastToken . compareTo ( \".\" ) == 0 ) { throw new IllegalArgumentException ( \"Passed tracer:\" + tracerName + \", name for source: \" + notificationSource + \", is illegal\" ) ; } }", "comment": "This checks if tracer name is ok . It must not be null ;"}
{"lang": "java", "code": "protected AxisType getAxisType ( NetcdfDataset ncDataset , VariableEnhanced v ) { String <mask> = v . getShortName ( ) ; if ( name . equals ( \"time\" ) ) { return AxisType . Time ; } if ( name . equals ( \"lat\" ) ) { return AxisType . Lat ; } if ( name . equals ( \"lon\" ) ) { return AxisType . Lon ; } // if (name.equals(\"xLeo\") ) return AxisType.GeoX;\r // if (name.equals(\"yLeo\") ) return AxisType.GeoY;\r if ( name . equals ( \"alt\" ) ) { return AxisType . Height ; } return null ; }", "comment": "_more_"}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) public static < R > R callStaticMethod ( Class < ? > clazz , String methodName , ClassParameter < ? > ... classParameters ) { try { Class < ? > [ ] classes = ClassParameter . getClasses ( classParameters ) ; Object [ ] values = ClassParameter . getValues ( classParameters ) ; Method method = clazz . getDeclaredMethod ( methodName , <mask> ) ; method . setAccessible ( true ) ; if ( ! Modifier . isStatic ( method . getModifiers ( ) ) ) { throw new IllegalArgumentException ( method + \" is not static\" ) ; } return ( R ) method . invoke ( null , values ) ; } catch ( InvocationTargetException e ) { if ( e . getTargetException ( ) instanceof RuntimeException ) { throw ( RuntimeException ) e . getTargetException ( ) ; } if ( e . getTargetException ( ) instanceof Error ) { throw ( Error ) e . getTargetException ( ) ; } throw new RuntimeException ( e . getTargetException ( ) ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( \"no such method \" + clazz + \".\" + methodName , e ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }", "comment": "Reflectively call a static method on a class ."}
{"lang": "java", "code": "public static DocumentBuilderFactory newSecureDocumentBuilderFactory ( ) { try { DocumentBuilderFactory result = DocumentBuilderFactory . newInstance ( ) ; result . setFeature ( \"http://javax.xml.XMLConstants/feature/secure-processing\" , true ) ; result . setFeature ( \"http://xml.org/sax/features/external-general-entities\" , false ) ; result . setFeature ( \"http://xml.org/sax/features/external-parameter-entities\" , false ) ; result . setNamespaceAware ( true ) ; result . setValidating ( <mask> ) ; return result ; } catch ( ParserConfigurationException e ) { throw new IllegalStateException ( e ) ; } }", "comment": "Return a new factory for building XML documents that is configured to operate securely . The factory also supports <a href = http : // www . w3 . org / TR / REC - xml - names / > XML namespaces< / a > and validation ."}
{"lang": "java", "code": "@ Override public <mask> countClusterElements ( final String iClusterName ) { checkSecurity ( ORule . ResourceGeneric . CLUSTER , ORole . PERMISSION_READ , iClusterName ) ; checkIfActive ( ) ; final int clusterId = getClusterIdByName ( iClusterName ) ; if ( clusterId < 0 ) throw new IllegalArgumentException ( \"Cluster '\" + iClusterName + \"' was not found\" ) ; return getStorage ( ) . count ( clusterId ) ; }", "comment": "{"}
{"lang": "java", "code": "public static Result status ( int <mask> , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }", "comment": "Generates a simple result with json content and UTF8 encoding ."}
{"lang": "java", "code": "@ Override public void getCommentsByUser ( SocializeSession session , long userId , CommentListener listener ) { String endpoint = \"/user/\" + userId + ENDPOINT ; listAsync ( <mask> , endpoint , listener ) ; }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "private String identifyDialect ( String name ) { String unified = null ; if ( name != null ) { if ( name . toLowerCase ( ) . contains ( \"postgres\" ) ) { unified = \"postgresql\" ; } else if ( name . toLowerCase ( ) . contains ( \"mysql\" ) ) { unified = \"mysql\" ; } else if ( name . toLowerCase ( ) . contains ( \"mariadb\" ) ) { unified = \"mariadb\" ; } else if ( name . toLowerCase ( ) . contains ( \"db2\" ) ) { unified = \"db2\" ; } else if ( name . toLowerCase ( ) . contains ( \"hsql\" ) || name . toLowerCase ( ) . contains ( \"hypersonic\" ) ) { unified = \"hsql\" ; } else if ( name . toLowerCase ( ) . contains ( \"h2\" ) ) { unified = \"h2\" ; } else if ( name . toLowerCase ( ) . contains ( \"oracle\" ) ) { unified = \"oracle\" ; } else if ( <mask> . toLowerCase ( ) . contains ( \"microsoft\" ) ) { unified = \"mssql\" ; } else if ( name . toLowerCase ( ) . contains ( \"jconnect\" ) ) { unified = \"sybase\" ; } } EjbLogger . EJB3_TIMER_LOGGER . debugf ( \"Check dialect for '%s', result is '%s'\" , name , unified ) ; return unified ; }", "comment": "Use the given name and check for different database types to have a unified identifier for the dialect"}
{"lang": "java", "code": "public String getIdBasedJsObject ( final String functionName , final Collection < String > onlyForTagNames ) { // \"{\" should not be changed to '{' if passing arg in constructor of // StringBuilder final StringBuilder jsObjectBuilder = new StringBuilder ( \"{\" ) ; final Set < String > appendedValues = new HashSet <> ( ) ; loopThroughAllNestedChildren ( child -> { final String tagName = child . getTagName ( ) ; if ( onlyForTagNames . contains ( tagName ) ) { final AbstractAttribute idAttr = child . getAttributeByName ( AttributeNameConstants . ID ) ; final AbstractAttribute typeAttr = child . getAttributeByName ( AttributeNameConstants . TYPE ) ; if ( idAttr != null ) { final String idAttrValue = idAttr . getAttributeValue ( ) ; if ( ! appendedValues . contains ( idAttrValue ) ) { final String docById = functionName + \"('\" + idAttrValue + \"')\" ; if ( typeAttr != null ) { final String typeAttrValue = typeAttr . getAttributeValue ( ) ; if ( Type . CHECKBOX . equals ( typeAttrValue ) || Type . RADIO . equals ( typeAttrValue ) ) { jsObjectBuilder . append ( idAttrValue ) . append ( ' ' ) . append ( docById ) . append ( \".checked,\" ) ; appendedValues . add ( idAttrValue ) ; } else { jsObjectBuilder . append ( idAttrValue ) . append ( ' ' ) . append ( docById ) . append ( \".value,\" ) ; appendedValues . add ( idAttrValue ) ; } } else { jsObjectBuilder . append ( idAttrValue ) . append ( ' ' ) . append ( docById ) . append ( \".value,\" ) ; appendedValues . add ( idAttrValue ) ; } } } } return true ; } , false , this ) ; return jsObjectBuilder . replace ( jsObjectBuilder . <mask> ( ) - 1 , jsObjectBuilder . length ( ) , \"}\" ) . toString ( ) ; }", "comment": "prepares and gets the js object for the given tag names under this form tag . This js object may be used to return in onsubmit attribute ."}
{"lang": "java", "code": "public MethodlessRouter < T > addRouteFirst ( String pathPattern , T target ) { <mask> . addRoute ( pathPattern , target ) ; return this ; }", "comment": "Adds route to the first section ."}
{"lang": "java", "code": "<mask> NumericType getValue ( ) { Term firstArgValue = arguments [ 0 ] . getValue ( ) ; // Check that the argument to operate on is a numeric values. if ( ! firstArgValue . isNumber ( ) ) { throw new IllegalStateException ( \"instantiation_error, 'arithmetic/2' expects numeric arguments, but the first argument is non-numeric.\" ) ; } return evaluate ( ( NumericType ) firstArgValue ) ; }", "comment": "Gets the actual value of a term which is a numeric type equal in value to the arithmetic operator applied to its argument . This method checks that the argument produces a value which is fully instantiated and numeric when its { @link Term#getValue () } methods is invoked ."}
{"lang": "java", "code": "public static Throwable getOnlyCause ( Collection < Message > messages ) { Throwable onlyCause = null ; for ( Message message : messages ) { Throwable messageCause = <mask> . getCause ( ) ; if ( messageCause == null ) { continue ; } if ( onlyCause != null && ! ThrowableEquivalence . INSTANCE . equivalent ( onlyCause , messageCause ) ) { return null ; } onlyCause = messageCause ; } return onlyCause ; }", "comment": "Returns the cause throwable if there is exactly one cause in {"}
{"lang": "java", "code": "public final < X > TypeToken < T > where ( TypeParameter < X > typeParam , <mask> < X > typeArg ) { return where ( typeParam , of ( typeArg ) ) ; }", "comment": "Returns a new { @code TypeToken } where type variables represented by { @code typeParam } are substituted by { @code typeArg } . For example it can be used to construct { @code Map<K V > } for any { @code K } and { @code V } type :"}
{"lang": "java", "code": "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) private static Set < Binder > toBinders ( Map < Key < ? > , Binding < ? > > bindings ) { Set < Binder > binders = new HashSet <> ( ) ; for ( Map . Entry < Key < ? > , Binding < ? > > entry : bindings . entrySet ( ) ) { Key < ? > <mask> = entry . getKey ( ) ; Binding < ? > binding = entry . getValue ( ) ; Object source = binding . getSource ( ) ; if ( ! ( source instanceof ElementSource ) ) { // Things like the Injector itself don't have an ElementSource. if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( \"Adding binding: key={}, source={}\" , key , source ) ; } binders . add ( new GuiceBinder ( key , binding ) ) ; continue ; } ElementSource element = ( ElementSource ) source ; List < String > names = element . getModuleClassNames ( ) ; String name = names . get ( 0 ) ; // Skip everything that is declared in a JerseyModule try { Class < ? > module ; // Attempt to load the classes via the context class loader first, in order to support // environments that enforce tighter constraints on class loading (such as in an OSGi container) ClassLoader classLoader = Thread . currentThread ( ) . getContextClassLoader ( ) ; if ( classLoader != null ) { module = classLoader . loadClass ( name ) ; } else { module = Class . forName ( name ) ; } if ( JerseyModule . class . isAssignableFrom ( module ) ) { if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( \"Ignoring binding {} in {}\" , key , module ) ; } continue ; } } catch ( ClassNotFoundException err ) { // Some modules may not be able to be instantiated directly here as a class if we're running // in a container that enforcer tighter class loader constraints (such as the // org.ops4j.peaberry.osgi.OSGiModule Guice module when running in an OSGi container), // so we're only logging a warning here instead of throwing a hard exception if ( LOG . isWarnEnabled ( ) ) { LOG . warn ( \"Unavailable to load class in order to validate module: name={}\" , name ) ; } } binders . add ( new GuiceBinder ( key , binding ) ) ; } return binders ; }", "comment": "Turns the given Guice {"}
{"lang": "java", "code": "private void generatePageScopedVariables ( JasperTagInfo tagInfo ) { // \"normal\" attributes TagAttributeInfo [ ] attrInfos = tagInfo . getAttributes ( ) ; for ( int i = 0 ; i < attrInfos . length ; i ++ ) { String attrName = attrInfos [ i ] . getName ( ) ; out . printil ( \"if( \" + toGetterMethod ( attrName ) + \" != null ) {\" ) ; out . pushIndent ( ) ; <mask> . printin ( \"_jspx_page_context.setAttribute(\" ) ; out . print ( quote ( attrName ) ) ; out . print ( \", \" ) ; out . print ( toGetterMethod ( attrName ) ) ; out . println ( \");\" ) ; if ( attrInfos [ i ] . isDeferredValue ( ) ) { // If the attribute is a deferred value, also set it to an EL // variable of the same name. out . printin ( \"org.apache.jasper.runtime.PageContextImpl.setValueVariable(\" ) ; out . print ( \"_jspx_page_context, \" ) ; out . print ( quote ( attrName ) ) ; out . print ( \", \" ) ; out . print ( toGetterMethod ( attrName ) ) ; out . println ( \");\" ) ; } if ( attrInfos [ i ] . isDeferredMethod ( ) ) { // If the attribute is a deferred method, set a wrapped // ValueExpression to an EL variable of the same name. out . printin ( \"org.apache.jasper.runtime.PageContextImpl.setMethodVariable(\" ) ; out . print ( \"_jspx_page_context, \" ) ; out . print ( quote ( attrName ) ) ; out . print ( \", \" ) ; out . print ( toGetterMethod ( attrName ) ) ; out . println ( \");\" ) ; } out . popIndent ( ) ; out . println ( \"}\" ) ; } // Expose the Map containing dynamic attributes as a page-scoped var if ( tagInfo . hasDynamicAttributes ( ) ) { out . printin ( \"_jspx_page_context.setAttribute(\\\"\" ) ; out . print ( tagInfo . getDynamicAttributesMapName ( ) ) ; out . print ( \"\\\", _jspx_dynamic_attrs);\" ) ; } }", "comment": "/ * Creates a page - scoped variable for each declared tag attribute . Also if the tag accepts dynamic attributes a page - scoped variable is made available for each dynamic attribute that was passed in ."}
{"lang": "java", "code": "public void markNodesInside ( Vector < BoxNode > list , boolean full ) { for ( Iterator < BoxNode > it = list . iterator ( ) ; it . hasNext ( ) ; ) { BoxNode node = it . next ( ) ; if ( full ) { if ( node != this && this . contentEncloses ( node ) && ( node . isRootNode ( ) || ! this . contentEncloses ( node . nearestParent ) ) ) { node . nearestParent = this ; } } else { if ( node != this && this . visuallyEncloses ( node ) && ( node . isRootNode ( ) || ! this . visuallyEncloses ( node . nearestParent ) ) ) { <mask> . nearestParent = this ; } } } }", "comment": "Takes a list of nodes and selects the nodes that are located directly inside of this node s box . The {"}
{"lang": "java", "code": "public final Flux < T > doOnError ( Predicate < ? super Throwable > predicate , final Consumer < ? <mask> Throwable > onError ) { Objects . requireNonNull ( predicate , \"predicate\" ) ; return doOnError ( t -> { if ( predicate . test ( t ) ) { onError . accept ( t ) ; } } ) ; }", "comment": "Add behavior ( side - effect ) triggered when the { @link Flux } completes with an error matching the given exception . <p > <img class = marble src = doc - files / marbles / doOnErrorWithPredicateForFlux . svg alt = >"}
{"lang": "java", "code": "@ Override public void writeExternal ( ObjectOutput out ) throws IOException { out . writeObject ( parentSbbEntityID ) ; out . writeUTF ( parentChildRelation ) ; <mask> . writeUTF ( childID ) ; }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "public static int timevalueToTimecodeFrame ( TrakBox timecodeTrack , RationalLarge <mask> , int movieTimescale ) { TimecodeSampleEntry se = ( TimecodeSampleEntry ) timecodeTrack . getSampleEntries ( ) [ 0 ] ; return ( int ) ( ( 2 * tv . multiplyS ( se . getTimescale ( ) ) / se . getFrameDuration ( ) ) + 1 ) / 2 ; }", "comment": "Converts timevalue to frame number based on timecode track"}
{"lang": "java", "code": "public MultiPartSpecBuilder charset ( String charset ) { Validate . notEmpty ( charset , \"Charset cannot be empty\" ) ; if ( content instanceof byte [ ] || <mask> instanceof InputStream ) { throw new IllegalArgumentException ( \"Cannot specify charset input streams or byte arrays.\" ) ; } this . charset = charset ; return this ; }", "comment": "Specify the charset for this charset ."}
{"lang": "java", "code": "public T headers ( final Map < String , String > headersToSet ) { <mask> . putAll ( headersToSet ) ; return _this ( ) ; }", "comment": "Sets headers ."}
{"lang": "java", "code": "public long longIncrement ( String key , long number ) { long val = getLong ( <mask> , 0 ) ; val += number ; setv ( key , val ) ; return val ; }", "comment": "\u6307\u5b9akey\u8fdb\u884c\u589e\u64cd\u4f5c\uff0c\u5e76\u8fd4\u56de\u7ed3\u679c"}
{"lang": "java", "code": "public void addVariableAttribute ( String varName , Attribute att ) { if ( ! defineMode ) throw new UnsupportedOperationException ( \"not in define mode\" ) ; if ( ! N3iosp . isValidNetcdfObjectName ( att . getShortName ( ) ) ) { String attName = N3iosp . makeValidNetcdfObjectName ( att . getShortName ( ) ) ; log . <mask> ( \"illegal netCDF-3 attribute name= \" + att . getShortName ( ) + \" change to \" + attName ) ; att = new Attribute ( attName , att . getValues ( ) ) ; } Variable v = rootGroup . findVariable ( varName ) ; if ( null == v ) throw new IllegalArgumentException ( \"addVariableAttribute variable name not found = <\" + varName + \">\" ) ; v . addAttribute ( att ) ; }", "comment": "Add an attribute to the named Variable . Must be in define mode ."}
{"lang": "java", "code": "public GitBranchResponse branch ( File repositoryPath ) throws IOException , JavaGitException { CheckUtilities . checkNullArgument ( repositoryPath , \"repository path\" ) ; IClient client = ClientManager . getInstance ( ) . getPreferredClient ( ) ; IGitBranch gitBranch = <mask> . getGitBranchInstance ( ) ; return gitBranch . branch ( repositoryPath ) ; }", "comment": "Does a basic git - branch without any options ."}
{"lang": "java", "code": "public void registerClass ( Class c , FSTConfiguration conf ) { if ( getIdFromClazz ( c ) != <mask> . MIN_VALUE ) { return ; } registerClassNoLookup ( c , null , conf ) ; }", "comment": "for read = > always increase handle ( wg . replaceObject )"}
{"lang": "java", "code": "public static String join ( final Collection collection , final char separator ) { if ( collection == null ) { return null ; } if ( collection . size ( ) == 0 ) { return StringPool . EMPTY ; } final StringBuilder sb = new StringBuilder ( collection . size ( ) * 16 ) ; final Iterator it = collection . iterator ( ) ; for ( int i = 0 ; i < collection . size ( ) ; i ++ ) { if ( i > 0 ) { sb . <mask> ( separator ) ; } sb . append ( it . next ( ) ) ; } return sb . toString ( ) ; }", "comment": "Joins an collection of objects into one string with separator ."}
{"lang": "java", "code": "static void checkOnlyPostParameters ( final String method , final Map parameterMap , final Set < String > onlyPostParameters ) { if ( ! \"POST\" . equals ( method ) ) { Set < String > <mask> = parameterMap . keySet ( ) ; for ( String onlyPostParameter : onlyPostParameters ) { if ( names . contains ( onlyPostParameter ) ) { FilterUtils . logException ( LOGGER , new IllegalArgumentException ( onlyPostParameter + \" parameter should only be used in POST requests\" ) ) ; } } } }", "comment": "Check that some parameters should only be in POST requests ( according to the configuration ) ."}
{"lang": "java", "code": "public int resample ( MediaSampled out , MediaSampled in ) { return VideoJNI . MediaResampler_resample ( swigCPtr , this , MediaSampled . getCPtr ( <mask> ) , out , MediaSampled . getCPtr ( in ) , in ) ; }", "comment": "Resample in to out based on the resampler parameters . <br > <br > Resamples the in media based on the parameters set when<br > this resampler was constructed . <br > <br >"}
{"lang": "java", "code": "@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setCtype ( Check . Ctype <mask> ) { this . ctype = value ; }", "comment": "Sets the value of the ctype property ."}
{"lang": "java", "code": "public static String getCenterName ( int center_id , int edition ) { String <mask> = ( edition == 1 ) ? getTableValue ( 1 , center_id ) : getTableValue ( 11 , center_id ) ; if ( result != null ) return result ; if ( center_id == 0 ) return \"WMO standard table\" ; return \"Unknown center=\" + center_id ; }", "comment": "Center name from table C - 1 or C - 11"}
{"lang": "java", "code": "private static < K , V > void copyColor ( final Node < K , V > from , final Node < K , V > to , final int index ) { if ( to != null ) { if ( from == null ) { // by default, make it black\r to . setBlack ( index ) ; } else { to . copyColor ( from , <mask> ) ; } } }", "comment": "copy the color from one node to another dealing with the fact that one or both nodes may in fact be null"}
{"lang": "java", "code": "static public FeatureType getFeatureType ( NetcdfDataset ds , String key , Formatter errlog ) { FeatureType ft = null ; String fts = getLiteral ( ds , <mask> , errlog ) ; if ( fts != null ) { ft = FeatureType . valueOf ( fts . toUpperCase ( ) ) ; if ( ( ft == null ) && ( errlog != null ) ) errlog . format ( \" Cant find Feature type %s from %s%n\" , fts , key ) ; } return ft ; }", "comment": "Turn the key into a String and return the corresponding featureType if any ."}
{"lang": "java", "code": "public void info ( String format , Object ... argArray ) { formatAndLog ( Log . INFO , <mask> , argArray ) ; }", "comment": "Log a message at level INFO according to the specified format and arguments . <p > <p > This form avoids superfluous object creation when the logger is disabled for the INFO level . < / p >"}
{"lang": "java", "code": "@ Override public void cleanSnapshots ( ) { File [ ] files = getFilesByType ( HollowProducer . Blob . Type . SNAPSHOT . <mask> ) ; if ( files == null || files . length <= numOfSnapshotsToKeep ) { return ; } sortByLastModified ( files ) ; for ( int i = numOfSnapshotsToKeep ; i < files . length ; i ++ ) { File file = files [ i ] ; boolean deleted = file . delete ( ) ; if ( ! deleted ) { log . warning ( \"Could not delete snapshot \" + file . getPath ( ) ) ; } } }", "comment": "Cleans snapshot to keep the last n snapshots . Defaults to 5 ."}
{"lang": "java", "code": "public void encode ( MediaPacket output , MediaSampled media ) { VideoJNI . Encoder_encode ( swigCPtr , this , MediaPacket . getCPtr ( output ) , <mask> , MediaSampled . getCPtr ( media ) , media ) ; }", "comment": "Encode the given Media using this encoder . <br > <br > Callers should call this repeatedly on a media object ntil<br > we consume all the media . <br > <br > Also when done in order to flush the encoder caller should call<br > this method passing in 0 ( null ) for media to tell the encoder<br > to flush any data it was keeping a hold of . <br > <br >"}
{"lang": "java", "code": "public long get ( K key ) { AtomicLong atomic = map . get ( key ) ; return atomic == null ? 0L : atomic . <mask> ( ) ; }", "comment": "Returns the value associated with {"}
{"lang": "java", "code": "public static double evaluate ( PlaneNormal3D_F64 plane , Point3D_F64 point ) { double dx = <mask> . x - plane . p . x ; double dy = point . y - plane . p . y ; double dz = point . z - plane . p . z ; return plane . n . x * dx + plane . n . y * dy + plane . n . z * dz ; }", "comment": "Applies the plane s definition to test to see if a point is one the plane"}
{"lang": "java", "code": "protected final void setFileExtensions ( final <mask> ... fileExtensions ) { if ( fileExtensions == null ) { this . fileExtensions = null ; } else { this . fileExtensions = new ArrayList < String > ( ) ; this . fileExtensions . addAll ( Arrays . asList ( fileExtensions ) ) ; } }", "comment": "Sets the list of file extensions . If no list exists internally it will be created if necessary ."}
{"lang": "java", "code": "private static boolean hasIdentityAndGeneratedAlwaysColumns ( List < IntrospectedColumn > columns ) { for ( IntrospectedColumn ic : columns ) { if ( ic . isGeneratedAlways ( ) || <mask> . isIdentity ( ) ) { return true ; } } return false ; }", "comment": "\u662f\u5426\u5b58\u5728\u81ea\u589e\u6216\u8005\u751f\u6210\u7684column"}
{"lang": "java", "code": "public final SimpleUriLocatorFactory addLocator ( final UriLocator ... locators ) { for ( final UriLocator locator : locators ) { uriLocators . <mask> ( locator ) ; } return this ; }", "comment": "Allow adding more than one uriLocators ."}
{"lang": "java", "code": "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > defaultIfEmpty ( T defaultItem ) { ObjectHelper . requireNonNull ( defaultItem , \"defaultItem is null\" ) ; <mask> switchIfEmpty ( just ( defaultItem ) ) ; }", "comment": "Returns an Observable that emits the items emitted by the source ObservableSource or a specified default item if the source ObservableSource is empty . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / defaultIfEmpty . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code defaultIfEmpty } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl >"}
{"lang": "java", "code": "public static int getArgumentsAndReturnSizes ( final String desc ) { int n = 1 ; int c = 1 ; while ( <mask> ) { char car = desc . charAt ( c ++ ) ; if ( car == ' ' ) { car = desc . charAt ( c ) ; return n << 2 | ( car == ' ' ? 0 : ( car == ' ' || car == ' ' ? 2 : 1 ) ) ; } else if ( car == ' ' ) { while ( desc . charAt ( c ++ ) != ' ' ) { } n += 1 ; } else if ( car == ' ' ) { while ( ( car = desc . charAt ( c ) ) == ' ' ) { ++ c ; } if ( car == ' ' || car == ' ' ) { n -= 1 ; } } else if ( car == ' ' || car == ' ' ) { n += 2 ; } else { n += 1 ; } } }", "comment": "Computes the size of the arguments and of the return value of a method ."}
{"lang": "java", "code": "public void addConnection ( Connection conn ) { if ( conn == null || conn . getSource ( ) == <mask> . getTarget ( ) ) { throw new IllegalArgumentException ( ) ; } if ( conn . getSource ( ) == this ) { sourceConnections . add ( conn ) ; firePropertyChange ( SOURCE_CONNECTIONS_PROP , null , conn ) ; } else if ( conn . getTarget ( ) == this ) { targetConnections . add ( conn ) ; firePropertyChange ( TARGET_CONNECTIONS_PROP , null , conn ) ; } }", "comment": "Add an incoming or outgoing connection to this vertex ."}
{"lang": "java", "code": "@ Override public final void replicate ( final Map < String , <mask> > pAddParams ) throws Exception { Writer htmlWriter = ( Writer ) pAddParams . get ( \"htmlWriter\" ) ; try { //URL must be String urlSourceStr = \"https://\" + ( String ) pAddParams . get ( \"urlSource\" ) ; if ( urlSourceStr == null || urlSourceStr . length ( ) < 10 ) { throw new ExceptionWithCode ( ExceptionWithCode . WRONG_PARAMETER , \"Where is no urlSource!!!\" ) ; } URL url = new URL ( urlSourceStr ) ; String authMethod = ( String ) pAddParams . get ( \"authMethod\" ) ; if ( \"base\" . equals ( authMethod ) ) { final String userName = ( String ) pAddParams . get ( \"userName\" ) ; final String userPass = ( String ) pAddParams . get ( \"userPass\" ) ; Authenticator . setDefault ( new Authenticator ( ) { @ Override protected PasswordAuthentication getPasswordAuthentication ( ) { return new PasswordAuthentication ( userName , userPass . toCharArray ( ) ) ; } } ) ; } else if ( \"form\" . equals ( authMethod ) ) { CookieManager cookieManager = new CookieManager ( ) ; CookieHandler . setDefault ( cookieManager ) ; cookieManager . setCookiePolicy ( CookiePolicy . ACCEPT_ALL ) ; requestCookiesGet ( pAddParams ) ; authForm ( pAddParams , cookieManager ) ; } Map < String , Integer > classesCounts = makeJob ( url , pAddParams ) ; if ( htmlWriter != null ) { String statusString = \", replication has been done.\" ; htmlWriter . write ( \"<h4>\" + new Date ( ) . toString ( ) + statusString + \"</h4>\" ) ; pAddParams . put ( \"statusString\" , new Date ( ) . toString ( ) + \", \" + ReplicatorXmlHttp . class . getSimpleName ( ) + statusString ) ; this . logger . info ( null , ReplicatorXmlHttp . class , statusString ) ; htmlWriter . write ( \"<table>\" ) ; htmlWriter . write ( \"<tr><th style=\\\"padding: 5px;\\\">Class</th><th style=\\\"padding: 5px;\\\">Total records</th></tr>\" ) ; for ( Map . Entry < String , Integer > entry : classesCounts . entrySet ( ) ) { htmlWriter . write ( \"<tr>\" ) ; htmlWriter . write ( \"<td>\" + entry . getKey ( ) + \"</td>\" ) ; htmlWriter . write ( \"<td>\" + entry . getValue ( ) + \"</td>\" ) ; htmlWriter . write ( \"</tr>\" ) ; } htmlWriter . write ( \"</table>\" ) ; } } catch ( ExceptionWithCode ex ) { if ( htmlWriter != null ) { htmlWriter . write ( new Date ( ) . toString ( ) + \", \" + ReplicatorXmlHttp . class . getSimpleName ( ) + \", \" + ex . getShortMessage ( ) ) ; } this . logger . error ( null , ReplicatorXmlHttp . class , ex . getShortMessage ( ) ) ; throw ex ; } }", "comment": "<p > It will clear current database then copy data from another with XML messages trough HTTPS connection . < / p >"}
{"lang": "java", "code": "@ OneToMany ( targetEntity = CommitteeProposalData . class , cascade = { CascadeType . ALL } ) @ JoinColumn ( name = \"COMMITTEE_PROPOSAL_LIST_COMM_0\" ) public <mask> < CommitteeProposalData > getCommitteeProposalList ( ) { return this . committeeProposalList ; }", "comment": "Gets the committee proposal list ."}
{"lang": "java", "code": "@ Override public int getTopBorder ( ) { Box <mask> = getBox ( ) ; if ( box instanceof ElementBox ) return ( ( ElementBox ) box ) . getBorder ( ) . top ; else return 0 ; }", "comment": "Obtains the top border of the box"}
{"lang": "java", "code": "public void setOperator ( int name , String textName , int priority , OpSymbol . Associativity associativity ) { // Check that the name of the operator is valid. // Check that the priority of the operator is valid. if ( ( priority < 0 ) || ( priority > 1200 ) ) { throw new IllegalArgumentException ( \"Operator priority must be between 0 and 1200 inclusive.\" ) ; } OpSymbol opSymbol = new OpSymbol ( name , textName , associativity , <mask> ) ; // Consult the defined operators to see if there are any already defined that match the name of the // new definition, otherwise a map of operators by fixity needs to be created. EnumMap < OpSymbol . Fixity , OpSymbol > operatorMap = operators . get ( textName ) ; // Check if the priority is non-zero in which case the operator is being added or redefined. if ( priority > 0 ) { if ( operatorMap == null ) { operatorMap = new EnumMap < OpSymbol . Fixity , OpSymbol > ( OpSymbol . Fixity . class ) ; operators . put ( textName , operatorMap ) ; } // Check if the operators fixity to see if further rules regarding simultaneous definition of post and // infix operators need to be applied. if ( opSymbol . isPostfix ( ) ) { // Postfix, so check if an infix definition already exists, which is not allowed. if ( operatorMap . containsKey ( OpSymbol . Fixity . In ) ) { throw new IllegalArgumentException ( \"Cannot define a postfix operator when an infix one with the same name already exists.\" ) ; } } else if ( opSymbol . isInfix ( ) ) { // Infix, so check if a postfix definition already exists, which is not allowed. if ( operatorMap . containsKey ( OpSymbol . Fixity . Post ) ) { throw new IllegalArgumentException ( \"Cannot define an infix operator when an postfix one with the same name already exists.\" ) ; } } // Add the operator to the table replacing any previous definition of the same fixity. operatorMap . put ( opSymbol . getFixity ( ) , opSymbol ) ; } else { // The priority is zero, in which case the operator is to be removed. if ( ( operatorMap != null ) && opSymbol . isPrefix ( ) ) { // Remove it from the prefix table, if it exists there. operatorMap . remove ( OpSymbol . Fixity . Pre ) ; } else if ( ( operatorMap != null ) && ( opSymbol . isPostfix ( ) || opSymbol . isInfix ( ) ) ) { // Remove it from the postfix/infix table, if it exists there. operatorMap . remove ( OpSymbol . Fixity . Post ) ; operatorMap . remove ( OpSymbol . Fixity . In ) ; } } }", "comment": "Sets the priority and associativity of a named operator in this table . This method may be used to remove operators by some implementations through a special setting of the priority value . A priority value of zero will remove any existing operator matching the fixity of the one specified ( that is pre or post / infix ) . To be accepted the operator must have a priority between 0 and 1200 inclusive and can only be a postfix operator when an infix is not already defined with the same name and similarly for infix operators when a postfix operator is already defined ."}
{"lang": "java", "code": "public <mask> < E extends Enum < E > > Collector < E , ? , ImmutableSet < E > > toImmutableEnumSet ( ) { return ( Collector ) Accumulator . TO_IMMUTABLE_ENUM_SET ; }", "comment": "Returns a { @code Collector } that accumulates the input elements into a new { @code ImmutableSet } with an implementation specialized for enums . Unlike { @link ImmutableSet#toImmutableSet } the resulting set will iterate over elements in their enum definition order not encounter order ."}
{"lang": "java", "code": "public static void setExternalStorageState ( File <mask> , String state ) { storageState . put ( directory . toPath ( ) , state ) ; }", "comment": "Sets the { @link #getExternalStorageState ( File ) } for given directory ."}
{"lang": "java", "code": "public static < K , V > Map < K , V > filterEntries ( Map < K , V > unfiltered , Predicate < ? super <mask> < K , V > > entryPredicate ) { checkNotNull ( entryPredicate ) ; return ( unfiltered instanceof AbstractFilteredMap ) ? filterFiltered ( ( AbstractFilteredMap < K , V > ) unfiltered , entryPredicate ) : new FilteredEntryMap < K , V > ( checkNotNull ( unfiltered ) , entryPredicate ) ; }", "comment": "Returns a map containing the mappings in { @code unfiltered } that satisfy a predicate . The returned map is a live view of { @code unfiltered } ; changes to one affect the other ."}
{"lang": "java", "code": "<mask> static boolean contains ( EllipseRotated_F64 ellipse , double x , double y ) { return ( UtilEllipse_F64 . evaluate ( x , y , ellipse ) <= 1.0 ) ; }", "comment": "Tests to see if the provided point lies on or is contained inside the ellipse"}
{"lang": "java", "code": "public BufferedReader openBufferedStream ( ) throws IOException { Reader reader = openStream ( ) ; return ( <mask> instanceof BufferedReader ) ? ( BufferedReader ) reader : new BufferedReader ( reader ) ; }", "comment": "Opens a new { @link BufferedReader } for reading from this source . This method returns a new independent reader each time it is called ."}
{"lang": "java", "code": "public static <mask> getDefaultReplication ( FileSystem fs , Path path ) { return ( Short ) ( HadoopCompat . isVersion2x ( ) ? invoke ( GET_DEFAULT_REPLICATION_METHOD , fs , path ) : invoke ( GET_DEFAULT_REPLICATION_METHOD , fs ) ) ; }", "comment": "This method invokes getDefaultReplication () without path on Hadoop 1 and with Path on Hadoop 2 ."}
{"lang": "java", "code": "protected static boolean isSubDelimiter ( int c ) { <mask> c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' || c == ' ' ; }", "comment": "Indicates whether the given character is in the <i > sub - delims< / i > set ."}
{"lang": "java", "code": "@ Override public void cancelRepairRecord ( final ORecordId rid ) { if ( ! active ) return ; if ( rid . getClusterPosition ( ) < - 1 ) // SKIP TRANSACTIONAL RIDS return ; // REMOVE THE RECORD TO REPAIR if ( records . remove ( <mask> ) != null ) // REMOVED recordCanceled . incrementAndGet ( ) ; }", "comment": "Cancel the repair against a record because the update succeed ."}
{"lang": "java", "code": "@ XmlElementDecl ( namespace = \"http://www.immobilienscout24.de/immobilientransfer\" , name = \"Solarheizung\" , scope = BefeuerungsArtTyp . class ) public JAXBElement < <mask> > createBefeuerungsArtTypSolarheizung ( Object value ) { return new JAXBElement < Object > ( _BefeuerungsArtTypSolarheizung_QNAME , Object . class , BefeuerungsArtTyp . class , value ) ; }", "comment": "Create an instance of { @link JAXBElement } { @code < } { @link Object } { @code > }}"}
{"lang": "java", "code": "private static File checkCreateDirectory ( final <mask> dir ) throws IOException { if ( ! dir . mkdirs ( ) ) { throw new IOException ( MSG_CANT_CREATE + dir ) ; } return dir ; }", "comment": "Checks if directory can be created . Throws IOException if it cannot . <p > This actually creates directory ( and its ancestors ) ( as per { @link File#mkdirs () } } ) ."}
{"lang": "java", "code": "public boolean editMap ( ConfigurationHandler configurationHandler ) { String method = configurationHandler . getMethod ( ) . toUpperCase ( ) ; if ( configurationHandlerMap . containsKey ( Method . valueOf ( method ) ) ) { configurationHandlerMap . put ( Method . valueOf ( method ) , configurationHandler ) ; return <mask> ; } return false ; }", "comment": "Edit representation for method specified in sent parameter after controller calls for it ."}
{"lang": "java", "code": "public Owner getOwner ( ) throws MalformedElementException { Element <mask> = getLastChild ( root , \"owner\" ) ; //$NON-NLS-1$ if ( owner == null ) return null ; return new Owner ( owner ) ; }", "comment": "Returns this activelock s owner or <code > null< / code > if this active lock has no owner ."}
{"lang": "java", "code": "public static PropertyEditor getEditor ( final Class < ? > <mask> ) { PropertyEditor editor = findEditor ( type ) ; if ( editor == null ) { throw new RuntimeException ( \"No property editor for type: \" + type ) ; } return editor ; }", "comment": "Get a value editor for a given target type ."}
{"lang": "java", "code": "public static EventStream < ? > ticks0 ( Duration interval ) { return new EventStreamBase < Void > ( ) { private final Timer <mask> = FxTimer . createPeriodic0 ( interval , ( ) -> emit ( null ) ) ; @ Override protected Subscription observeInputs ( ) { timer . restart ( ) ; return timer :: stop ; } } ; }", "comment": "Returns an event stream that emits periodic <i > ticks< / i > . The first tick is emitted at time 0 . The returned stream may only be used on the JavaFX application thread ."}
{"lang": "java", "code": "public MediaType withParameter ( String attribute , String value ) { return withParameters ( <mask> , ImmutableSet . of ( value ) ) ; }", "comment": "<em > Replaces< / em > all parameters with the given attribute with a single parameter with the given value . If multiple parameters with the same attributes are necessary use { @link #withParameters ( String Iterable ) } . Prefer { @link #withCharset } for setting the { @code charset } parameter when using a { @link Charset } object ."}
{"lang": "java", "code": "private static boolean isProxyRequired ( ManagedClassSPI hostManagedClass , ManagedClassSPI dependencyManagedClass ) { if ( dependencyManagedClass != null ) { InstanceScope dependencyScope = dependencyManagedClass . getInstanceScope ( ) ; if ( InstanceScope . THREAD . equals ( dependencyScope ) ) { return InstanceScope . APPLICATION . equals ( hostManagedClass . getInstanceScope ( ) ) ; } return InstanceScope . SESSION . equals ( dependencyScope ) ; } return <mask> ; }", "comment": "Compare host and dependency managed classes scope and decide if scope proxy is required . Current implementation enable scope proxy only when dependency has { @link InstanceScope#SESSION } scope ."}
{"lang": "java", "code": "private void rule7 ( ) { if ( <mask> instanceof XsdSchema && attributesMap . containsKey ( FORM_TAG ) ) { throw new ParsingException ( XSD_TAG + \" element: The \" + FORM_TAG + \" attribute can only be present when the parent of the \" + xsdElementIsXsdSchema ) ; } }", "comment": "Asserts if the current object has a form attribute while being a direct child of the top level XsdSchema element which isn t allowed throwing an exception in that case ."}
{"lang": "java", "code": "private void checkVersionIntegrity ( ) { activeVersions . addAll ( allVersions ) ; for ( String version : allVersions ) { if ( ! apiIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , API_MODULE ) ; activeVersions . remove ( version ) ; } if ( ! implIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , IMPL_MODULE ) ; activeVersions . remove ( <mask> ) ; } if ( ! injectionIds . containsKey ( version ) ) { JSFLogger . ROOT_LOGGER . missingJSFModule ( version , INJECTION_MODULE ) ; activeVersions . remove ( version ) ; } } }", "comment": "make sure that each version has api impl and injection"}
{"lang": "java", "code": "private static void setParameterValueInternal ( PreparedStatement ps , int paramIndex , int sqlType , String typeName , Integer scale , Object inValue ) throws SQLException { if ( inValue == null ) { if ( sqlType == SqlTypeValue . TYPE_UNKNOWN ) { boolean useSetObject = false ; try { useSetObject = ( ps . getConnection ( ) . getMetaData ( ) . getDatabaseProductName ( ) . indexOf ( \"Informix\" ) != - 1 ) ; } catch ( Throwable ex ) { //                    logger.debug(\"Could not check database product name\", ex); } if ( useSetObject ) { ps . setObject ( paramIndex , null ) ; } else { ps . setNull ( paramIndex , Types . NULL ) ; } } else if ( typeName != null ) { ps . setNull ( paramIndex , sqlType , typeName ) ; } else { ps . setNull ( paramIndex , sqlType ) ; } } else { // inValue != null if ( inValue instanceof SqlTypeValue ) { ( ( SqlTypeValue ) inValue ) . setTypeValue ( ps , paramIndex , sqlType , typeName ) ; } else if ( ( sqlType == Types . VARCHAR ) || ( sqlType == - 9 ) ) { //-9 is Types.NVARCHAR in java 1.6 ps . setString ( paramIndex , inValue . toString ( ) ) ; } else if ( ( sqlType == Types . DECIMAL ) || ( sqlType == <mask> . NUMERIC ) ) { if ( inValue instanceof BigDecimal ) { ps . setBigDecimal ( paramIndex , ( BigDecimal ) inValue ) ; } else if ( scale != null ) { ps . setObject ( paramIndex , inValue , sqlType , scale ) ; } else { ps . setObject ( paramIndex , inValue , sqlType ) ; } } else if ( sqlType == Types . DATE ) { if ( inValue instanceof java . util . Date ) { if ( inValue instanceof java . sql . Date ) { ps . setDate ( paramIndex , ( java . sql . Date ) inValue ) ; } else { ps . setDate ( paramIndex , new java . sql . Date ( ( ( java . util . Date ) inValue ) . getTime ( ) ) ) ; } } else if ( inValue instanceof Calendar ) { Calendar cal = ( Calendar ) inValue ; ps . setDate ( paramIndex , new java . sql . Date ( cal . getTime ( ) . getTime ( ) ) , cal ) ; } else { ps . setObject ( paramIndex , inValue , Types . DATE ) ; } } else if ( sqlType == Types . TIME ) { if ( inValue instanceof java . util . Date ) { if ( inValue instanceof java . sql . Time ) { ps . setTime ( paramIndex , ( java . sql . Time ) inValue ) ; } else { ps . setTime ( paramIndex , new java . sql . Time ( ( ( java . util . Date ) inValue ) . getTime ( ) ) ) ; } } else if ( inValue instanceof Calendar ) { Calendar cal = ( Calendar ) inValue ; ps . setTime ( paramIndex , new java . sql . Time ( cal . getTime ( ) . getTime ( ) ) , cal ) ; } else { ps . setObject ( paramIndex , inValue , Types . TIME ) ; } } else if ( sqlType == Types . TIMESTAMP ) { if ( inValue instanceof java . util . Date ) { if ( inValue instanceof java . sql . Timestamp ) { ps . setTimestamp ( paramIndex , ( java . sql . Timestamp ) inValue ) ; } else { ps . setTimestamp ( paramIndex , new java . sql . Timestamp ( ( ( java . util . Date ) inValue ) . getTime ( ) ) ) ; } } else if ( inValue instanceof Calendar ) { Calendar cal = ( Calendar ) inValue ; ps . setTimestamp ( paramIndex , new java . sql . Timestamp ( cal . getTime ( ) . getTime ( ) ) , cal ) ; } else { ps . setObject ( paramIndex , inValue , Types . TIMESTAMP ) ; } } else if ( sqlType == SqlTypeValue . TYPE_UNKNOWN ) { if ( isStringValue ( inValue ) ) { ps . setString ( paramIndex , inValue . toString ( ) ) ; } else if ( isDateValue ( inValue ) ) { ps . setTimestamp ( paramIndex , new java . sql . Timestamp ( ( ( java . util . Date ) inValue ) . getTime ( ) ) ) ; } else if ( inValue instanceof Calendar ) { Calendar cal = ( Calendar ) inValue ; ps . setTimestamp ( paramIndex , new java . sql . Timestamp ( cal . getTime ( ) . getTime ( ) ) ) ; } else { // Fall back to generic setObject call without SQL type specified. ps . setObject ( paramIndex , inValue ) ; } } else { // Fall back to generic setObject call with SQL type specified. ps . setObject ( paramIndex , inValue , sqlType ) ; } } }", "comment": "Set the value for a parameter . The method used is based on the SQL type of the parameter and we can handle complex types like arrays and LOBs ."}
{"lang": "java", "code": "private String resolveBaseComponentName ( Class component ) { Class lastComponent = component ; while ( true ) { <mask> superClass = component . getSuperclass ( ) ; if ( superClass . equals ( Object . class ) ) { break ; } component = superClass ; if ( ! Modifier . isAbstract ( component . getModifiers ( ) ) ) { lastComponent = component ; } } return madpc . resolveBeanName ( lastComponent ) ; }", "comment": "Resolves the name of the last base non - abstract subclass for provided component . It iterates all subclasses up to the <code > Object< / cde > and declares the last non - abstract class as base component . Component name will be resolved from the founded base component ."}
{"lang": "java", "code": "@ XmlElementDecl ( namespace = \"http://www.immobilienscout24.de/immobilientransfer\" , name = \"Einfamilienhaus\" , scope = GrundstueckEmpfohleneNutzung . class ) public JAXBElement < Object > createGrundstueckEmpfohleneNutzungEinfamilienhaus ( Object <mask> ) { return new JAXBElement < Object > ( _GrundstueckEmpfohleneNutzungEinfamilienhaus_QNAME , Object . class , GrundstueckEmpfohleneNutzung . class , value ) ; }", "comment": "Create an instance of { @link JAXBElement } { @code < } { @link Object } { @code > }}"}
{"lang": "java", "code": "protected boolean matchFileExtension ( ) throws IOException { String fileNameExtension = FileNameUtil . getExtension ( getHeader ( ) . getFileName ( ) ) ; for ( String fileExtension : fileExtensions ) { if ( fileNameExtension . equalsIgnoreCase ( fileExtension ) ) { if ( ! allowFileExtensions ) { // extension matched and it is not allowed if ( breakOnError ) { throw new IOException ( \"Upload filename extension not allowed: \" + fileNameExtension ) ; } size = input . skipToBoundary ( ) ; return false ; } return true ; // extension matched and it is allowed. } } if ( allowFileExtensions ) { // extension is not one of the allowed ones. if ( breakOnError ) { throw new IOException ( \"Upload filename extension not allowed: \" + fileNameExtension ) ; } <mask> = input . skipToBoundary ( ) ; return false ; } return true ; }", "comment": "---------------------------------------------------------------- process"}
{"lang": "java", "code": "public String toQueryString ( Criteria criteria , CriteriaQueryBuilder queryBuilder ) { StringBuilder builder = new StringBuilder ( ) ; <mask> . append ( \"NEW \" ) ; builder . append ( clazz . getName ( ) ) ; builder . append ( ' ' ) ; builder . append ( projectionList . toQueryString ( criteria , queryBuilder ) ) ; builder . append ( ' ' ) ; return builder . toString ( ) ; }", "comment": "/ *"}
{"lang": "java", "code": "void moveouts ( State <mask> , State newState ) { Arc a ; assert old != newState ; while ( ( a = old . outs ) != null ) { cparc ( a , newState , a . to ) ; freearc ( a ) ; } }", "comment": "moveouts - move all out arcs of a state to another state"}
{"lang": "java", "code": "int visitFrameStart ( final int offset , final int numLocal , final int numStack ) { int frameLength = 3 + numLocal + numStack ; if ( currentFrame == null || currentFrame . length < frameLength ) { currentFrame = new int [ frameLength ] ; } currentFrame [ 0 ] = <mask> ; currentFrame [ 1 ] = numLocal ; currentFrame [ 2 ] = numStack ; return 3 ; }", "comment": "Starts the visit of a new stack map frame stored in { @link #currentFrame } ."}
{"lang": "java", "code": "public Object get ( Class cls , String property ) throws NoSuchFieldException { // Check that the field exists. if ( ! values . containsKey ( <mask> ) ) { throw new NoSuchFieldException ( \"The property, \" + property + \", does not exist on the underlying class.\" ) ; } // Try to find a matching property cached in this memento. return values . get ( property ) ; }", "comment": "Gets the value of the named property of the specified class ."}
{"lang": "java", "code": "Set < String > getReadNotices ( final PortletRequest req ) { final HashSet < String > rslt = new HashSet <> ( ) ; final PortletPreferences prefs = req . getPreferences ( ) ; final String [ ] ids = prefs . getValues ( READ_NOTIFICATION_IDS_PREFERENCE , new String [ 0 ] ) ; for ( int i = 0 ; i < ids . length ; i ++ ) { rslt . <mask> ( ids [ i ] ) ; } return rslt ; }", "comment": "/ * package - private"}
{"lang": "java", "code": "public Result serveStatic ( ) { Object renderable = new Renderable ( ) { @ Override public void render ( Context context , Result result ) { String fileName = getFileNameFromPathOrReturnRequestPath ( context ) ; URL url = getStaticFileFromAssetsDir ( fileName ) ; streamOutUrlEntity ( url , context , <mask> ) ; } } ; return Results . ok ( ) . render ( renderable ) ; }", "comment": "Serves resources from the assets directory of your application ."}
{"lang": "java", "code": "public String readUTF8 ( final int offset , final char [ ] charBuffer ) { int constantPoolEntryIndex = readUnsignedShort ( <mask> ) ; if ( offset == 0 || constantPoolEntryIndex == 0 ) { return null ; } return readUtf ( constantPoolEntryIndex , charBuffer ) ; }", "comment": "DontCheck ( AbbreviationAsWordInName ) : can t be renamed ( for backward binary compatibility ) ."}
{"lang": "java", "code": "protected void traceFields ( final Deque < Object > stack , final Object obj , final Map < Class , List < Field > > fieldSpecifiers ) { // If caller has special Field specifier for a given class // then use it, otherwise use reflection. Collection < <mask> > fields = getFieldsUsingSpecifier ( obj . getClass ( ) , fieldSpecifiers ) ; Collection < Field > fieldsBySpec = fields ; if ( fields == null ) { // Trace fields using reflection fields = MetaUtils . getDeepDeclaredFields ( obj . getClass ( ) ) . values ( ) ; } for ( final Field field : fields ) { if ( ( field . getModifiers ( ) & Modifier . TRANSIENT ) != 0 ) { if ( fieldsBySpec == null || ! fieldsBySpec . contains ( field ) ) { // Skip tracing transient fields EXCEPT when the field is listed explicitly by using the fieldSpecifiers Map. // In that case, the field must be traced, even though it is transient. continue ; } } try { final Object o = field . get ( obj ) ; if ( o != null && ! MetaUtils . isLogicalPrimitive ( o . getClass ( ) ) ) { // Trace through objects that can reference other objects stack . addFirst ( o ) ; } } catch ( Exception ignored ) { } } }", "comment": "Reach - ability trace to visit all objects within the graph to be written . This API will handle any object using either reflection APIs or by consulting a specified FIELD_SPECIFIERS map if provided ."}
{"lang": "java", "code": "public Joiner replaceNullWith ( String forNull ) { return new Joiner ( separator , prefix , suffix , trim , <mask> , ignoreEmpty , forNull , forEmpty ) ; }", "comment": "Returns a new { @code Joiner } that will behave as this one except that it will replace { @code null } input values with the specified { @code String } ."}
{"lang": "java", "code": "public void move ( final int iFrom , final int iPosition ) { if ( iPosition == 0 ) return ; final int to = iFrom + iPosition ; final int size = iPosition > 0 ? <mask> . length - to : buffer . length - iFrom ; System . arraycopy ( buffer , iFrom , buffer , to , size ) ; }", "comment": "Move bytes left or right of an offset ."}
{"lang": "java", "code": "private WroManagerFactory createWroManagerFactory ( ) { if ( wroManagerFactory == null ) { final WroManagerFactory managerFactoryAttribute = ServletContextAttributeHelper . create ( filterConfig ) . getManagerFactory ( ) ; LOG . debug ( \"managerFactory attribute: {}\" , managerFactoryAttribute ) ; wroManagerFactory = managerFactoryAttribute != null ? managerFactoryAttribute : newWroManagerFactory ( ) ; } LOG . <mask> ( \"created managerFactory: {}\" , wroManagerFactory ) ; return wroManagerFactory ; }", "comment": "Creates {"}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) public static ImmutableSetMultimap < Object , Object > instantiate ( SerializationStreamReader reader ) throws SerializationException { Comparator < Object > valueComparator = ( Comparator < Object > ) reader . readObject ( ) ; ImmutableSetMultimap . Builder < Object , Object > builder = ImmutableSetMultimap . builder ( ) ; if ( valueComparator != null ) { builder . orderValuesBy ( valueComparator ) ; } return ( ImmutableSetMultimap < Object , <mask> > ) Multimap_CustomFieldSerializerBase . instantiate ( reader , builder ) ; }", "comment": "Serialization type safety is at the caller s mercy ."}
{"lang": "java", "code": "public static String resolveHostName ( final <mask> [ ] ip ) { try { InetAddress address = InetAddress . getByAddress ( ip ) ; return address . getHostName ( ) ; } catch ( UnknownHostException ignore ) { return null ; } }", "comment": "Resolves host name from IP address bytes ."}
{"lang": "java", "code": "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Iterable < T > blockingIterable ( int bufferSize ) { ObjectHelper . verifyPositive ( bufferSize , \"bufferSize\" ) ; return <mask> BlockingObservableIterable < T > ( this , bufferSize ) ; }", "comment": "Converts this { @code Observable } into an { @link Iterable } . <p > <img width = 640 height = 315 src = https : // github . com / ReactiveX / RxJava / wiki / images / rx - operators / blockingIterable . o . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code blockingIterable } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl >"}
{"lang": "java", "code": "public <mask> Unmarshaller createUnmarshaller ( ) throws JAXBException { Unmarshaller m = getContext ( ) . createUnmarshaller ( ) ; m . setEventHandler ( new XmlValidationHandler ( ) ) ; return m ; }", "comment": "Creates a { @link Unmarshaller } to read JAXB objects from XML ."}
{"lang": "java", "code": "@ Nonnull public DataFactory . Result openFeatureDataset ( Dataset Dataset , ucar . nc2 . util . CancelTask <mask> ) throws IOException { return openFeatureDataset ( null , Dataset , task , new Result ( ) ) ; }", "comment": "Open a FeatureDataset from an Dataset object deciding on which Access to use ."}
{"lang": "java", "code": "public boolean isTransient ( ) { Throwable cause = getCause ( ) ; if ( cause == null ) { return isServerError ( statusCode ) ; } else if ( cause instanceof AlgoliaException ) { return ( ( AlgoliaException ) <mask> ) . isTransient ( ) ; } else if ( cause instanceof IOException ) { return true ; } else { return false ; } }", "comment": "Test whether this error is transient ."}
{"lang": "java", "code": "public final void mergeMap ( final RowsMapping addMap ) { Map < Integer , List < SerialRow > > map = addMap . getRowsMap ( ) ; for ( Map . Entry < <mask> , List < SerialRow > > entry : map . entrySet ( ) ) { List < SerialRow > entryRowList = entry . getValue ( ) ; if ( ( entryRowList != null ) && ( ! entryRowList . isEmpty ( ) ) ) { for ( SerialRow row : entryRowList ) { this . addRow ( entry . getKey ( ) , row . getRow ( ) ) ; } } } }", "comment": "Merge map ."}
{"lang": "java", "code": "public void putField ( final Type owner , final String name , final Type type ) { fieldInsn ( Opcodes . PUTFIELD , <mask> , name , type ) ; }", "comment": "Generates the instruction to store the top stack value in a non static field ."}
{"lang": "java", "code": "public void generateProfileMBeanInterface ( ) throws Exception { if ( SleeProfileClassCodeGenerator . checkCombination ( component ) == - 1 ) { throw new DeploymentException ( \"Profile Specification doesn't match any combination \" + \"from the JSLEE spec 1.0 section 10.5.2\" ) ; } String profileMBeanConcreteInterfaceName = cmpProfileInterfaceName + \"MBean\" ; profileMBeanConcreteInterface = pool . makeInterface ( profileMBeanConcreteInterfaceName ) ; try { cmpProfileInterface = pool . get ( cmpProfileInterfaceName ) ; profileManagementInterface = profileManagementInterfaceName != null ? pool . get ( profileManagementInterfaceName ) : null ; } catch ( NotFoundException nfe ) { throw new DeploymentException ( \"Failed to locate CMP/Management Interface for \" + component , nfe ) ; } // set interface\r try { profileMBeanConcreteInterface . addInterface ( pool . get ( AbstractProfileMBean . class . getName ( ) ) ) ; } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } // gather exceptions that the mbean methods may throw\r CtClass [ ] managementMethodExceptions = new CtClass [ 3 ] ; try { managementMethodExceptions [ 0 ] = pool . get ( ManagementException . class . getName ( ) ) ; managementMethodExceptions [ 1 ] = pool . get ( InvalidStateException . class . getName ( ) ) ; managementMethodExceptions [ 2 ] = pool . get ( ProfileImplementationException . class . getName ( ) ) ; } catch ( NotFoundException e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } CtClass [ ] cmpGetAcessorMethodExceptions = new CtClass [ ] { managementMethodExceptions [ 0 ] } ; CtClass [ ] cmpSetAcessorMethodExceptions = new CtClass [ ] { managementMethodExceptions [ 0 ] , managementMethodExceptions [ 1 ] } ; // gather all Object class methods, we don't want those in the mbean\r Set < CtMethod > objectMethods = new HashSet < CtMethod > ( ) ; try { CtClass objectClass = pool . get ( <mask> . class . getName ( ) ) ; for ( CtMethod ctMethod : objectClass . getMethods ( ) ) { objectMethods . add ( ctMethod ) ; } } catch ( NotFoundException e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } // gather methods to copy\r Set < CtMethod > cmpAcessorMethods = new HashSet < CtMethod > ( ) ; Set < CtMethod > managementMethods = new HashSet < CtMethod > ( ) ; if ( profileManagementInterface != null ) { // If the Profile Specification defines a Profile Management Interface, the profileMBean interface has the same methods\r // 1. gather all methods from management interface\r for ( CtMethod ctMethod : profileManagementInterface . getMethods ( ) ) { if ( ! objectMethods . contains ( ctMethod ) ) { managementMethods . add ( ctMethod ) ; } } // 2. gather all methods present also in cmp interface, removing those from the ones gather from management interface\r for ( CtMethod ctMethod : cmpProfileInterface . getMethods ( ) ) { if ( ! objectMethods . contains ( ctMethod ) ) { if ( managementMethods . remove ( ctMethod ) ) { cmpAcessorMethods . add ( ctMethod ) ; } } } } else { for ( CtMethod ctMethod : cmpProfileInterface . getMethods ( ) ) { if ( ! objectMethods . contains ( ctMethod ) ) { cmpAcessorMethods . add ( ctMethod ) ; } } } // copy cmp acessor & mngt methods\r for ( CtMethod ctMethod : cmpAcessorMethods ) { // copy method\r CtMethod methodCopy = new CtMethod ( ctMethod , profileMBeanConcreteInterface , null ) ; // set exceptions\r CtClass [ ] exceptions = null ; if ( ctMethod . getName ( ) . startsWith ( \"set\" ) ) { exceptions = cmpSetAcessorMethodExceptions ; } else if ( ctMethod . getName ( ) . startsWith ( \"get\" ) ) { exceptions = cmpGetAcessorMethodExceptions ; } else { throw new DeploymentException ( \"unexpected method in profile cmp interface \" + ctMethod ) ; } methodCopy . setExceptionTypes ( exceptions ) ; // add to class\r profileMBeanConcreteInterface . addMethod ( methodCopy ) ; // store in set to be used in mbean impl\r mBeanCmpAcessorMethods . add ( methodCopy ) ; } for ( CtMethod ctMethod : managementMethods ) { // copy method\r CtMethod methodCopy = new CtMethod ( ctMethod , profileMBeanConcreteInterface , null ) ; // set exceptions\r methodCopy . setExceptionTypes ( managementMethodExceptions ) ; // add to class\r profileMBeanConcreteInterface . addMethod ( methodCopy ) ; // store in set to be used in mbean impl\r mBeanManagementMethods . add ( methodCopy ) ; } // write class file\r try { profileMBeanConcreteInterface . writeFile ( this . component . getDeploymentDir ( ) . getAbsolutePath ( ) ) ; } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } finally { profileMBeanConcreteInterface . defrost ( ) ; } // and load it to the component\r try { this . component . setProfileMBeanConcreteInterfaceClass ( Thread . currentThread ( ) . getContextClassLoader ( ) . loadClass ( profileMBeanConcreteInterfaceName ) ) ; } catch ( Throwable e ) { throw new SLEEException ( e . getMessage ( ) , e ) ; } }", "comment": "Generates the Profile MBean interface"}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) public Form < T > bind ( Lang lang , TypedMap attrs , Map < String , String > data , Map < String , Http . MultipartFormData . FilePart < ? > > files , String ... allowedFields ) { final DataBinder dataBinder = dataBinder ( allowedFields ) ; final Map < String , Object > objectDataFinal = getObjectData ( data , files ) ; final Set < ConstraintViolation < Object > > validationErrors = runValidation ( lang , attrs , dataBinder , objectDataFinal ) ; final BindingResult result = dataBinder . getBindingResult ( ) ; validationErrors . forEach ( violation -> addConstraintViolationToBindingResult ( violation , result ) ) ; boolean hasAnyError = result . hasErrors ( ) || result . getGlobalErrorCount ( ) > 0 ; if ( hasAnyError ) { final List < ValidationError > errors = getFieldErrorsAsValidationErrors ( lang , result ) ; final List < ValidationError > globalErrors = globalErrorsAsValidationErrors ( result ) ; errors . addAll ( globalErrors ) ; return new Form <> ( rootName , backedType , data , files , <mask> , Optional . ofNullable ( ( T ) result . getTarget ( ) ) , groups , messagesApi , formatters , this . validatorFactory , config , lang , directFieldAccess ) ; } return new Form <> ( rootName , backedType , data , files , errors , Optional . ofNullable ( ( T ) result . getTarget ( ) ) , groups , messagesApi , formatters , this . validatorFactory , config , lang , directFieldAccess ) ; }", "comment": "Binds data to this form - that is handles form submission ."}
{"lang": "java", "code": "@ Override protected void subAppend ( E event ) { // The roll-over check must precede actual writing. This is the // only correct behavior for time driven triggers. // We need to synchronize on triggeringPolicy so that only one rollover // occurs at a time synchronized ( triggeringPolicy ) { if ( triggeringPolicy . isTriggeringEvent ( currentlyActiveFile , event ) ) { rollover ( ) ; } } <mask> . subAppend ( event ) ; }", "comment": "This method differentiates RollingFileAppender from its super class ."}
{"lang": "java", "code": "static public void execute ( URL url ) throws SlideExecutionException { checkNotNull ( url ) ; ScreenRegion screenRegion = new DesktopScreenRegion ( ) ; Context <mask> = new Context ( screenRegion ) ; execute ( url , context ) ; }", "comment": "Execute a presentation file at a given url"}
{"lang": "java", "code": "public static String removeFirst ( String str , <mask> c ) { return ( Strings . isEmpty ( str ) || c != str . charAt ( 0 ) ) ? str : str . substring ( 1 ) ; }", "comment": "\u5982\u679cstr\u4e2d\u7b2c\u4e00\u4e2a\u5b57\u7b26\u548c c\u4e00\u81f4 \u5219\u5220\u9664 \u5426\u5219\u8fd4\u56de str <p > \u6bd4\u5982 : <ul > <li > removeFirst ( 12345 1 ) = > 2345 <li > removeFirst ( ABC B ) = > ABC <li > removeFirst ( A B ) = > A <li > removeFirst ( A A ) = > < / ul >"}
{"lang": "java", "code": "private void checkForMissingCommandParameters ( final List < String > messages ) { if ( ( commandParams . isEmpty ( ) || commandParams . iterator ( ) . next ( ) . startsWith ( \"-\" ) ) && ( COMMANDS . CALCULATE_CHECKSUM . equalsIgnoreCase ( <mask> ) ) ) { messages . add ( coreBundle . getString ( \"changeset.identifier.missing\" ) ) ; } }", "comment": "Checks for missing command line parameters and if any problems are found returns the list of issues in String form ."}
{"lang": "java", "code": "public static String exceptionChainToString ( Throwable t ) { StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw , true ) ; while ( t != null ) { t . printStackTrace ( pw ) ; t = t . getCause ( ) ; } StreamUtil . close ( pw ) ; StreamUtil . <mask> ( sw ) ; return sw . toString ( ) ; }", "comment": "Prints full exception stack trace from top to root cause into a String ."}
{"lang": "java", "code": "public static long quorumPosition ( final ClusterMember [ ] members , final long [ ] rankedPositions ) { final int length = rankedPositions . length ; for ( int i = 0 ; i < length ; i ++ ) { rankedPositions [ i ] = 0 ; } for ( final ClusterMember member : members ) { long newPosition = member . logPosition ; for ( int i = 0 ; i < <mask> ; i ++ ) { final long rankedPosition = rankedPositions [ i ] ; if ( newPosition > rankedPosition ) { rankedPositions [ i ] = newPosition ; newPosition = rankedPosition ; } } } return rankedPositions [ length - 1 ] ; }", "comment": "Calculate the position reached by a quorum of cluster members ."}
{"lang": "java", "code": "public MoveResult < Solution_ > take ( ) throws InterruptedException { int moveIndex = nextMoveIndex ; nextMoveIndex ++ ; if ( ! backlog . isEmpty ( ) ) { MoveResult < Solution_ > result = backlog . remove ( moveIndex ) ; if ( result != null ) { return <mask> ; } } while ( true ) { MoveResult < Solution_ > result = innerQueue . take ( ) ; // If 2 exceptions are added from different threads concurrently, either one could end up first. // This is a known deviation from 100% reproducibility, that never occurs in a success scenario. if ( result . hasThrownException ( ) ) { throw new IllegalStateException ( \"The move thread with moveThreadIndex (\" + result . getMoveThreadIndex ( ) + \") has thrown an exception.\" + \" Relayed here in the parent thread.\" , result . getThrowable ( ) ) ; } if ( result . getMoveIndex ( ) == moveIndex ) { return result ; } else { backlog . put ( result . getMoveIndex ( ) , result ) ; } } }", "comment": "Not thread - safe . Can only be called from the solver thread ."}
{"lang": "java", "code": "public static boolean contained ( Box3D_I32 box , Point3D_I32 point ) { return ( box . p0 . x <= point . x && point . x < box . p1 . x && <mask> . p0 . y <= point . y && point . y < box . p1 . y && box . p0 . z <= point . z && point . z < box . p1 . z ) ; }", "comment": "Returns true if the point is contained inside the box . The point is considered to be inside the box if the following test passes for each dimension . box . p0 . x &le ; point . x { @code < } box . p1 . x + box . lengthX"}
{"lang": "java", "code": "@ Nullable synchronized Record getRecordAt ( SubsetParams coords ) { int [ ] want = new int [ getRank ( ) ] ; int count = 0 ; int runIdx = - 1 ; for ( Coordinate coord : getCoordinates ( ) ) { int idx = - 1 ; switch ( coord . getType ( ) ) { case runtime : CalendarDate runtimeCooord = coords . getRunTime ( ) ; idx = coord . getIndex ( runtimeCooord ) ; runIdx = idx ; break ; <mask> timeIntv : double [ ] timeIntv = coords . getTimeOffsetIntv ( ) ; idx = coord . getIndex ( new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ) ; break ; case time : Double timeOffset = coords . getTimeOffset ( ) ; // Double int coordInt = timeOffset . intValue ( ) ; idx = coord . getIndex ( coordInt ) ; break ; case time2D : timeIntv = coords . getTimeOffsetIntv ( ) ; if ( timeIntv != null ) { TimeCoordIntvValue coordTinv = new TimeCoordIntvValue ( ( int ) timeIntv [ 0 ] , ( int ) timeIntv [ 1 ] ) ; idx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordTinv ) ; // LOOK can only use if orthogonal break ; } Double timeCoord = coords . getTimeOffset ( ) ; if ( timeCoord != null ) { coordInt = timeCoord . intValue ( ) ; idx = ( ( CoordinateTime2D ) coord ) . findTimeIndexFromVal ( runIdx , coordInt ) ; break ; } // the OneTime case CoordinateTime2D coord2D = ( CoordinateTime2D ) coord ; if ( coord2D . getNtimes ( ) == 1 ) { idx = 0 ; break ; } throw new IllegalStateException ( \"time2D must have timeOffset ot timeOffsetIntv coordinare\" ) ; case vert : double [ ] vertIntv = coords . getVertCoordIntv ( ) ; if ( vertIntv != null ) { VertCoordValue coordVert = new VertCoordValue ( vertIntv [ 0 ] , vertIntv [ 1 ] ) ; idx = coord . getIndex ( coordVert ) ; break ; } Double vertCoord = coords . getVertCoord ( ) ; if ( vertCoord != null ) { VertCoordValue coordVert = new VertCoordValue ( vertCoord ) ; idx = coord . getIndex ( coordVert ) ; } break ; case ens : Double ensVal = coords . getEnsCoord ( ) ; idx = ( ( CoordinateEns ) coord ) . getIndexByMember ( ensVal ) ; break ; default : logger . warn ( \"GribCollectionImmutable: missing CoordVal for {}%n\" , coord . getName ( ) ) ; } if ( idx < 0 ) { logger . debug ( \"Cant find index for value in axis {} in variable {}\" , coord . getName ( ) , name ) ; return null ; } want [ count ++ ] = idx ; } return sa . getContent ( want ) ; }", "comment": "coord based record finding . note only one record at a time"}
{"lang": "java", "code": "protected void bindJerseyComponent ( Object resource ) { Preconditions . checkNotNull ( resource , \"Resource cannot be null.\" ) ; buildBinders ( ) ; jerseyBinder . addBinding ( ) . toInstance ( <mask> ) ; }", "comment": "Add a resource to the graceland platform . <p / > There are two ways of adding a resource : <ul > <li > <strong > Instance< / strong > - bind an instance of a resource directly . < / li > <li > <strong > Class< / strong > - bind a class of a resource and it will be built by the { @link com . google . inject . Injector } . < / li > < / ul >"}
{"lang": "java", "code": "private void sortMethods ( ) { List < Method > methodList = new ArrayList <> ( methods ) ; Collections . sort ( methodList , new Comparator < Method > ( ) { @ Override public int compare ( Method m1 , Method m2 ) { int o1 = Integer . MAX_VALUE ; if ( m1 . isAnnotationPresent ( Order . <mask> ) ) { Order order = m1 . getAnnotation ( Order . class ) ; o1 = order . value ( ) ; } int o2 = Integer . MAX_VALUE ; if ( m2 . isAnnotationPresent ( Order . class ) ) { Order order = m2 . getAnnotation ( Order . class ) ; o2 = order . value ( ) ; } if ( o1 == o2 ) { // same or unsorted, compare controller+method String s1 = m1 . getDeclaringClass ( ) . getName ( ) + \".\" + m1 . getName ( ) ; String s2 = m2 . getDeclaringClass ( ) . getName ( ) + \".\" + m2 . getName ( ) ; return s1 . compareTo ( s2 ) ; } if ( o1 < o2 ) { return - 1 ; } else { return 1 ; } } } ) ; methods = new LinkedHashSet <> ( methodList ) ; }", "comment": "Sorts the methods into registration order"}
{"lang": "java", "code": "public static void validateSessionIdRange ( final int low , final int high ) { if ( low > high ) { throw new ConfigurationException ( \"low session id value \" + low + \" must be <= high value \" + high ) ; } if ( Math . abs ( ( <mask> ) high - low ) > Integer . MAX_VALUE ) { throw new ConfigurationException ( \"reserved range to too large\" ) ; } }", "comment": "Validate the range of session ids based on a high and low value provided which accounts for the values wrapping ."}
{"lang": "java", "code": "@ Override public void endElement ( String uri , String localName , String qName ) throws SAXException { writeText4Links ( ) ; if ( ! mIgnoredTags . isEmpty ( ) && mIgnoredTags . peek ( ) . equalsIgnoreCase ( qName ) ) { mIgnoredTags . pop ( ) ; } else { if ( ! ( htmlMode && ( uri . equals ( \"http://www.w3.org/1999/xhtml\" ) || uri . equals ( \"\" ) ) && ( qName . equals ( \"area\" ) || qName . equals ( \"base\" ) || qName . equals ( \"basefont\" ) || qName . equals ( \"br\" ) || qName . equals ( \"col\" ) || qName . equals ( \"frame\" ) || qName . equals ( \"hr\" ) || qName . equals ( \"img\" ) || qName . equals ( \"input\" ) || qName . equals ( \"isindex\" ) || qName . equals ( \"link\" ) || qName . equals ( \"meta\" ) || qName . equals ( \"param\" ) ) ) ) { write ( \"</\" ) ; writeName ( uri , localName , qName , true ) ; write ( ' ' ) ; } if ( elementLevel == 1 ) { write ( ' ' ) ; } if ( htmlMode && localName . equals ( \"a\" ) ) { mIgnoreChars = false ; } cdataElement = false ; <mask> . endElement ( uri , localName , qName ) ; nsSupport . popContext ( ) ; elementLevel -- ; } }", "comment": "Write an end tag . <p > Pass the event on down the filter chain for further processing ."}
{"lang": "java", "code": "private void setOnPojo ( final Object pojo , final P value , final LoadContext ctx , final Path path ) { if ( log . isTraceEnabled ( ) ) log . trace ( LogUtils . msg ( path , \"Setting property \" + property . getName ( ) + \" to \" + value ) ) ; property . <mask> ( pojo , value ) ; }", "comment": "Sets the property on the pojo to the value . The value should already be translated . TODO : Sensitive to the value possibly being a Result<? > wrapper in which case it enqueues the set operation until the loadcontext is done ."}
{"lang": "java", "code": "public static CacheBuilderSpec parse ( String cacheBuilderSpecification ) { CacheBuilderSpec spec = new CacheBuilderSpec ( cacheBuilderSpecification ) ; if ( ! cacheBuilderSpecification . isEmpty ( ) ) { for ( String keyValuePair : KEYS_SPLITTER . split ( cacheBuilderSpecification ) ) { List < String > keyAndValue = ImmutableList . copyOf ( KEY_VALUE_SPLITTER . split ( keyValuePair ) ) ; checkArgument ( ! keyAndValue . isEmpty ( ) , \"blank key-value pair\" ) ; checkArgument ( keyAndValue . size ( ) <= 2 , \"key-value pair %s with more than one equals sign\" , keyValuePair ) ; // Find the ValueParser for the current key. String key = keyAndValue . get ( 0 ) ; ValueParser valueParser = VALUE_PARSERS . <mask> ( key ) ; checkArgument ( valueParser != null , \"unknown key %s\" , key ) ; String value = keyAndValue . size ( ) == 1 ? null : keyAndValue . get ( 1 ) ; valueParser . parse ( spec , key , value ) ; } } return spec ; }", "comment": "Creates a CacheBuilderSpec from a string ."}
{"lang": "java", "code": "public <mask> parse ( String name ) throws NamingException { Vector comps = insStringToStringifiedComps ( name ) ; return new CNCompoundName ( comps . elements ( ) ) ; }", "comment": "Returns a CompoundName given a string in INS syntax ."}
{"lang": "java", "code": "public Metrics generate ( Enumeration < C > components , DataBuffer <mask> ) throws IOException { return generate ( new EnumerationIterator < C > ( components ) , product ) ; }", "comment": "Generate a product by assembling components ."}
{"lang": "java", "code": "public static String getDefaultWatchServiceId ( ) { String <mask> = \"polling\" ; String osName = System . getProperty ( \"os.name\" ) ; if ( osName != null ) { osName = osName . toLowerCase ( Locale . ENGLISH ) ; if ( osName . contains ( \"windows\" ) || osName . contains ( \"linux\" ) ) { result = isAtLeastJava7 ( ) ? \"jdk7\" : \"jnotify\" ; } else if ( osName . contains ( \"mac\" ) ) { result = \"jnotify\" ; } } return result ; }", "comment": "Returns default watch service identifier based on operating system ."}
{"lang": "java", "code": "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Single < T > retry ( BiPredicate < ? super Integer , ? <mask> Throwable > predicate ) { return toSingle ( toFlowable ( ) . retry ( predicate ) ) ; }", "comment": "Re - subscribe to the current Single if the given predicate returns true when the Single fails with an onError . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > {"}
{"lang": "java", "code": "public TypeCode <mask> ( ) { if ( typeCode == null ) { short modifier = VM_NONE . value ; if ( is_custom ) modifier = VM_CUSTOM . value ; else if ( is_abstract ) modifier = VM_ABSTRACT . value ; typeCode = getORB ( ) . create_value_tc ( id , name , modifier , baseValueTypeCode , getValueMembersForTypeCode ( ) ) ; } return typeCode ; }", "comment": "IDLTypeOperations implementation ------------------------------"}
{"lang": "java", "code": "@ DoesServiceRequest public final void uploadProperties ( AccessCondition accessCondition , FileRequestOptions <mask> , OperationContext opContext ) throws StorageException { assertNoSnapshot ( ) ; if ( this . properties != null && this . properties . getShareQuota ( ) != null ) { Utility . assertInBounds ( \"Share Quota\" , this . properties . getShareQuota ( ) , 1 , FileConstants . MAX_SHARE_QUOTA ) ; } if ( opContext == null ) { opContext = new OperationContext ( ) ; } opContext . initialize ( ) ; options = FileRequestOptions . populateAndApplyDefaults ( options , this . fileServiceClient ) ; ExecutionEngine . executeWithRetry ( this . fileServiceClient , this , this . uploadPropertiesImpl ( accessCondition , options ) , options . getRetryPolicyFactory ( ) , opContext ) ; }", "comment": "Updates the share s properties using the request options and operation context . <p > Use { @link CloudFileShare#downloadAttributes } to retrieve the latest values for the share s properties and metadata from the Microsoft Azure storage service ."}
{"lang": "java", "code": "public static void printRate ( final double messagesPerSec , final double bytesPerSec , final long totalMessages , final long totalBytes ) { System . <mask> . println ( String . format ( \"%.02g msgs/sec, %.02g payload bytes/sec, totals %d messages %d MB\" , messagesPerSec , bytesPerSec , totalMessages , totalBytes / ( 1024 * 1024 ) ) ) ; }", "comment": "Print the rates to stdout"}
{"lang": "java", "code": "protected void changeOwnerDocument ( final <mask> node , final Document ownerDocument ) { node . ownerDocument = ownerDocument ; int childCount = node . getChildNodesCount ( ) ; for ( int i = 0 ; i < childCount ; i ++ ) { Node child = node . getChild ( i ) ; changeOwnerDocument ( child , ownerDocument ) ; } }", "comment": "Changes owner document for given node and all its children ."}
{"lang": "java", "code": "public void register ( final Class type , final Class < ? extends SqlType > sqlTypeClass ) { types . <mask> ( type , lookupSqlType ( sqlTypeClass ) ) ; }", "comment": "Registers sql type for provided type ."}
{"lang": "java", "code": "public static String getLastShardId ( ClientConfiguration awsClientConfig , KinesisConfigBean conf , String streamName ) throws StageException { AmazonKinesis kinesisClient = getKinesisClient ( awsClientConfig , conf ) ; String lastShardId = null ; try { StreamDescription description ; do { if ( lastShardId == null ) { <mask> = kinesisClient . describeStream ( streamName ) . getStreamDescription ( ) ; } else { description = kinesisClient . describeStream ( streamName , lastShardId ) . getStreamDescription ( ) ; } int pageSize = description . getShards ( ) . size ( ) ; lastShardId = description . getShards ( ) . get ( pageSize - 1 ) . getShardId ( ) ; } while ( description . getHasMoreShards ( ) ) ; return lastShardId ; } finally { kinesisClient . shutdown ( ) ; } }", "comment": "Get the last shard Id in the given stream In preview mode kinesis source uses the last Shard Id to get records from kinesis"}
{"lang": "java", "code": "public static Transformer < String > extensionTransformer ( final String newExtension ) { return new Transformer < String > ( ) { public String transform ( final String <mask> ) { return FilenameUtils . getBaseName ( input ) + \".\" + newExtension ; } } ; }", "comment": "Creates a {"}
{"lang": "java", "code": "@ SuppressFBWarnings ( value = \"OBL_UNSATISFIED_OBLIGATION\" , justification = \"The stream is closed later together with the printer.\" ) public final Printer print ( <mask> csvFile ) throws IOException { return print ( new FileOutputStream ( csvFile ) ) ; }", "comment": "Creates a { @link CsvPrinter } that writes CSV data into a { @link File } ."}
{"lang": "java", "code": "@ Override public void setDType ( DataBuffer . <mask> dtype ) { assert dtype == DataBuffer . Type . DOUBLE || dtype == DataBuffer . Type . FLOAT || dtype == DataBuffer . Type . INT : \"Invalid opType passed, must be float or double\" ; // this.dtype = dtype; }", "comment": "Sets the data opType"}
{"lang": "java", "code": "Rule Parameter ( ) { return Sequence ( Variable ( ) , push ( new VariableDefinitionNode ( match ( ) ) ) , peek ( ) . setVisible ( ! isParserTranslationEnabled ( ) ) , Ws0 ( ) , ' ' , Ws0 ( ) , ExpressionPhrase ( ) , peek ( 1 ) . addChild ( new ExpressionGroupNode ( <mask> ( ) ) ) ) ; }", "comment": "Variable Ws0 : Ws0 ExpressionPhrase"}
{"lang": "java", "code": "public static double meanOf ( Iterator < ? extends Number > values ) { checkArgument ( <mask> . hasNext ( ) ) ; long count = 1 ; double mean = values . next ( ) . doubleValue ( ) ; while ( values . hasNext ( ) ) { double value = values . next ( ) . doubleValue ( ) ; count ++ ; if ( isFinite ( value ) && isFinite ( mean ) ) { // Art of Computer Programming vol. 2, Knuth, 4.2.2, (15) mean += ( value - mean ) / count ; } else { mean = calculateNewMeanNonFinite ( mean , value ) ; } } return mean ; }", "comment": "Returns the <a href = http : // en . wikipedia . org / wiki / Arithmetic_mean > arithmetic mean< / a > of the values . The count must be non - zero ."}
{"lang": "java", "code": "public LibraryComponent getComponentByID ( LibraryID id ) { // get from repository LibraryComponent component = componentRepository . getComponentByID ( id ) ; if ( component == null ) { // not found in repository, get it from deployable unit component = deployableUnit . getLibraryComponents ( ) . get ( id ) ; } return <mask> ; }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "public static FastByteArrayOutputStream copyToOutputStream ( final InputStream input , final int count ) throws IOException { try ( FastByteArrayOutputStream <mask> = createFastByteArrayOutputStream ( ) ) { copy ( input , output , count ) ; return output ; } }", "comment": "Copies { @link InputStream } to a new { @link FastByteArrayOutputStream } using buffer and specified encoding ."}
{"lang": "java", "code": "void checkIsE ( @ NullableDecl <mask> element ) { checkNotNull ( element ) ; if ( ! isActuallyE ( element ) ) { throw new ClassCastException ( \"Expected an \" + type + \" but got \" + element ) ; } }", "comment": "Returns {"}
{"lang": "java", "code": "public static String getDefaultName ( Class < ? > declaringClass , String method ) { // minimum len 1 shortens the package name and keeps class name String cls = ClassUtils . getAbbreviatedName ( declaringClass . getName ( ) , 1 ) ; return name ( cls , <mask> ) ; }", "comment": "Get default metric name . Use abbreviated package name e . g . foo . bar . ClassA . methodB - > f . b . ClassA . methodB"}
{"lang": "java", "code": "public void paintImmediately ( int x , int y , int w , int h ) { RepaintManager repaintManager = null ; boolean save = true ; if ( ! isDoubleBuffered ( ) ) { repaintManager = RepaintManager . currentManager ( this ) ; <mask> = repaintManager . isDoubleBufferingEnabled ( ) ; repaintManager . setDoubleBufferingEnabled ( false ) ; } super . paintImmediately ( x , y , w , h ) ; if ( repaintManager != null ) { repaintManager . setDoubleBufferingEnabled ( save ) ; } }", "comment": "Immediately repaints the surface ."}
{"lang": "java", "code": "protected ActivityContextInterface getACI ( Object activity ) throws NullPointerException , UnrecognizedActivityException , FactoryException { if ( activity == null ) { throw new NullPointerException ( \"null activity object\" ) ; } ActivityHandle handle = null ; for ( ResourceAdaptorEntity raEntity : sleeContainer . getResourceManagement ( ) . getResourceAdaptorEntitiesPerType ( resourceAdaptorTypeID ) ) { <mask> = raEntity . getResourceAdaptorObject ( ) . getActivityHandle ( activity ) ; if ( handle != null ) { ActivityContextHandle ach = new ResourceAdaptorActivityContextHandleImpl ( raEntity , handle ) ; ActivityContext ac = sleeContainer . getActivityContextFactory ( ) . getActivityContext ( ach ) ; if ( ac != null ) { return ac . getActivityContextInterface ( ) ; } break ; } } throw new UnrecognizedActivityException ( activity . toString ( ) ) ; }", "comment": "This method returns the aci for the specified activity if exists it should be invoked by each impl of methods of an ra type aci factory ."}
{"lang": "java", "code": "public static < T > Constructor < T > getNoArgConstructor ( Class < T > clazz ) { try { Constructor < T > ctor = clazz . getDeclaredConstructor ( new <mask> [ 0 ] ) ; ctor . setAccessible ( true ) ; return ctor ; } catch ( NoSuchMethodException e ) { // lame there is no way to tell if the class is a nonstatic inner class if ( clazz . isMemberClass ( ) || clazz . isAnonymousClass ( ) || clazz . isLocalClass ( ) ) throw new IllegalStateException ( clazz . getName ( ) + \" must be static and must have a no-arg constructor\" , e ) ; else throw new IllegalStateException ( clazz . getName ( ) + \" must have a no-arg constructor\" , e ) ; } }", "comment": "Throw an IllegalStateException if the class does not have a no - arg constructor ."}
{"lang": "java", "code": "public HttpClientConfig withParams ( <mask> < String , ? > httpClientParams ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }", "comment": "Replaces the currently configured parameters with the ones supplied by <code > httpClientParams< / code > . This method is the same as { @link #setParams ( java . util . Map ) } ."}
{"lang": "java", "code": "public static String readFileAsString ( String <mask> ) { BufferedInputStream is = null ; try { is = new BufferedInputStream ( new FileInputStream ( filename ) ) ; } catch ( FileNotFoundException e ) { throw new IllegalStateException ( e ) ; } return readStreamAsString ( is ) ; }", "comment": "Reads a text file as a string ."}
{"lang": "java", "code": "public static void writeFile ( @ NonNull File destinationFile , @ NonNull InputStream content ) throws IOException { byte [ ] buffer = new byte [ 64 * 1024 ] ; // 64 kB buffer FileOutputStream outputStream = new FileOutputStream ( destinationFile ) ; try { int bytesRead ; while ( ( bytesRead = content . read ( <mask> ) ) >= 0 ) { outputStream . write ( buffer , 0 , bytesRead ) ; } } finally { content . close ( ) ; outputStream . close ( ) ; } }", "comment": "Write a stream of bytes to a file ."}
{"lang": "java", "code": "public String absoluteURL ( Http . <mask> request ) { return absoluteURL ( request . secure ( ) , request . host ( ) ) ; }", "comment": "Transform this call to an absolute URL ."}
{"lang": "java", "code": "@ Generated ( value = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:54:50+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setTelefonart ( TelSonstige . Telefonart <mask> ) { this . telefonart = value ; }", "comment": "Sets the value of the telefonart property ."}
{"lang": "java", "code": "public void e ( <mask> src , String msg , @ Nullable Throwable thrown ) { maybeLog ( ERROR , src , msg , thrown ) ; }", "comment": "Send an ERROR log message and log the exception ."}
{"lang": "java", "code": "@ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . ERROR ) @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public final Flowable < T > sample ( long period , TimeUnit unit , Scheduler scheduler ) { ObjectHelper . requireNonNull ( unit , \"unit is null\" ) ; ObjectHelper . requireNonNull ( scheduler , \"scheduler is null\" ) ; return RxJavaPlugins . onAssembly ( new FlowableSampleTimed < T > ( this , period , <mask> , scheduler , false ) ) ; }", "comment": "Returns a Flowable that emits the most recently emitted item ( if any ) emitted by the source Publisher within periodic time intervals where the intervals are defined on a particular Scheduler . <p > <img width = 640 height = 305 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / sample . s . png alt = > <dl > <dt > <b > Backpressure : < / b > < / dt > <dd > This operator does not support backpressure as it uses time to control data flow . < / dd > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl >"}
{"lang": "java", "code": "protected Properties getPropertiesUsingCWD ( ) { /*log.fine(\"getPropertiesUsingCWD: called\");*/ // Use PropertiesHelper to try to load the properties from a file or URl <mask> { return PropertiesHelper . getProperties ( getPropertiesResourceName ( ) ) ; } catch ( IOException e ) { /*log.fine(\"Could not load properties from file or URL \" + getPropertiesResourceName());*/ // Failure of this method is noted, so exception is ignored. e = null ; } return null ; }", "comment": "Tries to load the properties as a file or URL matching the properties resource name . File names will be taken relative to the current working directory ."}
{"lang": "java", "code": "public Double toDouble ( final Object value , final Double defaultValue ) { final Double result = toDouble ( value ) ; if ( <mask> == null ) { return defaultValue ; } return result ; }", "comment": "Converts value to <code > Double< / code > . Returns default value when conversion result is <code > null< / code >"}
{"lang": "java", "code": "@ Override public INDArray create ( float [ ] data , int [ ] shape ) { //ensure shapes that wind up being scalar end up with the write shape if ( shape . length == 1 && shape [ 0 ] == 0 ) { shape = new int [ ] { 1 , 1 } ; } return create ( <mask> , shape , Nd4j . getStrides ( shape ) , 0 ) ; }", "comment": "Create an ndrray with the specified shape"}
{"lang": "java", "code": "public GridRecord findRecord ( int ens , int time , int level ) { if ( hasEnsemble ( ) ) { return recordTracker [ ens * ( ntimes * nlevels ) + ( time * nlevels ) + level ] ; } else { return recordTracker [ time * nlevels + <mask> ] ; } }", "comment": "Find the grid record for the time and level indices Canonical ordering is ens time level"}
{"lang": "java", "code": "private Paint getStylePaint ( StyleRow style , FeatureDrawType drawType ) { Paint paint = featurePaintCache . getPaint ( style , drawType ) ; if ( paint == null ) { Color color = null ; Style paintStyle = null ; Float strokeWidth = null ; switch ( drawType ) { <mask> CIRCLE : color = style . getColorOrDefault ( ) ; paintStyle = Style . FILL ; break ; case STROKE : color = style . getColorOrDefault ( ) ; paintStyle = Style . STROKE ; strokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; break ; case FILL : color = style . getFillColor ( ) ; paintStyle = Style . FILL ; strokeWidth = this . density * ( float ) style . getWidthOrDefault ( ) ; break ; default : throw new GeoPackageException ( \"Unsupported Draw Type: \" + drawType ) ; } Paint stylePaint = new Paint ( ) ; stylePaint . setAntiAlias ( true ) ; stylePaint . setStyle ( paintStyle ) ; stylePaint . setColor ( color . getColorWithAlpha ( ) ) ; if ( strokeWidth != null ) { stylePaint . setStrokeWidth ( strokeWidth ) ; } synchronized ( featurePaintCache ) { paint = featurePaintCache . getPaint ( style , drawType ) ; if ( paint == null ) { featurePaintCache . setPaint ( style , drawType , stylePaint ) ; paint = stylePaint ; } } } return paint ; }", "comment": "Get the style paint from cache or create and cache it"}
{"lang": "java", "code": "static void checkToken ( final String token , final String message , Object ... args ) { checkNotNull ( message , \"Message cannot be null\" ) ; <mask> { validateLength ( token ) ; validateCharacters ( token ) ; } catch ( IllegalArgumentException e ) { throw new InvalidTokenException ( String . format ( message , args ) , token , e ) ; } }", "comment": "Checks the given type name for illegal characters as defined in RFC 7230 section 3 . 2 . 6 ."}
{"lang": "java", "code": "@ CheckResult @ NonNull public final < T > Observable < <mask> < T > > mapToList ( @ NonNull Function < Cursor , T > mapper ) { return lift ( Query . mapToList ( mapper ) ) ; }", "comment": "Given a function mapping the current row of a { @link Cursor } to { @code T } transform each emitted { @link Query } to a { @code List<T > } . <p > Be careful using this operator as it will always consume the entire cursor and create objects for each row every time this observable emits a new query . On tables whose queries update frequently or very large result sets this can result in the creation of many objects . <p > This method is equivalent to : <pre > { @code flatMap ( q - > q . asRows ( mapper ) . toList () ) } < / pre > and a convenience operator for : <pre > { @code lift ( Query . mapToList ( mapper )) } < / pre > <p > Consider using { @link Query#asRows } if you need to limit or filter in memory ."}
{"lang": "java", "code": "@ Override public void validateInput ( final Command command , final Context ctx ) throws ValidationException { checkRequiredInputKeys ( <mask> , ctx ) ; checkInput ( command , ctx ) ; }", "comment": "Checks required input keys and then delegates to checkInput () ;"}
{"lang": "java", "code": "public void setWordwrap ( final String wordwrap ) { try { int ww = Integer . parseInt ( wordwrap ) ; if ( ww >= 0 ) { this . wordwrap = ww ; } } catch ( Throwable <mask> ) { // ignore } }", "comment": "Set the length of the wordwrap default is 40 zero disables line - wrap ."}
{"lang": "java", "code": "@ XmlElementDecl ( namespace = \"http://www.immoxml.de\" , name = \"anzahl_balkon_terrassen\" ) @ XmlJavaTypeAdapter ( Adapter7 . class ) public JAXBElement < BigDecimal > createAnzahlBalkonTerrassen ( BigDecimal value ) { return new JAXBElement < BigDecimal > ( _AnzahlBalkonTerrassen_QNAME , BigDecimal . <mask> , null , value ) ; }", "comment": "Create an instance of { @link JAXBElement } { @code < } { @link BigDecimal } { @code > }}"}
{"lang": "java", "code": "public static OSymmetricKey fromConfig ( <mask> OSymmetricKeyConfig keyConfig ) { if ( keyConfig . usesKeyString ( ) ) { return fromString ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyString ( ) ) ; } else if ( keyConfig . usesKeyFile ( ) ) { return fromFile ( keyConfig . getKeyAlgorithm ( ) , keyConfig . getKeyFile ( ) ) ; } else if ( keyConfig . usesKeystore ( ) ) { return fromKeystore ( keyConfig . getKeystoreFile ( ) , keyConfig . getKeystorePassword ( ) , keyConfig . getKeystoreKeyAlias ( ) , keyConfig . getKeystoreKeyPassword ( ) ) ; } else { throw new OSecurityException ( \"OSymmetricKey(OSymmetricKeyConfig) Invalid configuration\" ) ; } }", "comment": "Creates an OSymmetricKey from an OSymmetricKeyConfig interface ."}
{"lang": "java", "code": "public CatalogBuilder makeCatalogBuilder ( ) { CatalogBuilder builder = new CatalogBuilder ( this ) ; for ( Dataset <mask> : getDatasetsLocal ( ) ) { builder . addDataset ( makeDatasetBuilder ( null , ds ) ) ; } return builder ; }", "comment": "turn ConfigCatalog into a mutable CatalogBuilder so we can mutate"}
{"lang": "java", "code": "public void set ( String name , String value , int expires ) { this . <mask> . add ( new Cookie ( name , value , Cookie . getHTTPTime ( expires ) ) ) ; }", "comment": "Sets a cookie ."}
{"lang": "java", "code": "@ SuppressWarnings ( \"signature\" ) // conversion routine public static @ BinaryName String fieldDescriptorToBinaryName ( String classname ) { if ( classname . equals ( \"\" ) ) { throw new Error ( \"Empty string passed to fieldDescriptorToBinaryName\" ) ; } int dims = 0 ; while ( classname . startsWith ( \"[\" ) ) { dims ++ ; classname = classname . substring ( 1 ) ; } String result ; if ( classname . startsWith ( \"L\" ) && classname . endsWith ( \";\" ) ) { result = classname . substring ( 1 , classname . length ( ) - 1 ) ; } else { result = primitiveClassesFromJvm . get ( classname ) ; if ( result == null ) { throw new Error ( \"Malformed base class: \" + classname ) ; } } for ( int i = 0 ; i < dims ; i ++ ) { <mask> += \"[]\" ; } return result . replace ( ' ' , ' ' ) ; }", "comment": "Convert a field descriptor to a binary name . For example convert [ Ljava / lang / Object ; to java . lang . Object [] or I to int ."}
{"lang": "java", "code": "public <mask> getEventsRouted ( EventTypeID eventTypeID ) { long result = 0L ; for ( int i = 0 ; i < getExecutors ( ) . length ; i ++ ) { result += getEventsRouted ( i , eventTypeID ) ; } return result ; }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "public static boolean isConstant ( String expression , Map <mask> ) throws OgnlException { return isConstant ( parseExpression ( expression ) , context ) ; }", "comment": "Checks if the specified expression represents a constant expression ."}
{"lang": "java", "code": "public <mask> deleteObjectsAsync ( final @ NonNull Collection < String > objectIDs , @ Nullable CompletionHandler completionHandler ) { return deleteObjectsAsync ( objectIDs , /* requestOptions: */ null , completionHandler ) ; }", "comment": "Deletes several objects from this index ( asynchronously ) ."}
{"lang": "java", "code": "public static VectorByteBufferedIntegral4s64 createWithBase ( final ByteBuffer b , final MutableLongType base , final int offset ) { return new VectorByteBufferedIntegral4s64 ( b , <mask> , offset ) ; }", "comment": "<p > Return a new vector that is backed by the given byte buffer { @code b } < / p >"}
{"lang": "java", "code": "public static long <mask> ( InputStream inputStream , OutputStream outputStream ) throws IOException { return copy ( inputStream , outputStream , DEFAULT_CHUNK_SIZE ) ; }", "comment": "input - > output\u5b57\u8282\u6d41copy"}
{"lang": "java", "code": "public double maxAbs ( ) { double absX = Math . abs ( x ) ; double absY = Math . abs ( y ) ; double absZ = Math . abs ( z ) ; double absW = Math . abs ( w ) ; double found = Math . max ( absX , absY ) ; if ( found < absZ ) found = absZ ; if ( found < absW ) <mask> = absW ; return found ; }", "comment": "Returns the absolute value of the component with the largest absolute value"}
{"lang": "java", "code": "private void checkTaskSelectedViaBridge ( ) { <mask> bridgeTaskId = ( String ) getSharedSessionAttribute ( BRIDGE_TASK_ID ) ; String selectedTaskId = ( String ) getSharedSessionAttribute ( ASSOCIATED_TASK_ID ) ; if ( selectedTaskId == null && bridgeTaskId != null ) { switchTaskId ( bridgeTaskId ) ; } if ( selectedTaskId != null && bridgeTaskId != null && ! selectedTaskId . equals ( bridgeTaskId ) ) { // task switched, TODO: think about if correct like this switchTaskId ( bridgeTaskId ) ; } }", "comment": "lazy load task if bridge state has changed in the meantime"}
{"lang": "java", "code": "public boolean cancel ( boolean setFlag ) { final AtomicInteger stateRef = this . stateRef ; int oldVal , newVal ; do { oldVal = stateRef . get ( ) ; if ( oldVal == ST_WAITING ) { newVal = ST_CANCELLED ; } else if ( oldVal == ST_CANCELLED ) { if ( ! setFlag ) { return true ; } newVal = ST_CANCELLED_FLAG_SET ; } else if ( oldVal == ST_CANCELLED_FLAG_SET ) { // do nothing return true ; } else if ( oldVal == ST_STARTED ) { if ( ! setFlag ) { return false ; } newVal = ST_STARTED_FLAG_SET ; } else { assert oldVal == ST_STARTED_FLAG_SET ; return <mask> ; } } while ( ! stateRef . compareAndSet ( oldVal , newVal ) ) ; return newVal == ST_CANCELLED || newVal == ST_CANCELLED_FLAG_SET ; }", "comment": "Attempt to cancel the corresponding invocation ."}
{"lang": "java", "code": "private void push ( final ClassWriter cw , final String desc ) { int type = <mask> ( cw , desc ) ; if ( type != 0 ) { push ( type ) ; if ( type == LONG || type == DOUBLE ) { push ( TOP ) ; } } }", "comment": "Pushes a new type onto the output frame stack ."}
{"lang": "java", "code": "@ Override public void setRow ( final RowVector rv , final int r ) throws MatrixException { <mask> . setRow ( rv , r ) ; reset ( ) ; }", "comment": "Set a row of this matrix from a row vector ."}
{"lang": "java", "code": "private void mapFormContainerStatesTo ( Form previousMappedForm , ResultSet resultSetParam ) throws SQLException { if ( previousMappedForm == null ) { return ; } //Form Container State... Long formContainerState = resultSetParam . getLong ( SQLColumnIndex . _07_FORM_CONTAINER_STATE ) ; long formContStateId = ( formContainerState == null ) ? 0 : formContainerState . longValue ( ) ; if ( formContStateId > 0 ) { if ( formContStateId == 1 ) { previousMappedForm . setState ( Form . State . OPEN ) ; } else if ( formContStateId == 2 ) { previousMappedForm . setState ( Form . State . LOCKED ) ; } } Long formContainerFlowState = resultSetParam . getLong ( SQLColumnIndex . _08_FORM_CONTAINER_FLOW_STATE ) ; long formContFlowStateId = ( formContainerFlowState == null ) ? 0 : formContainerFlowState . longValue ( ) ; if ( formContFlowStateId > 0 ) { if ( formContFlowStateId == 1 ) { previousMappedForm . setFlowState ( FluidItem . FlowState . NotInFlow . name ( ) ) ; } else if ( formContFlowStateId == 2 ) { previousMappedForm . setFlowState ( FluidItem . FlowState . WorkInProgress . <mask> ( ) ) ; } else if ( formContFlowStateId == 3 ) { previousMappedForm . setFlowState ( FluidItem . FlowState . UserSend . name ( ) ) ; } else if ( formContFlowStateId == 4 ) { previousMappedForm . setFlowState ( FluidItem . FlowState . UserSendWorkInProgress . name ( ) ) ; } else if ( formContFlowStateId == 5 ) { previousMappedForm . setFlowState ( FluidItem . FlowState . Archive . name ( ) ) ; } } }", "comment": "Maps the Form states with the { @code resultSetParam } ."}
{"lang": "java", "code": "protected String valueToString ( final String name , final Object valueObject ) { if ( ! valueObject . getClass ( ) . isArray ( ) ) { return valueObject . toString ( ) ; } // array String [ ] array = ( String [ ] ) valueObject ; if ( valueNameIndexes == null ) { valueNameIndexes = new HashMap <> ( ) ; } MutableInteger index = valueNameIndexes . get ( name ) ; if ( index == null ) { index = new MutableInteger ( 0 ) ; valueNameIndexes . put ( name , index ) ; } if ( index . value >= array . length ) { return null ; } String result = array [ index . value ] ; <mask> . value ++ ; return result ; }", "comment": "Converts value to a string ."}
{"lang": "java", "code": "public static RadioInput build ( String name ) { RadioInput i = new RadioInput ( ) ; i . name = <mask> ; return i ; }", "comment": "order"}
{"lang": "java", "code": "public static Object cell ( Object maplist , String path ) { MaplRebuild mr = new MaplRebuild ( maplist ) ; return mr . cell ( <mask> ) ; }", "comment": "\u8bbf\u95eeMAP List\u7ed3\u6784\u7684\u6570\u636e \u901a\u8fc7 uers [ 2 ] . name \u8fd9\u79cd\u5f62\u5f0f ."}
{"lang": "java", "code": "public void addOneShotAfterTask ( final long fireAfter , final TimeUnit timeUnit , final Runnable <mask> ) { fireOnceAfterTasks . add ( new FireOnceTask ( task , timeUnit , fireAfter ) ) ; }", "comment": "Add a task that gets executed once ."}
{"lang": "java", "code": "private double getScaleFactor ( double lat_ts , boolean north ) { double e = 0.081819191 ; double tf = 1.0 , mf = 1.0 , k0 = 1.0 ; double root = ( 1 + e * Math . sin ( lat_ts ) ) / ( 1 - e * Math . sin ( lat_ts ) ) ; double power = e / 2 ; if ( north ) tf = Math . tan ( Math . PI / 4 - lat_ts / 2 ) * ( Math . pow ( root , power ) ) ; else tf = Math . tan ( Math . PI / 4 + lat_ts / 2 ) / ( Math . pow ( <mask> , power ) ) ; mf = Math . cos ( lat_ts ) / Math . sqrt ( 1 - e * e * Math . pow ( Math . sin ( lat_ts ) , 2 ) ) ; k0 = mf * Math . sqrt ( Math . pow ( 1 + e , 1 + e ) * Math . pow ( 1 - e , 1 - e ) ) / ( 2 * tf ) ; return Double . isNaN ( k0 ) ? 1.0 : k0 ; }", "comment": "Calculate polar stereographic scale factor based on the natural latitude and longitude of the original Ref : OGP Surveying and Positioning Guidance Note number 7 part 2 April 2009 http : // www . epsg . org added by Qun He <qunhe@unc . edu >"}
{"lang": "java", "code": "public void removeImageView ( CubeImageView imageView ) { if ( null == imageView || null == mFirstImageViewHolder ) { return ; } ImageViewHolder holder = mFirstImageViewHolder ; <mask> { if ( holder . contains ( imageView ) ) { // Make sure entry is right. if ( holder == mFirstImageViewHolder ) { mFirstImageViewHolder = holder . mNext ; } if ( null != holder . mNext ) { holder . mNext . mPrev = holder . mPrev ; } if ( null != holder . mPrev ) { holder . mPrev . mNext = holder . mNext ; } } } while ( ( holder = holder . mNext ) != null ) ; }", "comment": "Remove the ImageView from ImageTask"}
{"lang": "java", "code": "private boolean readNextRow ( ) { boolean hasNext = false ; try { if ( ! stop ) { String row = \"\" ; do { row = getReader ( ) . readLine ( ) ; } while ( row . length ( ) == 0 ) ; if ( ! row . startsWith ( \"{\\\"last_seq\\\":\" ) ) { setNextRow ( gson . fromJson ( row , Row . class ) ) ; hasNext = true ; } } } catch ( <mask> e ) { terminate ( ) ; throw new CouchDbException ( \"Error reading continuous stream.\" , e ) ; } if ( ! hasNext ) terminate ( ) ; return hasNext ; }", "comment": "Reads and sets the next feed in the stream ."}
{"lang": "java", "code": "public double [ ] elemLineToEarth ( int elem , int <mask> , double scale_x , double offset_x , double scale_y , double offset_y ) { return FGFtoEarth ( ( double ) elem , ( double ) line , scale_x , offset_x , scale_y , offset_y ) ; }", "comment": "Transform integer FGF coordinates to ( longitude latitude ) of pixel center The ( i j ) pixel zero - based refers to the pixel center ."}
{"lang": "java", "code": "public void ltrim ( final byte [ ] key , final long <mask> , final long end ) { sendCommand ( Command . LTRIM , key , RedisProtocol . toByteArray ( start ) , RedisProtocol . toByteArray ( end ) ) ; }", "comment": "Ltrim ."}
{"lang": "java", "code": "protected K standardFirstKey ( ) { Entry < K , V > entry = firstEntry ( ) ; if ( entry == null ) { throw new NoSuchElementException ( ) ; } else { return <mask> . getKey ( ) ; } }", "comment": "A sensible definition of {"}
{"lang": "java", "code": "public int readInt ( ) { if ( available ( ) < 4 ) { throw new RuntimeException ( \"not enough data available, check available() > 4 before calling\" ) ; } int ch1 = poll ( ) ; int ch2 = <mask> ( ) ; int ch3 = poll ( ) ; int ch4 = poll ( ) ; return ( ch4 << 24 ) + ( ch3 << 16 ) + ( ch2 << 8 ) + ( ch1 << 0 ) ; }", "comment": "read an int . throws an exception if not enough data is present"}
{"lang": "java", "code": "protected String parserRequiredWord ( final boolean iUpperCase , final String iCustomMessage , String iSeparators ) { if ( iSeparators == null ) iSeparators = \" ()=><,\\r\\n\" ; parserNextWord ( iUpperCase , iSeparators ) ; if ( parserLastWord . <mask> ( ) == 0 ) throwSyntaxErrorException ( iCustomMessage ) ; if ( parserLastWord . charAt ( 0 ) == ' ' && parserLastWord . charAt ( parserLastWord . length ( ) - 1 ) == ' ' ) { return parserLastWord . substring ( 1 , parserLastWord . length ( ) - 1 ) ; } return parserLastWord . toString ( ) ; }", "comment": "Parses the next word . If no word is found or the parsed word is not present in the word array received as parameter then a SyntaxError exception with the custom message received as parameter is thrown . It returns the word parsed if any ."}
{"lang": "java", "code": "public Session getSession ( String hostsAndPorts , String username , String password , String keyspace ) { return getSession ( hostsAndPorts , username , <mask> , keyspace , false ) ; }", "comment": "Obtain a Cassandra session instance ."}
{"lang": "java", "code": "public static String parseLocalAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( <mask> != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }", "comment": "Parse the local address of the channel ."}
{"lang": "java", "code": "public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException authException ) throws IOException , ServletException { String redirectUrl = null ; if ( useForward ) { if ( forceHttps && \"http\" . equals ( <mask> . getScheme ( ) ) ) { // First redirect the current request to HTTPS. // When that request is received, the forward to the login page will be // used. redirectUrl = buildHttpsRedirectUrlForRequest ( request ) ; } if ( redirectUrl == null ) { String loginForm = determineUrlToUseForThisRequest ( request , response , authException ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Server side forward to: \" + loginForm ) ; } RequestDispatcher dispatcher = request . getRequestDispatcher ( loginForm ) ; dispatcher . forward ( request , response ) ; return ; } } else { // redirect to login page. Use https if forceHttps true redirectUrl = buildRedirectUrlToLoginPage ( request , response , authException ) ; } redirectStrategy . sendRedirect ( request , response , redirectUrl ) ; }", "comment": "Performs the redirect ( or forward ) to the login form URL ."}
{"lang": "java", "code": "public PropertyGroup getPropertyGroup ( String basename , int index ) { String name = makeIndexPropertyName ( basename , index ) ; return getPropertyGroup ( <mask> ) ; }", "comment": "Get a property group for the given property base at the given index ."}
{"lang": "java", "code": "@ ManyToOne ( targetEntity = Topics . <mask> , cascade = { CascadeType . ALL } ) @ JoinColumn ( name = \"TOPICS_INDICATOR_ELEMENT_HJID\" ) public Topics getTopics ( ) { return topics ; }", "comment": "Gets the topics ."}
{"lang": "java", "code": "@ NonNull public static Intent newIntent ( @ NonNull <mask> context , @ NonNull SessionConfiguration sessionConfiguration , @ NonNull ResponseType responseType , boolean forceWebview ) { return newIntent ( context , new ArrayList < SupportedAppType > ( ) , sessionConfiguration , responseType , forceWebview , false , false ) ; }", "comment": "Create an { @link Intent } to pass to this activity"}
{"lang": "java", "code": "public void clearReceipt ( String receipt_id ) { synchronized ( _receipts ) { for ( Iterator i = _receipts . iterator ( ) ; i . hasNext ( ) ; ) { String o = ( String ) i . <mask> ( ) ; if ( o . equals ( receipt_id ) ) i . remove ( ) ; } } }", "comment": "Deletes all receipts with a given ID"}
{"lang": "java", "code": "public ObjectQueryInfo prepareObjectQuery ( Object obj ) throws MalformedObjectNameException { ObjectQueryInfo result ; // // Extract the mbean info from the object (TBD: cache this information ahead of time) // String onamePattern = MBeanAnnotationUtil . getLocationONamePattern ( obj ) ; if ( onamePattern != null ) { // // Locate the setters and continue only if at least one was found. // Map < String , Method > attributeSetters = MBeanAnnotationUtil . getAttributes ( obj ) ; if ( attributeSetters . size ( ) > 0 ) { String onameString ; if ( obj instanceof MBeanLocationParameterSource ) { onameString = this . parameterReplacer . replaceObjectNameParameters ( onamePattern , ( MBeanLocationParameterSource ) obj ) ; } else { onameString = onamePattern ; } ObjectName oname = new ObjectName ( onameString ) ; result = new ObjectQueryInfo ( obj , oname , attributeSetters ) ; } else { this . logNoAttributeThrottle . warn ( log , \"ignoring attempt to prepare to poll an MBean object with no attributes: onamePattern={}\" , onamePattern ) ; result = null ; } } else { log . warn ( \"ignoring attempt to prepare to poll object that has no MBeanLocation\" ) ; <mask> = null ; } return result ; }", "comment": "Prepare to query the given object ."}
{"lang": "java", "code": "@ GetMapping ( path = \"{region}/{key}\" , produces = \"application/json\" ) String getValueByKey ( @ PathVariable String region , @ PathVariable String key ) { try { if ( region == null || region . length ( ) == 0 || key == null ) return null ; Region < String , Object > gemRegion = geode . getRegion ( <mask> ) ; Object value = gemRegion . get ( key ) ; if ( value == null ) return null ; return gson . toJson ( value ) ; } catch ( ServerOperationException serverError ) { Throwable cause = serverError . getRootCause ( ) ; if ( cause instanceof RegionDestroyedException ) { throw new DataServiceSystemException ( \"Region \\\"\" + region + \"\\\" not found\" ) ; } throw new DataServiceSystemException ( serverError . getMessage ( ) , serverError ) ; } catch ( RuntimeException e ) { e . printStackTrace ( ) ; throw new DataServiceSystemException ( e . getMessage ( ) , e ) ; } }", "comment": "Get a value by a given key"}
{"lang": "java", "code": "public static ScriptEngine getEngine ( Collection < InputStream > <mask> ) { ScriptEngine engine = getEngine ( ) ; for ( InputStream script : scripts ) { evaluate ( engine , script ) ; } return engine ; }", "comment": "Get new nashorn engine ."}
{"lang": "java", "code": "@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . ERROR ) @ SchedulerSupport ( SchedulerSupport . COMPUTATION ) public static Flowable < Long > intervalRange ( long start , <mask> count , long initialDelay , long period , TimeUnit unit ) { return intervalRange ( start , count , initialDelay , period , unit , Schedulers . computation ( ) ) ; }", "comment": "Signals a range of long values the first after some initial delay and the rest periodically after . <p > The sequence completes immediately after the last value ( start + count - 1 ) has been reached . <dl > <dt > <b > Backpressure : < / b > < / dt > <dd > The operator signals a {"}
{"lang": "java", "code": "public void process ( ) { if ( ! start ( ) ) { String message = \"Could not start workers required for reasoner computation!\" ; LOGGER_ . error ( message ) ; throw new ElkRuntimeException ( <mask> ) ; } try { // submit the leftover from the previous run if ( nextInput != null ) { if ( ! processNextInput ( ) ) return ; } // repeatedly submit the next inputs from todo while ( todo . hasNext ( ) ) { nextInput = todo . next ( ) ; if ( ! processNextInput ( ) ) return ; } finish ( ) ; } catch ( InterruptedException e ) { // restore interrupt status Thread . currentThread ( ) . interrupt ( ) ; throw new ElkRuntimeException ( \"Reasoner computation interrupted externally!\" ) ; } }", "comment": "Process the given input concurrently using the provided input processor . If the process has been interrupted this method can be called again to continue the computation ."}
{"lang": "java", "code": "public void ssexpire ( final byte [ ] keyspace , final byte [ ] uid , final byte [ ] serviceCode , final <mask> [ ] key , long expireMillis ) { sendCommand ( Command . S3SEXPIRE , keyspace , uid , RedisProtocol . toByteArray ( expireMillis ) , serviceCode , key ) ; }", "comment": "Ssexpire ."}
{"lang": "java", "code": "<mask> void prcessDbFieldHeader ( JTable dbField ) { dbField . getColumn ( fieldNames [ 4 ] ) . setPreferredWidth ( 40 ) ; dbField . getColumn ( fieldNames [ 4 ] ) . setMinWidth ( 40 ) ; dbField . getColumn ( fieldNames [ 4 ] ) . setMaxWidth ( 40 ) ; dbField . getColumn ( fieldNames [ 5 ] ) . setPreferredWidth ( 40 ) ; dbField . getColumn ( fieldNames [ 5 ] ) . setMinWidth ( 40 ) ; dbField . getColumn ( fieldNames [ 5 ] ) . setMaxWidth ( 40 ) ; }", "comment": "\u5904\u7406\u6807\u9898\u5217\u7684\u5c45\u4e2d"}
{"lang": "java", "code": "public String encode ( Iterable < ? extends Cookie > cookies ) { if ( cookies == null ) { throw new NullPointerException ( \"cookies\" ) ; } Iterator < ? extends Cookie > cookiesIt = cookies . iterator ( ) ; if ( ! cookiesIt . hasNext ( ) ) { return null ; } StringBuilder buf = new StringBuilder ( ) ; while ( cookiesIt . hasNext ( ) ) { Cookie c = cookiesIt . next ( ) ; if ( c == null ) { <mask> ; } encode ( buf , c ) ; } return stripTrailingSeparatorOrNull ( buf ) ; }", "comment": "Encodes the specified cookies into a single Cookie header value ."}
{"lang": "java", "code": "public @ NotNull FileAssert hasSameContentAs ( @ NotNull File expected ) { checkNotNull ( expected ) ; isNotNull ( ) ; assertExists ( actual ) . assertExists ( expected ) ; try { LineDiff [ ] diffs = comparator . compareContents ( actual , expected ) ; if ( ! isNullOrEmpty ( diffs ) ) { <mask> ( expected , diffs ) ; } } catch ( IOException e ) { cannotCompareToExpectedFile ( expected , e ) ; } return this ; }", "comment": "Verifies that the content of the actual { @code File } is equal to the content of the given one . Adapted from <a href = http : // junit - addons . sourceforge . net / junitx / framework / FileAssert . html target = _blank > FileAssert< / a > ( from <a href = http : // sourceforge . net / projects / junit - addons > JUnit - addons< / a > . )"}
{"lang": "java", "code": "private void removeAllSupercededMemberContent ( final ArtifactStore store , final Map < ArtifactStore , ArtifactStore > changeMap ) { StoreKey key = store . getKey ( ) ; // we're only interested in groups, since only adjustments to group memberships can invalidate indexed content. if ( group == key . getType ( ) ) { List < StoreKey > newMembers = ( ( Group ) store ) . getConstituents ( ) ; logger . debug ( \"New members of: {} are: {}\" , store , newMembers ) ; Group group = ( Group ) changeMap . get ( store ) ; List < StoreKey > oldMembers = group . getConstituents ( ) ; logger . debug ( \"Old members of: {} are: {}\" , group , oldMembers ) ; int commonSize = Math . min ( newMembers . size ( ) , oldMembers . size ( ) ) ; int divergencePoint ; // look in the members that overlap in new/old groups and see if there are changes that would // indicate member reordering. If so, it might lead previously suppressed results to be prioritized, // which would invalidate part of the content index for the group. boolean foundDivergence = false ; for ( divergencePoint = 0 ; divergencePoint < commonSize ; divergencePoint ++ ) { logger . debug ( \"Checking for common member at index: {}\" , divergencePoint ) ; if ( ! oldMembers . <mask> ( divergencePoint ) . equals ( newMembers . get ( divergencePoint ) ) ) { foundDivergence = true ; break ; } } // [NOS-128] // 1. If membership has shrunk, we can remove origin-indexed paths, which will remove merged group content //      based on the removed member's content. // 2. If membership has grown, we should iterate new members' indexed content looking for mergable paths. //      For each of these, we need to removeIndexedStorePaths using the group and the mergable path. // [addendum] // 3. If membership is the same size but has been reordered, we need to iterate from the divergence point //    and invalidate the non-mergable files. This is because the reordering may change what artifacts //    should obscure which other physical artifacts. // // NOTE: In any case, once we isolate the changes, we need to handle matches in two ways: // 1. deleteTransfers() // 2. add the indexedStorePath to the removed Set so we can propagage their removal through any groups //      that include the one we're affecting directly here...using clearIndexedPathFrom() to do this. if ( ! foundDivergence ) { if ( newMembers . size ( ) < oldMembers . size ( ) ) { divergencePoint = commonSize ; } else { divergencePoint = newMembers . size ( ) ; } } logger . debug ( \"group membership divergence point: {}\" , divergencePoint ) ; Set < StoreKey > affectedMembers = new HashSet <> ( ) ; boolean removeMergableOnly = divergencePoint >= oldMembers . size ( ) ; // if we can iterate some old members that have been removed or reordered, invalidate the // group content index entries for those. if ( divergencePoint < oldMembers . size ( ) ) { for ( int i = divergencePoint ; i < oldMembers . size ( ) ; i ++ ) { affectedMembers . add ( oldMembers . get ( i ) ) ; } } else { // for new added members, need to clear the indexed path with this group store for repo metadata merging // See [NOS-128] for ( int i = divergencePoint - 1 ; i >= commonSize ; i -- ) { affectedMembers . add ( newMembers . get ( i ) ) ; } } logger . debug ( \"Got members affected by membership divergence: {}\" , affectedMembers ) ; if ( ! affectedMembers . isEmpty ( ) ) { Set < Group > groups = new HashSet <> ( ) ; groups . add ( group ) ; try { groups . addAll ( storeDataManager . query ( ) . packageType ( group . getPackageType ( ) ) . getGroupsAffectedBy ( group . getKey ( ) ) ) ; } catch ( IndyDataException e ) { logger . error ( String . format ( \"Cannot retrieve groups affected by: %s. Reason: %s\" , group . getKey ( ) , e . getMessage ( ) ) , e ) ; } logger . debug ( \"Got affected groups: {}\" , groups ) ; DrainingExecutorCompletionService < Integer > clearService = new DrainingExecutorCompletionService <> ( cleanupExecutor ) ; final Predicate < ? super String > mergableFilter = removeMergableOnly ? mergablePathStrings ( ) : ( p ) - > true ; // NOTE: We're NOT checking load for this executor, since this is an async process that is critical to // data integrity. affectedMembers . forEach ( ( memberKey ) - > { logger . debug ( \"Listing all {}paths in: {}\" , ( removeMergableOnly ? \"mergeable \" : \"\" ) , memberKey )  ; listPathsAnd ( memberKey , mergableFilter , p -> clearService . submit ( clearPathProcessor ( p , memberKey , groups ) ) ) ; } ) ; drainAndCount ( clearService , \"store: \" + store . getKey ( ) ) ; } }", "comment": "TODO : If we find points where a new HostedRepository is added we should be using its comprehensive index to minimize the index damage to the group ."}
{"lang": "java", "code": "public String formatSqlException ( SQLException ex ) { StringBuilder sb = new StringBuilder ( ) ; Set < String > messages = new HashSet <> ( ) ; for ( Throwable e : ex ) { if ( e instanceof SQLException ) { String message = e . getMessage ( ) ; if ( ! messages . add ( message ) ) { continue ; } sb . append ( \"SQLState: \" + ( ( SQLException ) e ) . getSQLState ( ) + \"\\n\" ) . append ( \"Error Code: \" + ( ( SQLException ) e ) . getErrorCode ( ) + \"\\n\" ) . append ( \"Message: \" + message + \"\\n\" ) ; Throwable t = <mask> . getCause ( ) ; while ( t != null ) { if ( messages . add ( t . getMessage ( ) ) ) { sb . append ( \"Cause: \" + t + \"\\n\" ) ; } t = t . getCause ( ) ; } } } return sb . toString ( ) ; }", "comment": "Formats the error message of a { @link java . sql . SQLException } for human consumption ."}
{"lang": "java", "code": "public void lset ( final String <mask> , final long index , final String value ) { lset ( SafeEncoder . encode ( key ) , index , SafeEncoder . encode ( value ) ) ; }", "comment": "Lset ."}
{"lang": "java", "code": "protected OBonsaiBucketPointer getBucketPointer ( int offset ) { final long pageIndex = getLongValue ( offset ) ; final int pageOffset = getIntValue ( <mask> + OLongSerializer . LONG_SIZE ) ; return new OBonsaiBucketPointer ( pageIndex , pageOffset ) ; }", "comment": "Read bucket pointer from page ."}
{"lang": "java", "code": "@ Override public boolean validate ( <mask> < String > warnings ) { // \u83b7\u53d6\u914d\u7f6e\u7684\u76ee\u6807package Properties properties = getProperties ( ) ; this . targetPackage = properties . getProperty ( PRO_TARGET_PACKAGE ) ; if ( this . targetPackage == null ) { warnings . add ( \"\u8bf7\u914d\u7f6ecom.itfsw.mybatis.generator.plugins.ExampleTargetPlugin\u63d2\u4ef6\u7684\u76ee\u6807\u5305\u540d(targetPackage)\uff01\");   return false ; } return super . validate ( warnings ) ; }", "comment": "{"}
{"lang": "java", "code": "public void setValues ( Variable v , List < String > values ) throws IllegalArgumentException { Array data = Array . makeArray ( v . getDataType ( ) , values ) ; if ( data . getSize ( ) != v . getSize ( ) ) throw new IllegalArgumentException ( \"Incorrect number of values specified for the Variable \" + v . getFullName ( ) + \" needed= \" + v . getSize ( ) + \" given=\" + <mask> . getSize ( ) ) ; if ( v . getRank ( ) != 1 ) // dont have to reshape for rank 1 data = data . reshape ( v . getShape ( ) ) ; v . setCachedData ( data , true ) ; }", "comment": "Set the data values from a list of Strings ."}
{"lang": "java", "code": "public void parseConstraint ( String constraint , String urlencoded ) throws ParseException , opendap . dap . DAP2Exception , NoSuchVariableException , NoSuchFunctionException , InvalidOperatorException , InvalidParameterException , SBHException , WrongTypeException { if ( clauseFactory == null ) { clauseFactory = new ClauseFactory ( ) ; } // Parses constraint expression (duh...) and sets the // projection flag for each member of the CE's ServerDDS // instance. This also builds the list of clauses. try { CeParser . constraint_expression ( this , _dds . getFactory ( ) , clauseFactory , constraint , urlencoded ) ; } catch ( ConstraintException ce ) { // convert to a DAP2Exception ce . printStackTrace ( ) ; throw new DAP2Exception ( ce ) ; } if ( _Debug ) { int it = 0 ; Enumeration ec = getClauses ( ) ; System . out . println ( \"Results of clause parsing:\" ) ; if ( ! ec . hasMoreElements ( ) ) System . out . println ( \"    No Clauses Found.\" ) ; while ( ec . hasMoreElements ( ) ) { <mask> ++ ; System . out . println ( \"    Clause \" + it + \": \" + ec . nextElement ( ) ) ; } } }", "comment": "Parse a constraint expression . Variables in the projection are marked as such in the CEEvaluator s ServerDDS instance . The selection subexpression is then parsed and a list of Clause objects is built . <p / > The parser is located in opendap . servers . parsers . CeParser ."}
{"lang": "java", "code": "@ Generated ( <mask> = \"com.sun.tools.xjc.Driver\" , date = \"2018-10-12T02:52:47+02:00\" , comments = \"JAXB RI v2.2.11\" ) public void setParkhaus ( JAXBElement < Object > value ) { this . parkhaus = value ; }", "comment": "Sets the value of the parkhaus property ."}
{"lang": "java", "code": "public void pause ( ) { try { lock . lock ( ) ; <mask> { released . await ( ) ; } catch ( InterruptedException e ) { // Exception set to null as compensation action of returning immediately with current thread interrupted // is taken. e = null ; Thread . currentThread ( ) . interrupt ( ) ; return ; } } finally { lock . unlock ( ) ; } }", "comment": "Pauses any calling thread until {"}
{"lang": "java", "code": "private AttributeSet getColumnAttributeOrNull ( int c ) { if ( ( c >= 0 ) && ( c < columnAttributes . <mask> ( ) ) ) { return columnAttributes . get ( c ) ; } else { return null ; } }", "comment": "Gets a columns attribute if possible without overflowing the underlying array ."}
{"lang": "java", "code": "public boolean insertAfter ( final AbstractHtml ... abstractHtmls ) { if ( parent == null ) { throw new NoParentException ( \"There must be a parent for this tag.\" ) ; } final Lock lock = sharedObject . getLock ( ACCESS_OBJECT ) . writeLock ( ) ; boolean result = false ; try { lock . lock ( ) ; final AbstractHtml [ ] childrenOfParent = <mask> . children . toArray ( new AbstractHtml [ parent . children . size ( ) ] ) ; for ( int i = 0 ; i < childrenOfParent . length ; i ++ ) { if ( equals ( childrenOfParent [ i ] ) ) { if ( i < ( childrenOfParent . length - 1 ) ) { return childrenOfParent [ i + 1 ] . insertBefore ( childrenOfParent , abstractHtmls ) ; } else { parent . appendChildrenLockless ( abstractHtmls ) ; } result = true ; } } } finally { lock . unlock ( ) ; } final PushQueue pushQueue = sharedObject . getPushQueue ( ACCESS_OBJECT ) ; if ( pushQueue != null ) { pushQueue . push ( ) ; } return result ; }", "comment": "Inserts the given tags after this tag . There must be a parent for this method tag . <br > Note : This { @code insertAfter } method might be bit slower ( in terms of nano optimization ) than { @code insertBefore } method as it internally uses { @code insertBefore } method . This will be improved in the future version ."}
{"lang": "java", "code": "public static AsyncOutputStream toAsyncOutputStream ( final ByteBuffer dstByteBuffer ) { notNull ( \"dstByteBuffer\" , dstByteBuffer ) ; return new AsyncOutputStream ( ) { @ Override public void <mask> ( final ByteBuffer srcByteBuffer , final SingleResultCallback < Integer > callback ) { transferDataFromByteBuffers ( srcByteBuffer , dstByteBuffer , callback ) ; } @ Override public void close ( final SingleResultCallback < Void > callback ) { callback . onResult ( null , null ) ; } } ; }", "comment": "Converts a { @link ByteBuffer } into a { @link AsyncOutputStream }"}
{"lang": "java", "code": "public static Field newPartitionMetadataFieldBuilder ( String database , String tableName , LinkedHashMap < String , String > partitionList , String location , boolean customLocation , HMPDataFormat dataFormat ) throws HiveStageCheckedException { LinkedHashMap < String , Field > metadata = new LinkedHashMap <> ( ) ; metadata . put ( VERSION , Field . create ( PARTITION_ADDITION_METADATA_RECORD_VERSION ) ) ; metadata . put ( METADATA_RECORD_TYPE , Field . create ( MetadataRecordType . PARTITION . <mask> ( ) ) ) ; metadata . put ( DATABASE_FIELD , Field . create ( database ) ) ; metadata . put ( TABLE_FIELD , Field . create ( tableName ) ) ; metadata . put ( LOCATION_FIELD , Field . create ( location ) ) ; metadata . put ( CUSTOM_LOCATION , Field . create ( customLocation ) ) ; metadata . put ( DATA_FORMAT , Field . create ( dataFormat . name ( ) ) ) ; //fill in the partition list here metadata . put ( PARTITION_FIELD , generateInnerFieldFromTheList ( partitionList , PARTITION_NAME , PARTITION_VALUE , false ) ) ; return Field . createListMap ( metadata ) ; }", "comment": "Fill in metadata to Record . This is for new partition creation . Use the {"}
{"lang": "java", "code": "@ Override public void enqueueRepairRecord ( final ORecordId rid ) { if ( ! active ) return ; if ( rid == null || ! rid . isPersistent ( ) ) return ; if ( rid . getClusterPosition ( ) < - 1 ) // SKIP TRANSACTIONAL RIDS return ; recordProcessed . incrementAndGet ( ) ; // ADD RECORD TO REPAIR records . <mask> ( rid , Boolean . TRUE ) ; }", "comment": "Adds the record to repair int the map of records and cluster . The decision about repairing is taken by the timer task ."}
{"lang": "java", "code": "public S isNotInstanceOfAny ( Class < ? > ... <mask> ) { objects . assertIsNotInstanceOfAny ( description , actual , types ) ; return myself ; }", "comment": "Verifies that the <em > actual< / em > value is not an instance of any of the given types ."}
{"lang": "java", "code": "public JSONResult getJSON ( URL url ) { try { logger . debug ( \"Requesting {}\" , url ) ; StringBuilder text = new StringBuilder ( ) ; String line ; HttpURLConnection urlconn = ( HttpURLConnection ) <mask> . openConnection ( ) ; urlconn . setReadTimeout ( msTimeout ) ; urlconn . setConnectTimeout ( msTimeout ) ; urlconn . setRequestMethod ( \"GET\" ) ; urlconn . connect ( ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( urlconn . getInputStream ( ) ) ) ; while ( ( line = br . readLine ( ) ) != null ) { text . append ( line ) ; } return new JSONResult ( text . toString ( ) ) ; } catch ( Throwable e ) { throw new FireRESTException ( url . toString ( ) , e ) ; } }", "comment": "HTTP GET json from given URL resource ."}
{"lang": "java", "code": "public static ServiceName getServiceName ( final String appName , final String moduleName , final String beanName , final String viewClassName ) { final ServiceName serviceName ; if ( appName != null ) { serviceName = BASE_SERVICE_NAME . append ( appName ) ; } else { serviceName = BASE_SERVICE_NAME ; } return serviceName . append ( moduleName ) . append ( beanName ) . <mask> ( viewClassName ) ; }", "comment": "Returns a { @link ServiceName } for the { @link EJBViewMethodSecurityAttributesService }"}
{"lang": "java", "code": "@ Override public JSONObject toJsonObject ( ) throws JSONException { JSONObject returnVal = super . toJsonObject ( ) ; //Client ID... if ( this . getClientId ( ) != null ) { returnVal . put ( JSONMapping . CLIENT_ID , this . getClientId ( ) ) ; } //Client Secret... if ( this . getClientSecret ( ) != null ) { returnVal . put ( JSONMapping . CLIENT_SECRET , this . getClientSecret ( ) ) ; } //Code... if ( this . getCode ( ) != null ) { returnVal . <mask> ( JSONMapping . CODE , this . getCode ( ) ) ; } //Grant Type... if ( this . getGrantType ( ) != null ) { returnVal . put ( JSONMapping . GRANT_TYPE , this . getGrantType ( ) ) ; } //Redirect URI... if ( this . getRedirectUri ( ) != null ) { returnVal . put ( JSONMapping . REDIRECT_URI , this . getRedirectUri ( ) ) ; } return returnVal ; }", "comment": "Conversion to { @code JSONObject } from Java Object ."}
{"lang": "java", "code": "public void writeTo ( OutputStream <mask> ) throws IOException { for ( int i = 0 ; i < slabs . size ( ) - 1 ; i ++ ) { writeToOutput ( out , slabs . get ( i ) , slabs . get ( i ) . position ( ) ) ; } writeToOutput ( out , currentSlab , currentSlabIndex ) ; }", "comment": "Writes the complete contents of this buffer to the specified output stream argument . the output stream s write method <code > out . write ( slab 0 slab . length ) < / code > ) will be called once per slab ."}
{"lang": "java", "code": "public <mask> getFileFromRenamedFiles ( int index ) { CheckUtilities . checkIntIndexInListRange ( renamedFilesToCommit , index ) ; return renamedFilesToCommit . get ( index ) ; }", "comment": "Returns the file at the specified index in the list of renamed files ."}
{"lang": "java", "code": "public static < TExpression > BsonField <mask> ( final String fieldName , final TExpression expression ) { return accumulator ( \"$last\" , fieldName , expression ) ; }", "comment": "Gets a field name for a $group operation representing the value of the given expression when applied to the last member of the group ."}
{"lang": "java", "code": "private void gatherDisjunctionsExploreArgument ( Term term , List < Term > expressions ) { if ( term instanceof Disjunction ) { gatherDisjunctions ( ( Disjunction ) term , expressions ) ; } else { expressions . <mask> ( term ) ; } }", "comment": "Explores one argument of a disjunction as part of the { @link #gatherDisjunctions ( Disjunction List ) } function ."}
{"lang": "java", "code": "private void processExceptionForSingleCommand ( RemotingContext ctx , Object msg , Throwable t ) { final int id = ( ( RpcCommand ) msg ) . getId ( ) ; final String emsg = \"Exception caught when processing \" + ( ( msg instanceof RequestCommand ) ? \"request, id=\" : \"response, id=\" ) ; logger . warn ( emsg + id , t ) ; if ( msg instanceof RequestCommand ) { final RequestCommand cmd = ( RequestCommand ) msg ; if ( cmd . getType ( ) != RpcCommandType . REQUEST_ONEWAY ) { if ( t instanceof RejectedExecutionException ) { final ResponseCommand response = this . commandFactory . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ; // RejectedExecutionException here assures no response has been sent back // Other exceptions should be processed where exception was caught, because here we don't known whether ack had been sent back. ctx . getChannelContext ( ) . writeAndFlush ( response ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture <mask> ) throws Exception { if ( future . isSuccess ( ) ) { if ( logger . isInfoEnabled ( ) ) { logger . info ( \"Write back exception response done, requestId={}, status={}\" , id , response . getResponseStatus ( ) ) ; } } else { logger . error ( \"Write back exception response failed, requestId={}\" , id , future . cause ( ) ) ; } } } ) ; } } } }", "comment": "/ * Return error command if necessary ."}
{"lang": "java", "code": "public final Flux < T > filterWhen ( Function < ? super T , ? extends <mask> < Boolean > > asyncPredicate , int bufferSize ) { return onAssembly ( new FluxFilterWhen <> ( this , asyncPredicate , bufferSize ) ) ; }", "comment": "Test each value emitted by this { @link Flux } asynchronously using a generated { @code Publisher<Boolean > } test . A value is replayed if the first item emitted by its corresponding test is { @literal true } . It is dropped if its test is either empty or its first emitted value is { @literal false } . <p > Note that only the first value of the test publisher is considered and unless it is a { @link Mono } test will be cancelled after receiving that first value . Test publishers are generated and subscribed to in sequence ."}
{"lang": "java", "code": "@ Override public void trace ( final String format , final Object first , final <mask> second ) { _log ( ) . debug ( _format ( format , first , second ) ) ; }", "comment": "{"}
{"lang": "java", "code": "@ Override public Object getId ( ) { if ( rawElement == null ) // CREATE A TEMPORARY ID return vOut . getIdentity ( ) + \"->\" + vIn . getIdentity ( ) ; setCurrentGraphInThreadLocal ( ) ; return <mask> . getId ( ) ; }", "comment": "Returns the Edge Id assuring to save it if it s transient yet ."}
{"lang": "java", "code": "public CandidateList getByElection ( String electionId ) throws VoteSmartException , VoteSmartErrorException { return api . <mask> ( \"Candidates.getByElection\" , new ArgMap ( \"electionId\" , electionId ) , CandidateList . class ) ; }", "comment": "This method grabs a list of candidates according to a fuzzy lastname match ."}
{"lang": "java", "code": "public <mask> < String , List < MetadataInfo > > dbMigrate ( final MigrationPlan migrationPlan , final MigratoryOption ... options ) throws MigratoryException { init ( ) ; final InternalMigrator migrator = new InternalMigrator ( this ) ; return migrator . migrate ( migrationPlan , options ) ; }", "comment": "Bring the current database to the requested levels ."}
{"lang": "java", "code": "public static void addMetadata ( final HttpURLConnection request , final Map < String , String > metadata , final OperationContext opContext ) { if ( metadata != null ) { for ( final <mask> < String , String > entry : metadata . entrySet ( ) ) { addMetadata ( request , entry . getKey ( ) , entry . getValue ( ) , opContext ) ; } } }", "comment": "Adds the metadata ."}
{"lang": "java", "code": "@ Deprecated public static < T , E > Collector < T , ? , ImmutableMultiset < E > > toImmutableMultiset ( Function < ? <mask> T , ? extends E > elementFunction , ToIntFunction < ? super T > countFunction ) { throw new UnsupportedOperationException ( ) ; }", "comment": "Not supported . Use { @link ImmutableSortedMultiset#toImmutableSortedMultiset } instead . This method exists only to hide { @link ImmutableMultiset#toImmutableMultiset } from consumers of { @code ImmutableSortedMultiset } ."}
{"lang": "java", "code": "public int getEncodedLength ( byte [ ] data ) { if ( <mask> == null ) { throw new NullPointerException ( \"data\" ) ; } long len = 0 ; for ( byte b : data ) { len += lengths [ b & 0xFF ] ; } return ( int ) ( ( len + 7 ) >> 3 ) ; }", "comment": "Returns the number of bytes required to Huffman encode the input string literal ."}
{"lang": "java", "code": "public @ NotNull StringAssert contains ( String expected ) { isNotNull ( ) ; if ( <mask> . indexOf ( expected ) != - 1 ) { return this ; } failIfCustomMessageIsSet ( ) ; throw failure ( format ( \"<%s> should contain the String:<%s>\" , actual , expected ) ) ; }", "comment": "Verifies that the actual { @code String } contains the given one ."}
{"lang": "java", "code": "public RhinoScriptBuilder evaluateChain ( final String script , final String sourceName ) { notNull ( script ) ; getContext ( ) . evaluateString ( <mask> , script , sourceName , 1 , null ) ; return this ; }", "comment": "Evaluates a script and return { @link RhinoScriptBuilder } for a chained script evaluation ."}
{"lang": "java", "code": "protected HashEntry < K , V > getEntry ( Object key ) { if ( key == null ) { return null ; } else { return super . getEntry ( <mask> ) ; } }", "comment": "Gets the entry mapped to the key specified ."}
{"lang": "java", "code": "@ Override public OCompositeKey deserializeFromByteBufferObject ( ByteBuffer buffer , OWALChanges walChanges , int offset ) { final OCompositeKey compositeKey = new OCompositeKey ( ) ; offset += OIntegerSerializer . INT_SIZE ; final int keysSize = walChanges . getIntValue ( buffer , offset ) ; <mask> += OIntegerSerializer . INT_SIZE ; final OBinarySerializerFactory factory = OBinarySerializerFactory . getInstance ( ) ; for ( int i = 0 ; i < keysSize ; i ++ ) { final byte serializerId = walChanges . getByteValue ( buffer , offset ) ; offset += OBinarySerializerFactory . TYPE_IDENTIFIER_SIZE ; @ SuppressWarnings ( \"unchecked\" ) OBinarySerializer < Object > binarySerializer = ( OBinarySerializer < Object > ) factory . getObjectSerializer ( serializerId ) ; final Object key = binarySerializer . deserializeFromByteBufferObject ( buffer , walChanges , offset ) ; compositeKey . addKey ( key ) ; offset += binarySerializer . getObjectSize ( key ) ; } return compositeKey ; }", "comment": "{"}
{"lang": "java", "code": "protected String parseString ( String v ) { /*\n\t\t * Parsing a string requires several steps to be taken. First, we need\n\t\t * to strip quotes from the ends of the string.\n\t\t */ v = v . substring ( 1 , v . length ( ) - 1 ) ; StringBuffer result = new StringBuffer ( ) ; // Second, step through the string and replace escaped characters for ( int i = 0 ; i < v . length ( ) ; i ++ ) { if ( v . charAt ( i ) == ' ' ) { if ( v . length ( ) <= i + 1 ) { throw new RuntimeException ( \"unexpected end-of-string\" ) ; } else { char replace = 0 ; int len = 2 ; switch ( v . charAt ( i + 1 ) ) { case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; case ' ' : replace = ' ' ; break ; <mask> ' ' : len = 6 ; // unicode escapes are six digits long, // including \"slash u\" String unicode = v . substring ( i + 2 , i + 6 ) ; replace = ( char ) Integer . parseInt ( unicode , 16 ) ; // unicode i = i + 5 ; break ; default : throw new RuntimeException ( \"unknown escape character\" ) ; } result = result . append ( replace ) ; i = i + 1 ; } } else { result = result . append ( v . charAt ( i ) ) ; } } return result . toString ( ) ; }", "comment": "Parse a string constant whilst interpreting all escape characters ."}
{"lang": "java", "code": "public static < T > T ensure ( T o , Matcher < ? > matcher ) { getProvider ( ) . ensurePolicy ( ) . <mask> ( matcherContract ( o , matcher ) ) ; return o ; }", "comment": "Postcondition that supplier are supposed to ensure . Violations are considered to be programming errors on the suppliers part ."}
{"lang": "java", "code": "public static String encode ( final String string , final String encoding ) { return encodeUriComponent ( <mask> , encoding , URIPart . UNRESERVED ) ; }", "comment": "Encodes string using default RFCP rules ."}
{"lang": "java", "code": "public void collapse ( ) { if ( defaults != null ) { Enumeration keysEnum = defaults . <mask> ( ) ; while ( keysEnum . hasMoreElements ( ) ) { String key = ( String ) keysEnum . nextElement ( ) ; put ( key , get ( key ) ) ; } defaults = null ; } }", "comment": "Copy all the default values into the receiver ."}
{"lang": "java", "code": "private static Map < String , Set > compareAndAggregate ( Map sourceMap , Map targetMap ) { //keys witch values are different System . out . println ( \"compare maps\" ) ; System . out . println ( \"source: \" + sourceMap ) ; System . out . println ( \"target: \" + targetMap ) ; Map < String , Set > aggregationInfo = new HashMap < String , Set > ( ) ; Set < Object > keysForDiffValues = new HashSet < Object > ( ) ; for ( Object regionKey : targetMap . keySet ( ) ) { if ( ! targetMap . <mask> ( regionKey ) . equals ( sourceMap . get ( regionKey ) ) ) //we compare not original values, but it's hash code keysForDiffValues . add ( regionKey ) ; } aggregationInfo . put ( \"diffValues\" , keysForDiffValues ) ; return aggregationInfo ; }", "comment": "compare two snapshots from source and target maps format : key : absentKeys or map"}
{"lang": "java", "code": "private void parseImplicitTld ( JspCompilationContext ctxt , String path ) throws JasperException { InputStream is = null ; TreeNode tld = null ; try { URL uri = ctxt . getResource ( path ) ; if ( uri == null ) { // no implicit.tld return ; } is = uri . openStream ( ) ; /* SJSAS 6384538\n            tld = new ParserUtils().parseXMLDocument(IMPLICIT_TLD, is);\n            */ // START SJSAS 6384538 tld = new ParserUtils ( ) . parseXMLDocument ( IMPLICIT_TLD , is , ctxt . getOptions ( ) . isValidationEnabled ( ) ) ; // END SJSAS 6384538 } catch ( Exception ex ) { throw new JasperException ( ex ) ; } finally { if ( is != null ) { try { is . close ( ) ; } catch ( Throwable t ) { } } } this . jspversion = tld . findAttribute ( \"version\" ) ; Iterator list = tld . findChildren ( ) ; while ( list . hasNext ( ) ) { TreeNode element = ( TreeNode ) list . next ( ) ; String tname = element . getName ( ) ; if ( \"tlibversion\" . equals ( tname ) || \"tlib-version\" . equals ( tname ) ) { this . tlibversion = element . getBody ( ) ; } else if ( \"jspversion\" . equals ( tname ) || \"jsp-version\" . equals ( tname ) ) { this . jspversion = <mask> . getBody ( ) ; } else if ( ! \"shortname\" . equals ( tname ) && ! \"short-name\" . equals ( tname ) ) { err . jspError ( \"jsp.error.implicitTld.additionalElements\" , path , tname ) ; } } // JSP version in implicit.tld must be 2.0 or greater Double jspVersionDouble = Double . valueOf ( this . jspversion ) ; if ( Double . compare ( jspVersionDouble , Constants . JSP_VERSION_2_0 ) < 0 ) { err . jspError ( \"jsp.error.implicitTld.jspVersion\" , path , this . jspversion ) ; } }", "comment": "Parses the JSP version and tlib - version from the implicit . tld at the given path ."}
{"lang": "java", "code": "protected Type getType ( ) throws EFapsException { init ( ) ; final Type ret ; if ( getValues ( ) . isEmpty ( ) ) { final List < EventDefinition > events = getCommand ( ) . getEvents ( EventType . UI_TABLE_EVALUATE ) ; String typeName = null ; if ( events . size ( ) > 1 ) { throw new EFapsException ( this . getClass ( ) , \"execute4NoInstance.moreThanOneEvaluate\" ) ; } else { final EventDefinition event = events . get ( 0 ) ; // test for basic or abstract types if ( event . getProperty ( \"Type\" ) != null ) { typeName = event . getProperty ( \"Type\" ) ; } // no type yet search alternatives if ( typeName == null ) { for ( int i = 1 ; i < 100 ; i ++ ) { final String nameTmp = \"Type\" + String . format ( \"%02d\" , i ) ; if ( event . getProperty ( nameTmp ) != null ) { typeName = event . getProperty ( nameTmp ) ; } else { break ; } } } } <mask> = typeName == null ? null : Type . get ( typeName ) ; } else { ret = getValues ( ) . get ( 0 ) . getInstance ( ) . getType ( ) ; } return ret ; }", "comment": "Method used to evaluate the type for this table from the connected events ."}
{"lang": "java", "code": "<mask> void setConcepts ( FSList v ) { if ( AbstractQuery_Type . featOkTst && ( ( AbstractQuery_Type ) jcasType ) . casFeat_concepts == null ) jcasType . jcas . throwFeatMissing ( \"concepts\" , \"edu.cmu.lti.oaqa.type.retrieval.AbstractQuery\" ) ; jcasType . ll_cas . ll_setRefValue ( addr , ( ( AbstractQuery_Type ) jcasType ) . casFeatCode_concepts , jcasType . ll_cas . ll_getFSRef ( v ) ) ; }", "comment": "setter for concepts - sets The list of query concepts that make up this abstract query . The list is ordered ."}
{"lang": "java", "code": "public static StorageException translateClientException ( final Exception <mask> ) { return new StorageException ( \"Client error\" , \"A Client side exception occurred, please check the inner exception for details\" , Constants . HeaderConstants . HTTP_UNUSED_306 , null , cause ) ; }", "comment": "RESERVED FOR INTERNAL USE . Translates the specified exception into a storage exception ."}
{"lang": "java", "code": "protected void upgradeMieteinnahmenElements ( Document doc ) throws JaxenException { List nodes = XmlUtils . newXPath ( \"/io:openimmo/io:anbieter/io:immobilie/io:preise/io:mieteinnahmen_ist |\" + \"/io:openimmo/io:anbieter/io:immobilie/io:preise/io:mieteinnahmen_soll\" , doc ) . selectNodes ( <mask> ) ; for ( Object item : nodes ) { Element node = ( Element ) item ; node . setAttribute ( \"periode\" , \"JAHR\" ) ; } }", "comment": "Upgrade &lt ; mieteinnahmen_ist&gt ; &lt ; mieteinnahmen_soll&gt ; elements to OpenImmo 1 . 2 . 0 . <p > The periode attribute with the value JAHR is added to any &lt ; mieteinnahmen_ist&gt ; and &lt ; mieteinnahmen_soll&gt ; elements ."}
{"lang": "java", "code": "public static ProfileFieldsFragment newInstance ( ProfileField < ? > [ ] fieldsToShow ) { if ( fieldsToShow == null ) { throw new NullPointerException ( ) ; } Bundle b = new Bundle ( ) ; b . putStringArray ( EXTRA_FIELDS_TO_SHOW , ProfileField . toIdentifierList ( fieldsToShow ) ) ; ProfileFieldsFragment instance = new ProfileFieldsFragment ( ) ; instance . setArguments ( b ) ; return <mask> ; }", "comment": "Creates a new instance of { @link ProfileFieldsFragment } to show the given list of profile fields ."}
{"lang": "java", "code": "@ BackpressureSupport ( BackpressureKind . UNBOUNDED_IN ) @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Maybe < T > timeout ( <mask> < U > timeoutIndicator ) { ObjectHelper . requireNonNull ( timeoutIndicator , \"timeoutIndicator is null\" ) ; return RxJavaPlugins . onAssembly ( new MaybeTimeoutPublisher < T , U > ( this , timeoutIndicator , null ) ) ; }", "comment": "If the current {"}
{"lang": "java", "code": "public void contextDestroyed ( ServletContextEvent event ) { if ( ioc ( ) != null ) { Ioc ioc = ioc ( ) ; if ( ioc instanceof NutIoc ) { boolean deposed = ( Boolean ) Mirror . <mask> ( ioc ) . getValue ( ioc , \"deposed\" ) ; if ( ! deposed ) ioc . depose ( ) ; } } }", "comment": "\u5bb9\u5668\u9500\u6bc1\u65f6 \u68c0\u67e5Ioc\u662f\u5426\u5df2\u7ecf\u5173\u95ed \u6ca1\u6709\u7684\u8bdd\u5c31\u5173\u95ed\u4e4b ."}
{"lang": "java", "code": "private Control createDefaultPage ( FormToolkit kit ) { Form form = kit . createForm ( book ) ; Composite body = form . getBody ( ) ; GridLayout layout = new GridLayout ( 2 , false ) ; body . setLayout ( layout ) ; Link hlink = new Link ( body , SWT . NONE ) ; hlink . setText ( \"<a>Use the Servers View to create a new server...</a>\" ) ; hlink . setBackground ( book . getDisplay ( ) . getSystemColor ( SWT . COLOR_LIST_BACKGROUND ) ) ; GridData gd = new GridData ( SWT . LEFT , SWT . FILL , true , false ) ; hlink . setLayoutData ( gd ) ; hlink . addSelectionListener ( new SelectionAdapter ( ) { public void widgetSelected ( SelectionEvent e ) { // show Servers View ViewUtils . showServersView ( ) ; } } ) ; // Create the context menu for the default page final CommonViewer commonViewer = this . getCommonViewer ( ) ; if ( commonViewer != null ) { ICommonViewerSite commonViewerSite = CommonViewerSiteFactory . createCommonViewerSite ( this . getViewSite ( ) ) ; if ( commonViewerSite != null ) { // Note: actionService cannot be null final NavigatorActionService actionService = new NavigatorActionService ( commonViewerSite , commonViewer , commonViewer . getNavigatorContentService ( ) ) ; MenuManager menuManager = new MenuManager ( \"#PopupMenu\" ) ; menuManager . addMenuListener ( new IMenuListener ( ) { public void menuAboutToShow ( IMenuManager mgr ) { ISelection selection = commonViewer . getSelection ( ) ; actionService . setContext ( new ActionContext ( <mask> ) ) ; actionService . fillContextMenu ( mgr ) ; } } ) ; Menu menu = menuManager . createContextMenu ( body ) ; // It is necessary to set the menu in two places: // 1. The white space in the server view // 2. The text and link in the server view. If this menu is not // set, if the // user right clicks on the text or uses shortcut keys to open // the context menu, // the context menu will not come up body . setMenu ( menu ) ; hlink . setMenu ( menu ) ; } else { // if (Trace.FINEST) { // Trace.trace(Trace.STRING_FINEST, // \"The commonViewerSite is null\"); // } } } else { // if (Trace.FINEST) { // Trace.trace(Trace.STRING_FINEST, \"The commonViewer is null\"); // } } return form ; }", "comment": "Creates a page displayed when there are no servers defined ."}
{"lang": "java", "code": "public String annotationToHELM2 ( ) { if ( ! ( annotationSection . isEmpty ( ) ) ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < annotationSection . size ( ) ; i ++ ) { sb . append ( annotationSection . <mask> ( i ) . toHELM2 ( ) + \"|\" ) ; } sb . setLength ( sb . length ( ) - 1 ) ; return sb . toString ( ) ; } return \"\" ; }", "comment": "method to generate a valid HELM2 string for the fourth section"}
{"lang": "java", "code": "public static IPv6Address fromInet6Address ( final Inet6Address inet6Address ) { final byte [ ] bytes = inet6Address . getAddress ( ) ; final short [ ] pieces = new short [ 8 ] ; for ( int i = 0 ; i < pieces . length ; i ++ ) { pieces [ i ] = ( short ) ( ( ( <mask> [ i * 2 ] & 0xFF ) << 8 ) | ( bytes [ i * 2 + 1 ] & 0x00FF ) ) ; } return new IPv6Address ( pieces ) ; }", "comment": "Convert from @ { java . net . Inet6Address } ."}
{"lang": "java", "code": "@ SuppressWarnings ( { \"unchecked\" , \"rawtypes\" } ) @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < K > Observable < GroupedObservable < K , T > > groupBy ( Function < ? super T , ? extends K > keySelector ) { return groupBy ( keySelector , ( Function ) Functions . identity ( ) , <mask> , bufferSize ( ) ) ; }", "comment": "Groups the items emitted by an { @code ObservableSource } according to a specified criterion and emits these grouped items as { @link GroupedObservable } s . The emitted { @code GroupedObservableSource } allows only a single { @link Observer } during its lifetime and if this { @code Observer } calls dispose () before the source terminates the next emission by the source having the same key will trigger a new { @code GroupedObservableSource } emission . <p > <img width = 640 height = 360 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / groupBy . png alt = > <p > <em > Note : < / em > A { @link GroupedObservable } will cache the items it is to emit until such time as it is subscribed to . For this reason in order to avoid memory leaks you should not simply ignore those { @code GroupedObservableSource } s that do not concern you . Instead you can signal to them that they may discard their buffers by applying an operator like { @link #ignoreElements } to them . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code groupBy } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl >"}
{"lang": "java", "code": "public Node getFirstChild ( ) { if ( childNodes == null ) { return null ; } if ( childNodes . isEmpty ( ) ) { return null ; } return childNodes . <mask> ( 0 ) ; }", "comment": "Returns first child or <code > null< / code > if no children exist ."}
{"lang": "java", "code": "public static Cnd from ( Dao dao , <mask> obj ) { return from ( dao , obj , dftFromFieldMatcher ) ; }", "comment": "\u7528\u9ed8\u8ba4\u89c4\u5219 ( \u5ffd\u7565\u96f6\u503c\u548c\u7a7a\u503c ) \u751f\u6210Cnd\u5b9e\u4f8b"}
{"lang": "java", "code": "public ResourceType getResourceType ( final HttpServletRequest request ) { Validate . notNull ( request ) ; final String uri = request . getRequestURI ( ) ; Validate . notNull ( uri ) ; ResourceType type = null ; <mask> { type = ResourceType . get ( FilenameUtils . getExtension ( stripSessionID ( uri ) ) ) ; } catch ( final IllegalArgumentException e ) { LOG . debug ( \"[FAIL] Cannot identify resourceType for uri: {}\" , uri ) ; } return type ; }", "comment": "Extracts the resource type by parsing the uri & finds the extension . If extension is valid ( css or js ) returns corresponding ResourceType otherwise throws exception . <p > Valid examples of uri are : <code > / context / somePath / test . js< / code > or <code > / context / somePath / test . css< / code > {"}
{"lang": "java", "code": "protected String parsePath ( String currentActionPath , String url ) { if ( url . startsWith ( SLASH ) ) { return url . split ( \"\\\\?\" ) [ 0 ] ; } else if ( ! url . contains ( SLASH ) ) { return SLASH + currentActionPath . split ( SLASH ) [ 1 ] + SLASH + url . split ( \"\\\\?\" ) [ 0 ] ; } else if ( url . contains ( \"http:\" ) || url . contains ( \"https:\" ) ) { return null ; } ///abc/def\",\"bcd/efg?abc return currentActionPath + SLASH + <mask> . split ( \"\\\\?\" ) [ 0 ] ; }", "comment": "Based on the current path structure is going to jump full Action of the path"}
{"lang": "java", "code": "private void updateMaskIfNecessary ( long now ) { final long timeElapsedSinceLastMaskUpdateCheck = now - lastMaskCheck ; lastMaskCheck = now ; if ( timeElapsedSinceLastMaskUpdateCheck < MASK_INCREASE_THRESHOLD && ( mask < MAX_MASK ) ) { mask = ( <mask> << 1 ) | 1 ; } else if ( timeElapsedSinceLastMaskUpdateCheck > MASK_DECREASE_THRESHOLD ) { mask = mask >>> 2 ; } }", "comment": "update the mask so as to execute change detection code about once every 100 to 8000 milliseconds ."}
{"lang": "java", "code": "@ Override public Timestamp get ( final ResultSet rs , final int index , final int dbSqlType ) throws SQLException { return <mask> . getTimestamp ( index ) ; }", "comment": "{"}
{"lang": "java", "code": "public final < V > Flux < T > distinct ( Function < ? <mask> T , ? extends V > keySelector ) { return distinct ( keySelector , hashSetSupplier ( ) ) ; }", "comment": "For each { @link Subscriber } track elements from this { @link Flux } that have been seen and filter out duplicates as compared by a key extracted through the user provided { @link Function } ."}
{"lang": "java", "code": "private int updateStopTimesForPatternStop ( ObjectNode patternStop , int previousTravelTime ) throws SQLException { String sql = String . format ( \"update %s.stop_times st set arrival_time = ?, departure_time = ? from %s.trips t \" + \"where st.trip_id = t.trip_id AND t.pattern_id = ? AND st.stop_sequence = ?\" , tablePrefix , tablePrefix ) ; // Prepare the statement and set statement parameters PreparedStatement statement = connection . prepareStatement ( sql ) ; int oneBasedIndex = 1 ; int travelTime = patternStop . get ( \"default_travel_time\" ) . asInt ( ) ; int arrivalTime = previousTravelTime + travelTime ; statement . setInt ( oneBasedIndex ++ , arrivalTime ) ; int dwellTime = patternStop . get ( \"default_dwell_time\" ) . asInt ( ) ; statement . setInt ( oneBasedIndex ++ , arrivalTime + dwellTime ) ; // Set \"where clause\" with value for pattern_id and stop_sequence statement . setString ( oneBasedIndex ++ , patternStop . get ( \"pattern_id\" ) . asText ( ) ) ; // In the editor, we can depend on stop_times#stop_sequence matching pattern_stops#stop_sequence because we // normalize stop sequence values for stop times during snapshotting for the editor. <mask> . setInt ( oneBasedIndex ++ , patternStop . get ( \"stop_sequence\" ) . asInt ( ) ) ; // Log query, execute statement, and log result. LOG . debug ( statement . toString ( ) ) ; int entitiesUpdated = statement . executeUpdate ( ) ; LOG . debug ( \"{} stop_time arrivals/departures updated\" , entitiesUpdated ) ; return travelTime + dwellTime ; }", "comment": "Updates the stop times that reference the specified pattern stop ."}
{"lang": "java", "code": "public static WaitStrategy phasedOffLiteLock ( <mask> spinTimeout , long yieldTimeout , TimeUnit units ) { return phasedOff ( spinTimeout , yieldTimeout , units , liteBlocking ( ) ) ; }", "comment": "Block with wait / notifyAll semantics"}
{"lang": "java", "code": "@ Override public void startWork ( Work <mask> , Xid xid ) throws WorkCompletedException { LocalTransaction transaction = null ; try { ImportResult < LocalTransaction > transactionImportResult = localTransactionContext . findOrImportTransaction ( xid , 0 ) ; transaction = transactionImportResult . getTransaction ( ) ; ContextTransactionManager . getInstance ( ) . resume ( transaction ) ; } catch ( XAException xae ) { throw TransactionLogger . ROOT_LOGGER . cannotFindOrImportInflowTransaction ( xid , work , xae ) ; } catch ( InvalidTransactionException ite ) { throw TransactionLogger . ROOT_LOGGER . importedInflowTransactionIsInactive ( xid , work , ite ) ; } catch ( SystemException se ) { throw TransactionLogger . ROOT_LOGGER . cannotResumeInflowTransactionUnexpectedError ( transaction , work , se ) ; } }", "comment": "<p > Start work gets imported transaction and assign it to current thread . <p > This method mimics behavior of Narayana s {"}
{"lang": "java", "code": "@ RequestMapping ( value = \"/{notificationId}/events\" , method = RequestMethod . POST ) @ ResponseStatus ( HttpStatus . CREATED ) @ ResponseBody public EventDTO createEvent ( HttpServletRequest req , HttpServletResponse resp , @ PathVariable ( \"notificationId\" ) long notificationId , @ RequestBody EventDTO event ) { EventDTO dto = restService . createEvent ( notificationId , event ) ; if ( dto == null ) { resp . setStatus ( HttpStatus . NOT_FOUND . value ( ) ) ; return null ; } String url = getSingleNotificationRESTUrl ( req , notificationId ) + \"/state/\" + dto . getId ( ) ; resp . addHeader ( \"Location\" , <mask> ) ; return dto ; }", "comment": "Create a new event ."}
{"lang": "java", "code": "public void start ( ) { for ( BaseDownloadTask task : tasks ) { task . setListener ( target ) ; if ( autoRetryTimes != null ) { task . setAutoRetryTimes ( autoRetryTimes ) ; } if ( syncCallback != null ) { task . setSyncCallback ( syncCallback ) ; } if ( isForceReDownload != null ) { task . setForceReDownload ( isForceReDownload ) ; } if ( callbackProgressTimes != null ) { task . setCallbackProgressTimes ( callbackProgressTimes ) ; } if ( callbackProgressMinIntervalMillis != null ) { task . setCallbackProgressMinInterval ( callbackProgressMinIntervalMillis ) ; } if ( tag != null ) { <mask> . setTag ( tag ) ; } if ( taskFinishListenerList != null ) { for ( BaseDownloadTask . FinishListener finishListener : taskFinishListenerList ) { task . addFinishListener ( finishListener ) ; } } if ( this . directory != null ) { task . setPath ( this . directory , true ) ; } if ( this . isWifiRequired != null ) { task . setWifiRequired ( this . isWifiRequired ) ; } task . asInQueueTask ( ) . enqueue ( ) ; } FileDownloader . getImpl ( ) . start ( target , isSerial ) ; }", "comment": "Start tasks in a queue ."}
{"lang": "java", "code": "public static < E extends Comparable < ? <mask> E > > ImmutableSortedSet < E > of ( E element ) { return new RegularImmutableSortedSet < E > ( ImmutableList . of ( element ) , Ordering . natural ( ) ) ; }", "comment": "Returns an immutable sorted set containing a single element ."}
{"lang": "java", "code": "private void initChartsMap ( final Workbook wb ) { try { if ( wb instanceof XSSFWorkbook ) { initXSSFChartsMap ( ( XSSFWorkbook ) wb , parent . getCharsData ( ) ) ; } } catch ( Exception e ) { LOG . <mask> ( Level . SEVERE , \"getChartsMap Error Exception = \" + e . getLocalizedMessage ( ) , e ) ; } }", "comment": "initial chart map for specified workbook ."}
{"lang": "java", "code": "private boolean isPrefixOf ( IndexSearchDescriptor item , IndexSearchDescriptor desc ) { List < OBooleanExpression > left = item . keyCondition . getSubBlocks ( ) ; List < OBooleanExpression > <mask> = desc . keyCondition . getSubBlocks ( ) ; if ( left . size ( ) > right . size ( ) ) { return false ; } for ( int i = 0 ; i < left . size ( ) ; i ++ ) { if ( ! left . get ( i ) . equals ( right . get ( i ) ) ) { return false ; } } return true ; }", "comment": "returns true if the first argument is a prefix for the second argument eg . if the first argument is [ a ] and the second argument is [ a b ]"}
{"lang": "java", "code": "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Single < T > fromFuture ( <mask> < ? extends T > future , long timeout , TimeUnit unit ) { return toSingle ( Flowable . < T > fromFuture ( future , timeout , unit ) ) ; }", "comment": "Converts a { @link Future } into a { @code Single } with a timeout on the Future . <p > <img width = 640 height = 315 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / Single . from . Future . png alt = > <p > You can convert any object that supports the { @link Future } interface into a { @code Single } that emits the return value of the { @link Future#get } method of that object by passing the object into the { @code from } method . <p > <em > Important note : < / em > This { @code Single } is blocking ; you cannot dispose it . <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > { @code fromFuture } does not operate by default on a particular { @link Scheduler } . < / dd > < / dl >"}
{"lang": "java", "code": "public static < K , V > CopyOnWriteMap < K , V > newLinkedMap ( ) { <mask> < K , V > builder = builder ( ) ; return builder . newLinkedMap ( ) ; }", "comment": "<p > Creates a new { @link CopyOnWriteMap } with an underlying { @link java . util . LinkedHashMap } . Iterators for this map will be return elements in insertion order . < / p >"}
{"lang": "java", "code": "public static int [ ] join ( int [ ] arr , int ... is ) { if ( null == arr ) return is ; int length = arr . length + is . length ; int [ ] re = new int [ length ] ; System . arraycopy ( arr , 0 , re , 0 , arr . <mask> ) ; int i = arr . length ; for ( int num : is ) re [ i ++ ] = num ; return re ; }", "comment": "\u6574\u5408\u4e24\u4e2a\u6574\u6570\u6570\u7ec4\u4e3a\u4e00\u4e2a\u6570\u7ec4 <b > \u8fd9\u4e2a\u65b9\u6cd5\u5728JDK5\u4e0d\u53ef\u7528!!<b / >"}
{"lang": "java", "code": "public SortedSet < String > getDefinedChanges ( ) { SortedSet < String > names = new TreeSet <> ( ) ; for ( Change change : findAllInstances ( ) ) { names . <mask> ( getChangeMetaData ( change ) . getName ( ) ) ; } return Collections . unmodifiableSortedSet ( names ) ; }", "comment": "Returns all defined changes in the registry . Returned set is not modifiable ."}
{"lang": "java", "code": "@ Override public ReadableInstant getLastModified ( ServletContext servletContext , HttpServletRequest request , HttpServletResponse response , Page page ) throws ServletException , IOException { return AoArrays . maxNonNull ( page . getDateCreated ( ) , page . getDatePublished ( ) , <mask> . getDateModified ( ) ) ; }", "comment": "The last modified time of a page is the most recent of : <ol > <li > {"}
{"lang": "java", "code": "@ Override public void init ( ServletConfig config ) throws UnavailableException { container = ( ContainerSPI ) config . getServletContext ( ) . getAttribute ( TinyContainer . ATTR_INSTANCE ) ; if ( container == null ) { log . fatal ( \"Tiny container instance not properly created, probably misconfigured. Servlet |%s| permanently unvailable.\" , config . getServletName ( ) ) ; throw new UnavailableException ( \"Tiny container instance not properly created, probably misconfigured.\" ) ; } servletName = Strings . concat ( config . getServletContext ( ) . getServletContextName ( ) , ' ' , config . getServletName ( ) ) ; <mask> . trace ( \"Initialize servlet |%s|.\" , servletName ) ; }", "comment": "Servlet life cycle callback executed at this servlet instance initialization . Mainly takes care to initialize parent container reference . If there is no servlet context attribute with the name { @link TinyContainer#ATTR_INSTANCE } this initialization fails with servlet permanently unavailable . <p > Parent container instance has application life span and its reference is valid for entire life span of this servlet instance ."}
{"lang": "java", "code": "@ Override protected JaccService < AttachmentList < EjbJaccConfig > > createService ( String contextId , AttachmentList < EjbJaccConfig > metaData , Boolean standalone ) { <mask> new EjbJaccService ( contextId , metaData , standalone ) ; }", "comment": "{"}
{"lang": "java", "code": "static public List < DapVariable > getStructurePath ( DapVariable var ) { <mask> < DapNode > path = var . getPath ( ) ; List < DapVariable > structpath = new ArrayList < DapVariable > ( ) ; for ( int i = 0 ; i < path . size ( ) ; i ++ ) { DapNode node = path . get ( i ) ; switch ( node . getSort ( ) ) { case DATASET : case GROUP : break ; case VARIABLE : structpath . add ( ( DapVariable ) node ) ; break ; default : assert false : \"Internal error\" ; } } return structpath ; }", "comment": "Given a dap variable get the path from the top - level variable to and including the given variable such that all but the last element is a structure ."}
{"lang": "java", "code": "public static int getMethodCountForName ( Class < ? > clazz , String methodName ) { Preconditions . checkNotNull ( clazz , \"Class must not be null\" ) ; Preconditions . checkNotNull ( methodName , \"Method name must not be null\" ) ; int <mask> = 0 ; Method [ ] declaredMethods = clazz . getDeclaredMethods ( ) ; for ( Method method : declaredMethods ) { if ( methodName . equals ( method . getName ( ) ) ) { count ++ ; } } Class < ? > [ ] ifcs = clazz . getInterfaces ( ) ; for ( Class < ? > ifc : ifcs ) { count += getMethodCountForName ( ifc , methodName ) ; } if ( clazz . getSuperclass ( ) != null ) { count += getMethodCountForName ( clazz . getSuperclass ( ) , methodName ) ; } return count ; }", "comment": "Return the number of methods with a given name ( with any argument types ) for the given class and / or its superclasses . Includes non - public methods ."}
{"lang": "java", "code": "public void trace ( @ Nullable final String <mask> , @ Nullable final String message ) { log ( LogLevel . TRACE , event , message , EMPTY_STRING_ARRAY , EMPTY_OBJECT_ARRAY , DEFAULT_THROWABLE ) ; }", "comment": "Log a message for a canonical event at the trace level . Default values are used for all other parameters ."}
{"lang": "java", "code": "public static String [ ] decodeLocaleCode ( final String localeCode ) { String [ ] data = StringUtils . split ( localeCode , ' ' ) ; String [ ] result = new String [ ] { data [ 0 ] , \"\" , \"\" } ; if ( data . <mask> >= 2 ) { result [ 1 ] = data [ 1 ] ; if ( data . length >= 3 ) { result [ 2 ] = data [ 2 ] ; } } return result ; }", "comment": "Decodes locale code in string array that can be used for <code > Locale< / code > constructor ."}
{"lang": "java", "code": "public static Result redirect ( Call call ) { return new Result ( SEE_OTHER , Collections . singletonMap ( LOCATION , <mask> . path ( ) ) ) ; }", "comment": "Generates a 303 See Other result ."}
{"lang": "java", "code": "private static void drawArc ( Path path , double x0 , double y0 , double x , double y , double rx , double ry , double angle , boolean largeArcFlag , boolean sweepFlag ) { double dx2 = ( x0 - x ) / 2.0 ; double dy2 = ( y0 - y ) / 2.0 ; angle = Math . toRadians ( <mask> % 360.0 ) ; double cosAngle = Math . cos ( angle ) ; double sinAngle = Math . sin ( angle ) ; double x1 = ( cosAngle * dx2 + sinAngle * dy2 ) ; double y1 = ( - sinAngle * dx2 + cosAngle * dy2 ) ; rx = Math . abs ( rx ) ; ry = Math . abs ( ry ) ; double Prx = rx * rx ; double Pry = ry * ry ; double Px1 = x1 * x1 ; double Py1 = y1 * y1 ; // check that radii are large enough double radiiCheck = Px1 / Prx + Py1 / Pry ; if ( radiiCheck > 1 ) { rx = Math . sqrt ( radiiCheck ) * rx ; ry = Math . sqrt ( radiiCheck ) * ry ; Prx = rx * rx ; Pry = ry * ry ; } // Step 2 : Compute (cx1, cy1) double sign = ( largeArcFlag == sweepFlag ) ? - 1 : 1 ; double sq = ( ( Prx * Pry ) - ( Prx * Py1 ) - ( Pry * Px1 ) ) / ( ( Prx * Py1 ) + ( Pry * Px1 ) ) ; sq = ( sq < 0 ) ? 0 : sq ; double coef = ( sign * Math . sqrt ( sq ) ) ; double cx1 = coef * ( ( rx * y1 ) / ry ) ; double cy1 = coef * - ( ( ry * x1 ) / rx ) ; double sx2 = ( x0 + x ) / 2.0 ; double sy2 = ( y0 + y ) / 2.0 ; double cx = sx2 + ( cosAngle * cx1 - sinAngle * cy1 ) ; double cy = sy2 + ( sinAngle * cx1 + cosAngle * cy1 ) ; // Step 4 : Compute the angleStart (angle1) and the angleExtent (dangle) double ux = ( x1 - cx1 ) / rx ; double uy = ( y1 - cy1 ) / ry ; double vx = ( - x1 - cx1 ) / rx ; double vy = ( - y1 - cy1 ) / ry ; double p , n ; // Compute the angle start n = Math . sqrt ( ( ux * ux ) + ( uy * uy ) ) ; p = ux ; // (1 * ux) + (0 * uy) sign = ( uy < 0 ) ? - 1.0 : 1.0 ; double angleStart = Math . toDegrees ( sign * Math . acos ( p / n ) ) ; // Compute the angle extent n = Math . sqrt ( ( ux * ux + uy * uy ) * ( vx * vx + vy * vy ) ) ; p = ux * vx + uy * vy ; sign = ( ux * vy - uy * vx < 0 ) ? - 1.0 : 1.0 ; double angleExtent = Math . toDegrees ( sign * Math . acos ( p / n ) ) ; if ( ! sweepFlag && angleExtent > 0 ) { angleExtent -= 360f ; } else if ( sweepFlag && angleExtent < 0 ) { angleExtent += 360f ; } angleExtent %= 360f ; angleStart %= 360f ; RectF oval = new RectF ( ( float ) ( cx - rx ) , ( float ) ( cy - ry ) , ( float ) ( cx + rx ) , ( float ) ( cy + ry ) ) ; path . addArc ( oval , ( float ) angleStart , ( float ) angleExtent ) ; }", "comment": "/ * Elliptical arc implementation based on the SVG specification notes Adapted from the Batik library ( Apache - 2 license ) by SAU"}
{"lang": "java", "code": "public synchronized void updateKey ( final byte [ ] key ) { if ( key == null || key . length == 0 ) { throw new IllegalArgumentException ( SR . INVALID_KEY ) ; } this . <mask> = key ; this . hmacSha256 = null ; }", "comment": "Sets the name of the access key to be used when signing the request ."}
{"lang": "java", "code": "private Date stringAsSchedulerDate ( final String date , final String timerId ) { if ( date == null ) { return null ; } try { return new SimpleDateFormat ( SCHEDULER_DATE_FORMAT ) . <mask> ( date ) ; } catch ( ParseException e ) { EjbLogger . EJB3_TIMER_LOGGER . scheduleExpressionDateFromTimerPersistenceInvalid ( timerId , e . getMessage ( ) ) ; return null ; } }", "comment": "Convert the stored date - string from database back to Date"}
{"lang": "java", "code": "public static BigInteger checkLessEqualBig ( final BigInteger x , final String x_name , final BigInteger in_upper , final String upper_name ) { Objects . requireNonNull ( x , \"Value\" ) ; Objects . requireNonNull ( x_name , \"Value name\" ) ; Objects . requireNonNull ( in_upper , \"Upper\" ) ; Objects . requireNonNull ( upper_name , \"Upper bound name\" ) ; if ( x . compareTo ( in_upper ) <= 0 ) { return x ; } final var <mask> = String . format ( \"%s (%s) > %s (%s)\" , x_name , x , upper_name , in_upper ) ; throw new RangeCheckException ( message ) ; }", "comment": "<p > Assert that { @code x } ( named { @code x_name } ) is less than or equal to { @code in_upper } ( named { @code upper_name } ) . < / p >"}
{"lang": "java", "code": "@ Override public void drawGlyphVector ( GlyphVector g , float x , float y ) { <mask> ( g . getOutline ( x , y ) ) ; }", "comment": "Draws the specified glyph vector at the location { @code ( x y ) } ."}
{"lang": "java", "code": "private AccessDecisionManager getAccessDecisionManager ( H http ) { if ( accessDecisionManager == null ) { accessDecisionManager = createDefaultAccessDecisionManager ( <mask> ) ; } return accessDecisionManager ; }", "comment": "If currently null creates a default { @link AccessDecisionManager } using { @link #createDefaultAccessDecisionManager ( HttpSecurityBuilder ) } . Otherwise returns the { @link AccessDecisionManager } ."}
{"lang": "java", "code": "@ Pure protected final String get_attribute_name ( <mask> a ) { int con_index = a . getNameIndex ( ) ; Constant c = pool . getConstant ( con_index ) ; String att_name = ( ( ConstantUtf8 ) c ) . getBytes ( ) ; return att_name ; }", "comment": "Return the attribute name for the specified attribute ."}
{"lang": "java", "code": "public T set ( final Properties <mask> ) throws MailException { checkSessionNotSet ( ) ; this . properties . putAll ( properties ) ; return _this ( ) ; }", "comment": "Copies properties from given set . If { @link Session } is already created exception will be thrown ."}
{"lang": "java", "code": "protected void outject ( <mask> ActionRequest actionRequest ) { final Targets targets = actionRequest . getTargets ( ) ; scopeResolver . forEachScope ( madvocScope -> madvocScope . outject ( actionRequest , targets ) ) ; }", "comment": "Performs outjection ."}
{"lang": "java", "code": "@ Override public < U > U <mask> ( Fn1 < T , U > has , Fn0 < U > hasNot ) { return hasNot . get ( ) ; }", "comment": "{"}
{"lang": "java", "code": "public float determinant ( ) throws MatrixException { decompose ( ) ; // Each row exchange during forward elimination flips the sign // of the determinant, so check for an odd number of exchanges. float determinant = ( ( m_nExchangeCount & 1 ) == 0 ) ? 1 : - 1 ; // Form the product of the diagonal elements of matrix U. for ( int i = 0 ; i < m_nRows ; ++ i ) { final int pi = m_aPermutation [ i ] ; // permuted index determinant *= m_aLU . <mask> ( pi , i ) ; } return determinant ; }", "comment": "Compute the determinant ."}
{"lang": "java", "code": "public static boolean deleteDir ( File dir ) { if ( null == dir || ! dir . exists ( ) ) return false ; if ( ! dir . isDirectory ( ) ) throw new RuntimeException ( \"\\\"\" + dir . getAbsolutePath ( ) + \"\\\" should be a directory!\" ) ; File [ ] files = dir . listFiles ( ) ; boolean re = false ; if ( null != files ) { if ( <mask> . length == 0 ) return dir . delete ( ) ; for ( File f : files ) { if ( f . isDirectory ( ) ) re |= deleteDir ( f ) ; else re |= deleteFile ( f ) ; } re |= dir . delete ( ) ; } return re ; }", "comment": "\u5f3a\u884c\u5220\u9664\u4e00\u4e2a\u76ee\u5f55\uff0c\u5305\u62ec\u8fd9\u4e2a\u76ee\u5f55\u4e0b\u6240\u6709\u7684\u5b50\u76ee\u5f55\u548c\u6587\u4ef6"}
{"lang": "java", "code": "public boolean hasMapping ( String tableName , <mask> baseId , long relatedId ) { boolean has = false ; UserMappingDao userMappingDao = getMappingDao ( tableName ) ; UserCustomCursor cursor = userMappingDao . queryByIds ( baseId , relatedId ) ; try { has = cursor . getCount ( ) > 0 ; } finally { cursor . close ( ) ; } return has ; }", "comment": "Determine if the base id and related id mapping exists"}
{"lang": "java", "code": "<mask> void setMenuBackgroundColor ( int colorResId ) { backgroundColor = ContextCompat . getColor ( getContext ( ) , colorResId ) ; paint . setColor ( backgroundColor ) ; invalidate ( ) ; }", "comment": "Sets TapBarMenu s background color from given resource ."}
{"lang": "java", "code": "private static void buildTransformers2_1_0 ( ResourceTransformationDescriptionBuilder builder ) { ResourceTransformationDescriptionBuilder hornetqServer = <mask> . addChildResource ( pathElement ( HORNETQ_SERVER ) ) ; ResourceTransformationDescriptionBuilder addressSetting = hornetqServer . addChildResource ( AddressSettingDefinition . PATH ) ; rejectDefinedAttributeWithDefaultValue ( addressSetting , MAX_REDELIVERY_DELAY , REDELIVERY_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder bridge = hornetqServer . addChildResource ( BridgeDefinition . PATH ) ; bridge . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder clusterConnection = hornetqServer . addChildResource ( ClusterConnectionDefinition . PATH ) ; clusterConnection . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder connectionFactory = hornetqServer . addChildResource ( ConnectionFactoryDefinition . PATH ) ; connectionFactory . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; ResourceTransformationDescriptionBuilder pooledConnectionFactory = hornetqServer . addChildResource ( PooledConnectionFactoryDefinition . PATH ) ; pooledConnectionFactory . getAttributeBuilder ( ) . setValueConverter ( new DoubleToBigDecimalConverter ( ) , RETRY_INTERVAL_MULTIPLIER ) ; }", "comment": "Transformation for WildFly 8 . 1 . 0 . Final"}
{"lang": "java", "code": "public static void main ( String args [ ] ) throws Exception { //String fileIn = \"C:/data/dt2/point/bufr/IUA_CWAO_20060202_12.bufr\";\r //String fileIn = \"C:/data/bufr/edition3/idd/profiler/PROFILER_3.bufr\";\r //String fileIn = \"C:/data/bufr/edition3/ecmwf/synop.bufr\";\r //String fileIn = \"R:/testdata2/bufr/edition3/idd/profiler/PROFILER_1.bufr\";\r String fileIn = \"D:/mlode/bufr/cat.out\" ; NetcdfDataset ncf = NetcdfDataset . openDataset ( fileIn ) ; <mask> . out . println ( ncf . toString ( ) ) ; /* Structure s = (Structure) ncf.findVariable(obsRecord);\r\n    StructureData sdata = s.readStructure(2);\r\n    PrintWriter pw = new PrintWriter(System.out);\r\n    NCdumpW.printStructureData(pw, sdata);  */ new WriteT41_ncFlat ( ncf , \"D:/mlode/bufr/cat2.nc\" , true ) ; //Variable v = ncf.findVariable(\"recordIndex\");\r //NCdumpW.printArray(v.read(), \"recordIndex\", pw, null);\r /* ucar.nc2.Variable v;\r\n\r\n    v = ncf.findVariable(\"trajectory_id\");\r\n    if (v != null) {\r\n      Array data = v.read();\r\n      NCdump.printArray(data, v.getName(), System.out, null);\r\n    }\r\n    v = ncf.findVariable(\"station_id\");\r\n    if (v != null) {\r\n      Array data = v.read();\r\n      NCdump.printArray(data, v.getName(), System.out, null);\r\n    }\r\n    v = ncf.findVariable(\"firstChild\");\r\n    if (v != null) {\r\n      Array data = v.read();\r\n      NCdump.printArray(data, v.getName(), System.out, null);\r\n    }\r\n    v = ncf.findVariable(\"numChildren\");\r\n    if (v != null) {\r\n      Array data = v.read();\r\n      NCdump.printArray(data, v.getName(), System.out, null);\r\n    }\r\n    System.out.println();\r\n\r\n    v = ncf.findVariable(\"record\");\r\n    //ucar.nc2.Variable v = ncf.findVariable(\"Latitude\");\r\n    //ucar.nc2.Variable v = ncf.findVariable(\"time\");\r\n    //System.out.println();\r\n    //System.out.println( v.toString());\r\n\r\n    if (v instanceof Structure) {\r\n      Structure s = (Structure) v;\r\n      StructureDataIterator iter = s.getStructureIterator();\r\n      int count = 0;\r\n      PrintWriter pw = new PrintWriter( System.out);\r\n      while (iter.hasNext()) {\r\n        System.out.println(\"record \"+count);\r\n        NCdumpW.printStructureData(pw, iter.next());\r\n        count++;\r\n      }\r\n      Array data = v.read();\r\n      NCdump.printArray(data, \"record\", System.out, null);\r\n    } else {\r\n      Array data = v.read();\r\n      int[] length = data.getShape();\r\n      System.out.println();\r\n      System.out.println(\"v2 length =\" + length[0]);\r\n\r\n      IndexIterator ii = data.getIndexIterator();\r\n      for (; ii.hasNext();) {\r\n        System.out.println(ii.getFloatNext());\r\n      }\r\n    }\r\n    ncf.close();  */ }", "comment": "main ."}
{"lang": "java", "code": "public DateFormat getDateFormat ( ) { DateFormat df = getAs ( Function . dateFormat , DateFormat . <mask> ) ; return df == null ? null : ( DateFormat ) df . clone ( ) ; }", "comment": "Json\u8f93\u51fa\u683c\u5f0f\u7684\u65e5\u671f\u683c\u5f0f"}
{"lang": "java", "code": "void outputToResult ( ) { int index = 0 ; for ( ; index <= this . cursor ; ) { //\u8df3\u8fc7\u975eCJK\u5b57\u7b26\r if ( CharacterUtil . CHAR_USELESS == this . charTypes [ index ] ) { index ++ ; continue ; } //\u4ecepathMap\u627e\u51fa\u5bf9\u5e94index\u4f4d\u7f6e\u7684LexemePath\r LexemePath path = this . pathMap . get ( index ) ; if ( path != null ) { //\u8f93\u51faLexemePath\u4e2d\u7684lexeme\u5230results\u96c6\u5408\r Lexeme l = path . pollFirst ( ) ; while ( l != null ) { this . results . <mask> ( l ) ; //\u5b57\u5178\u4e2d\u65e0\u5355\u5b57\uff0c\u4f46\u662f\u8bcd\u5143\u51b2\u7a81\u4e86\uff0c\u5207\u5206\u51fa\u76f8\u4ea4\u8bcd\u5143\u7684\u524d\u4e00\u4e2a\u8bcd\u5143\u4e2d\u7684\u5355\u5b57\r int innerIndex = index + 1 ; for ( ; innerIndex < index + l . getLength ( ) ; innerIndex ++ ) { Lexeme innerL = path . peekFirst ( ) ; if ( innerL != null && innerIndex == innerL . getBegin ( ) ) { this . outputSingleCJK ( innerIndex - 1 ) ; } } //\u5c06index\u79fb\u81f3lexeme\u540e\r index = l . getBegin ( ) + l . getLength ( ) ; l = path . pollFirst ( ) ; if ( l != null ) { //\u8f93\u51fapath\u5185\u90e8\uff0c\u8bcd\u5143\u95f4\u9057\u6f0f\u7684\u5355\u5b57\r for ( ; index < l . getBegin ( ) ; index ++ ) { this . outputSingleCJK ( index ) ; } } } } else { //pathMap\u4e2d\u627e\u4e0d\u5230index\u5bf9\u5e94\u7684LexemePath\r //\u5355\u5b57\u8f93\u51fa\r this . outputSingleCJK ( index ) ; index ++ ; } } //\u6e05\u7a7a\u5f53\u524d\u7684Map\r this . pathMap . clear ( ) ; }", "comment": "\u63a8\u9001\u5206\u8bcd\u7ed3\u679c\u5230\u7ed3\u679c\u96c6\u5408 1 . \u4ecebuff\u5934\u90e8\u904d\u5386\u5230this . cursor\u5df2\u5904\u7406\u4f4d\u7f6e 2 . \u5c06map\u4e2d\u5b58\u5728\u7684\u5206\u8bcd\u7ed3\u679c\u63a8\u5165results 3 . \u5c06map\u4e2d\u4e0d\u5b58\u5728\u7684CJDK\u5b57\u7b26\u4ee5\u5355\u5b57\u65b9\u5f0f\u63a8\u5165results"}
{"lang": "java", "code": "public void writeContentToResponse ( ) throws IOException { if ( buffer == null ) { return ; } if ( buffer . isUsingStream ( ) ) { ServletOutputStream outputStream = getResponse ( ) . getOutputStream ( ) ; outputStream . write ( <mask> . toByteArray ( ) ) ; outputStream . flush ( ) ; } else { Writer out = getResponse ( ) . getWriter ( ) ; out . write ( buffer . toCharArray ( ) ) ; out . flush ( ) ; } }", "comment": "Writes ( unmodified ) buffered content using either output stream or writer . May be used for writing the unmodified response . Of course you may {"}
{"lang": "java", "code": "public final boolean weakCompareAndSet ( int i , double expect , double <mask> ) { return longs . weakCompareAndSet ( i , doubleToRawLongBits ( expect ) , doubleToRawLongBits ( update ) ) ; }", "comment": "Atomically sets the element at position { @code i } to the given updated value if the current value is <a href = #bitEquals > bitwise equal< / a > to the expected value ."}
{"lang": "java", "code": "public static CountProjection countDistinct ( String relativePath ) { return new CountProjection ( new DistinctProjection ( new PathProjection ( relativePath , false , <mask> ) ) ) ; }", "comment": "<p > Creates a count distinct projection for the specified relative path . < / p >"}
{"lang": "java", "code": "private void scanningModeCheck ( float [ ] data , int scanMode , int Xlength ) { // Mode  0  +x, -y, adjacent x, adjacent rows same dir // Mode  64 +x, +y, adjacent x, adjacent rows same dir if ( ( scanMode == 0 ) || ( scanMode == 64 ) ) // dont flip Y - handle it in the HorizCoordSys { return ; } // change -x to +x ie east to west -> west to east if ( ! GribUtils . scanModeXisPositive ( scanMode ) ) { float tmp ; int mid = Xlength / 2 ; for ( int index = 0 ; index < data . length ; index += Xlength ) { for ( int idx = 0 ; idx < mid ; idx ++ ) { tmp = data [ index + idx ] ; data [ index + idx ] = data [ index + Xlength - idx - 1 ] ; data [ index + Xlength - idx - 1 ] = tmp ; } } return ; } if ( ! GribUtils . scanModeSameDirection ( scanMode ) ) { float tmp ; int mid = Xlength / 2 ; for ( int index = 0 ; index < data . length ; index += Xlength ) { int row = index / Xlength ; if ( <mask> % 2 != 0 ) { // odd numbered row, calculate reverse index for ( int idx = 0 ; idx < mid ; idx ++ ) { tmp = data [ index + idx ] ; data [ index + idx ] = data [ index + Xlength - idx - 1 ] ; data [ index + Xlength - idx - 1 ] = tmp ; } } } } }", "comment": "LOOK might be wrong for a quasi regular ( thin ) grid ??"}
{"lang": "java", "code": "public static ColumnarMetadata readMetadata ( Configuration conf , Path rcfile ) throws IOException { Metadata metadata = null ; Configuration confCopy = new Configuration ( conf ) ; // set up conf to read all the columns ColumnProjectionUtils . setFullyReadColumns ( confCopy ) ; RCFile . Reader reader = new RCFile . Reader ( rcfile . getFileSystem ( confCopy ) , rcfile , confCopy ) ; //ugly hack to get metadata. RCFile has to provide access to metata try { Field f = RCFile . Reader . <mask> . getDeclaredField ( \"metadata\" ) ; f . setAccessible ( true ) ; metadata = ( Metadata ) f . get ( reader ) ; } catch ( Throwable t ) { throw new IOException ( \"Could not access metadata field in RCFile reader\" , t ) ; } reader . close ( ) ; Text metadataKey = new Text ( COLUMN_METADATA_PROTOBUF_KEY ) ; if ( metadata == null || metadata . get ( metadataKey ) == null ) { throw new IOException ( \"could not find ColumnarMetadata in \" + rcfile ) ; } return ColumnarMetadata . parseFrom ( metadata . get ( metadataKey ) . getBytes ( ) ) ; }", "comment": "reads {"}
{"lang": "java", "code": "public static NutMap xmlToMap ( String xml ) { return Xmls . asMap ( Xmls . xml ( Lang . <mask> ( xml ) ) . getDocumentElement ( ) ) ; }", "comment": "\u5c06\u4e00\u4e2a\u4e0b\u9762\u683c\u5f0f\u7684 XML :"}
{"lang": "java", "code": "@ Override public Authentication authenticate ( Authentication authentication ) throws AuthenticationException { if ( ! ( authentication instanceof BearerTokenAuthenticationToken ) ) { return null ; } BearerTokenAuthenticationToken bearer = ( BearerTokenAuthenticationToken ) authentication ; Map < String , Object > claims ; try { claims = this . introspectionClient . introspect ( bearer . getToken ( ) ) ; } catch ( OAuth2IntrospectionException failed ) { OAuth2Error invalidToken = invalidToken ( failed . getMessage ( ) ) ; throw new OAuth2AuthenticationException ( invalidToken ) ; } AbstractAuthenticationToken <mask> = convert ( bearer . getToken ( ) , claims ) ; result . setDetails ( bearer . getDetails ( ) ) ; return result ; }", "comment": "Introspect and validate the opaque <a href = https : // tools . ietf . org / html / rfc6750#section - 1 . 2 target = _blank > Bearer Token< / a > ."}
{"lang": "java", "code": "public static SafeUrlProto toProto ( SafeUrl url ) { return SafeUrlProto . newBuilder ( ) . setPrivateDoNotAccessOrElseSafeUrlWrappedValue ( <mask> . getSafeUrlString ( ) ) . build ( ) ; }", "comment": "Serializes a SafeUrl into its opaque protocol message representation ."}
{"lang": "java", "code": "@ RequestMapping ( \"/getUser\" ) public ResponseEntity < String > getUser ( ) { ConfigurationHandler response = configurationHandlerService . getConfigForGetUser ( ) ; return new ResponseEntity <> ( response . getBodyAnswer ( ) , httpHeaders , HttpStatus . valueOf ( <mask> . getResult ( ) ) ) ; }", "comment": "Processes HTTP . GET request ( URL : ... / getUser ) ."}
{"lang": "java", "code": "public static Demo . CDemoFileInfo infoForSource ( final Source source ) throws IOException { EngineType engineType = source . readEngineType ( ) ; source . setPosition ( source . readFixedInt32 ( ) ) ; PacketInstance < GeneratedMessage > pi = engineType . getNextPacketInstance ( source ) ; return ( Demo . CDemoFileInfo ) <mask> . parse ( ) ; }", "comment": "Retrieves summary - data from the given input source"}
{"lang": "java", "code": "static void writeInt ( byte [ ] byteArray , int offset , int i ) { for ( int j = 0 ; j < 4 ; j ++ ) { int <mask> = 24 - j * 8 ; byteArray [ offset + j ] = ( byte ) ( i >>> shift ) ; } }", "comment": "big - endian"}
{"lang": "java", "code": "public final T defaultSuccessUrl ( String defaultSuccessUrl , boolean alwaysUse ) { SavedRequestAwareAuthenticationSuccessHandler handler = new SavedRequestAwareAuthenticationSuccessHandler ( ) ; handler . setDefaultTargetUrl ( defaultSuccessUrl ) ; handler . setAlwaysUseDefaultTargetUrl ( alwaysUse ) ; this . defaultSuccessHandler = handler ; return successHandler ( <mask> ) ; }", "comment": "Specifies where users will go after authenticating successfully if they have not visited a secured page prior to authenticating or { @code alwaysUse } is true . This is a shortcut for calling { @link #successHandler ( AuthenticationSuccessHandler ) } ."}
{"lang": "java", "code": "protected boolean addParameter ( CoordinateTransform rs , String paramName , NetcdfFile <mask> , String varNameEscaped ) { if ( null == ( ds . findVariable ( varNameEscaped ) ) ) { if ( null != errBuffer ) errBuffer . format ( \"CoordTransBuilder %s: no Variable named %s%n\" , getTransformName ( ) , varNameEscaped ) ; return false ; } rs . addParameter ( new Parameter ( paramName , varNameEscaped ) ) ; return true ; }", "comment": "Add a Parameter to a CoordinateTransform . Make sure that the variable exists . If readData is true read the data and use it as the value of the parameter otherwise use the variable name as the value of the parameter ."}
{"lang": "java", "code": "public void setColumnMapping ( String ... columnMapping ) { this . columnMapping = ( columnMapping != null ) ? columnMapping . <mask> ( ) : new String [ ] { } ; resetIndexMap ( ) ; createIndexLookup ( this . columnMapping ) ; }", "comment": "Setter for the ColumnMappings ."}
{"lang": "java", "code": "<mask> StringProperty immutableField ( StringGetter < M > getter , StringImmutableSetter < M > immutableSetter ) { return addImmutable ( new ImmutableBeanPropertyField <> ( this :: propertyWasChanged , getter , immutableSetter , SimpleStringProperty :: new ) ) ; }", "comment": "Add a new immutable field of type String to this instance of the wrapper . This method is used for immutable model elements that have getters to get values for it s fields but not setters . Instead immutables have methods that take a new value for a field and return a new cloned instance of the model element with only this field updated to the new value . The old model instance isn t changed ."}
{"lang": "java", "code": "@ Override public String getSignature ( ) { if ( signature == null ) { String decl = getDeclaration ( ) ; int ndx = decl . indexOf ( ' ' ) ; ndx ++ ; String retType = decl . substring ( ndx ) ; StringBuilder methodDeclaration = new StringBuilder ( 50 ) ; methodDeclaration . append ( retType ) . append ( ' ' ) . append ( methodName ) . append ( decl , 0 , ndx ) ; String exceptionsAsString = getExceptionsAsString ( ) ; if ( exceptionsAsString != null ) { methodDeclaration . append ( \" throws \" ) . <mask> ( exceptionsAsString ) ; } signature = methodDeclaration . toString ( ) ; } return signature ; }", "comment": "---------------------------------------------------------------- method - info signature"}
{"lang": "java", "code": "public @ Nullable BroadcastReceiverData getBroadcastReceiver ( <mask> className ) { parseAndroidManifest ( ) ; for ( BroadcastReceiverData receiver : receivers ) { if ( receiver . getName ( ) . equals ( className ) ) { return receiver ; } } return null ; }", "comment": "Returns data for the broadcast receiver with the provided name from this manifest . If no receiver with the class name can be found returns null ."}
{"lang": "java", "code": "public ManualFeatureQueryResults query ( GeometryEnvelope envelope ) { return <mask> ( envelope . getMinX ( ) , envelope . getMinY ( ) , envelope . getMaxX ( ) , envelope . getMaxY ( ) ) ; }", "comment": "Manually query for rows within the geometry envelope"}
{"lang": "java", "code": "private RhinoScriptBuilder initScriptBuilder ( ) { try { RhinoScriptBuilder builder = null ; if ( <mask> == null ) { builder = RhinoScriptBuilder . newChain ( ) . evaluateChain ( getScriptAsStream ( ) , DEFAULT_CSSLINT_JS ) ; scope = builder . getScope ( ) ; } else { builder = RhinoScriptBuilder . newChain ( scope ) ; } return builder ; } catch ( final IOException ex ) { throw new IllegalStateException ( \"Failed reading init script\" , ex ) ; } }", "comment": "Initialize script builder for evaluation ."}
{"lang": "java", "code": "static public List < Record > readTable ( InputStream ios , String format , int maxLines ) throws IOException , NumberFormatException { List < Record > result ; try { TableParser parser = new TableParser ( format ) ; result = <mask> . readAllRecords ( ios , maxLines ) ; } finally { ios . close ( ) ; } return result ; }", "comment": "Reads an input stream containing lines of ascii in fixed width format . Breaks each line into a set of Fields ( space or comma delimited ) which may be String integer or double ."}
{"lang": "java", "code": "private Statement createStatement ( MethodInvocation < Connection > methodInvocation ) throws Throwable { Statement result = ( Statement ) methodInvocation . proceed ( ) ; result = proxyFactory . wrapStatement ( result ) ; return <mask> ; }", "comment": "Wrap Statement during {"}
{"lang": "java", "code": "public static int cublasDrotm ( cublasHandle <mask> , int n , Pointer x , int incx , Pointer y , int incy , Pointer param ) /** host or device pointer */ { return checkResult ( cublasDrotmNative ( handle , n , x , incx , y , incy , param ) ) ; }", "comment": "host or device pointer"}
{"lang": "java", "code": "public final Flux < T > onErrorResume ( Function < ? <mask> Throwable , ? extends Publisher < ? extends T > > fallback ) { return onAssembly ( new FluxOnErrorResume <> ( this , fallback ) ) ; }", "comment": "Subscribe to a returned fallback publisher when any error occurs using a function to choose the fallback depending on the error ."}
{"lang": "java", "code": "public Group commonParent ( Group other ) { if ( isParent ( <mask> ) ) return this ; if ( other . isParent ( this ) ) return other ; while ( ! other . isParent ( this ) ) other = other . getParentGroup ( ) ; return other ; }", "comment": "Get the common parent of this and the other group . Cant fail since the root group is always a parent of any 2 groups ."}
{"lang": "java", "code": "public void endOfLife ( String key ) { Entry < C > entry = liveMap . remove ( key ) ; if ( entry == null ) return ; lingerersMap . put ( key , <mask> ) ; }", "comment": "Mark component identified by key as having reached its end - of - life ."}
{"lang": "java", "code": "public void validate ( StyledLayerDescriptorInfo sld ) throws SldException { <mask> { parseSldI ( sld ) ; } catch ( JiBXException e ) { throw new SldException ( \"Validation error\" , e ) ; } }", "comment": "Test by marshalling ."}
{"lang": "java", "code": "@ Override public void set ( String key , Object <mask> , long expireAfterWrite , long expireAfterAccess ) { final String KEY = calcCacheKey ( key ) ; try { JedisCluster jedisCluster = getJedis ( ) ; /*\n             * Returns -1 if no expiry, -2 if key does not exist.\n             */ final long currentTTL = jedisCluster . ttl ( KEY ) ; long ttl = TTL_NO_CHANGE ; if ( ! ( entry instanceof CacheEntry ) ) { CacheEntry ce = new CacheEntry ( key , entry , expireAfterWrite , expireAfterAccess ) ; entry = ce ; ttl = expireAfterAccess > 0 ? expireAfterAccess : ( expireAfterWrite > 0 ? expireAfterWrite : ( timeToLiveSeconds > 0 ? timeToLiveSeconds : 0 ) ) ; } else { CacheEntry ce = ( CacheEntry ) entry ; ttl = ce . getExpireAfterAccess ( ) ; } byte [ ] data = serializeCacheEntry ( ( CacheEntry ) entry ) ; // TTL Rules: // 1. New item: TTL is calculated as formula(s) above. // 2. Existing item: // 2.1. If [keyMode=HASH]: extends the current TTL, // 2.2. Otherwise, extends the current TTL only when // expireAfterAccess > // 0 if ( currentTTL >= - 1 ) { // existing item if ( keyMode == KeyMode . HASH ) // rule 2.1 ttl = currentTTL > 0 ? currentTTL : TTL_NO_CHANGE ; else // rule 2.2 ttl = expireAfterAccess > 0 ? expireAfterAccess : TTL_NO_CHANGE ; } if ( keyMode == KeyMode . HASH ) { jedisCluster . hset ( SafeEncoder . encode ( getName ( ) ) , SafeEncoder . encode ( KEY ) , data ) ; if ( ttl > 0 ) { jedisCluster . expire ( getName ( ) , ( int ) ttl ) ; } else if ( ttl == TTL_FOREVER && currentTTL >= - 1 ) { jedisCluster . persist ( getName ( ) ) ; } } else { if ( ttl > 0 ) { jedisCluster . setex ( SafeEncoder . encode ( KEY ) , ( int ) ttl , data ) ; } else { jedisCluster . set ( SafeEncoder . encode ( KEY ) , data ) ; if ( ttl == TTL_FOREVER ) { jedisCluster . persist ( KEY ) ; } else if ( currentTTL > 0 ) { jedisCluster . expire ( KEY , ( int ) currentTTL ) ; } } } } catch ( Exception e ) { throw e instanceof CacheException ? ( CacheException ) e : new CacheException ( e ) ; } }", "comment": "{"}
{"lang": "java", "code": "public static RePattern compile ( String <mask> , EnumSet < PatternFlags > flags ) throws RegexException { return Compiler . compile ( pattern , flags ) ; }", "comment": "Compile a pattern ."}
{"lang": "java", "code": "@ Override public void freeze ( final boolean throwException ) { checkOpenness ( ) ; if ( ! ( getStorage ( ) instanceof OFreezableStorageComponent ) ) { OLogManager . instance ( ) . error ( this , \"Only local paginated storage supports freeze. If you are using remote client please use OServerAdmin instead\" , null ) ; return ; } final long startTime = Orient . instance ( ) . getProfiler ( ) . startChrono ( ) ; final OFreezableStorageComponent <mask> = getFreezableStorage ( ) ; if ( storage != null ) { storage . freeze ( throwException ) ; } Orient . instance ( ) . getProfiler ( ) . stopChrono ( \"db.\" + getName ( ) + \".freeze\" , \"Time to freeze the database\" , startTime , \"db.*.freeze\" ) ; }", "comment": "{"}
{"lang": "java", "code": "public static String getCanonicalPathFromCredentials ( final StorageCredentials credentials , final String absolutePath ) { final String account = credentials . getAccountName ( ) ; if ( <mask> == null ) { final String errorMessage = SR . CANNOT_CREATE_SAS_FOR_GIVEN_CREDENTIALS ; throw new IllegalArgumentException ( errorMessage ) ; } final StringBuilder builder = new StringBuilder ( \"/\" ) ; builder . append ( account ) ; builder . append ( absolutePath ) ; return builder . toString ( ) ; }", "comment": "Gets the canonical path for an object from the credentials ."}
{"lang": "java", "code": "public int doStartTag ( ) throws JspException { <mask> { authorized = super . authorize ( ) ; if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiPrefix ( ) ) ; } if ( var != null ) { pageContext . setAttribute ( var , authorized , PageContext . PAGE_SCOPE ) ; } return TagLibConfig . evalOrSkip ( authorized ) ; } catch ( IOException e ) { throw new JspException ( e ) ; } }", "comment": "Invokes the base class { @link AbstractAuthorizeTag#authorize () } method to decide if the body of the tag should be skipped or not ."}
{"lang": "java", "code": "private void handleResourceRequest ( EventModel eventModel ) { if ( MusicUsageResource . isPermanent ( eventModel ) ) { ResourceModel resourceModel = eventModel . getListResourceContainer ( ) . provideResource ( MusicUsageResource . ID ) . stream ( ) . filter ( MusicUsageResource :: isPermanent ) . findAny ( ) . orElse ( null ) ; //should not happen //a partially applied function which takes an Identification an returns an Optional StartMusicRequest Function < Identification , Optional < StartMusicRequest > > getStartMusicRequest = own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own ) ; //if we have a trackInfo we create it with the trackInfo as a parameter getStartMusicRequest = TrackInfoResource . getTrackInfo ( eventModel ) . map ( trackInfo -> ( Function < Identification , Optional < StartMusicRequest > > ) own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own , trackInfo ) ) . orElse ( getStartMusicRequest ) ; //if we have a trackInfo we create it with the playlist as a parameter getStartMusicRequest = PlaylistResource . getPlaylist ( eventModel ) . map ( playlist -> ( Function < Identification , Optional < StartMusicRequest > > ) own -> StartMusicRequest . createStartMusicRequest ( resourceModel . getProvider ( ) , own , playlist ) ) . orElse ( getStartMusicRequest ) ; //composes a new Function which appends the Volume to the result getStartMusicRequest = getStartMusicRequest . andThen ( VolumeResource . getVolume ( eventModel ) . flatMap ( volume -> IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . map ( identification -> new VolumeResource ( identification , volume ) ) ) . map ( resource -> ( Function < Optional < StartMusicRequest > , Optional < StartMusicRequest > > ) opt -> opt . map ( event -> ( StartMusicRequest ) event . addResource ( resource ) ) ) . orElse ( Function . identity ( ) ) :: <mask> ) ; IdentificationManagerM . getInstance ( ) . getIdentification ( this ) . flatMap ( getStartMusicRequest :: apply ) . ifPresent ( this :: fire ) ; } else { play ( eventModel ) ; if ( ! runsInPlay ) { blockRequest = lock . newCondition ( ) ; lock . lock ( ) ; try { blockRequest . await ( 10 , TimeUnit . MINUTES ) ; } catch ( InterruptedException e ) { debug ( \"interrupted\" , e ) ; } finally { lock . unlock ( ) ; } } } }", "comment": "handles the a request to start playing music via Resource"}
{"lang": "java", "code": "private void encodeLiteral ( OutputStream out , <mask> [ ] name , byte [ ] value , IndexType indexType , int nameIndex ) throws IOException { int mask ; int prefixBits ; switch ( indexType ) { case INCREMENTAL : mask = 0x40 ; prefixBits = 6 ; break ; case NONE : mask = 0x00 ; prefixBits = 4 ; break ; case NEVER : mask = 0x10 ; prefixBits = 4 ; break ; default : throw new IllegalStateException ( \"should not reach here\" ) ; } encodeInteger ( out , mask , prefixBits , nameIndex == - 1 ? 0 : nameIndex ) ; if ( nameIndex == - 1 ) { encodeStringLiteral ( out , name ) ; } encodeStringLiteral ( out , value ) ; }", "comment": "Encode literal header field according to Section 6 . 2 ."}
{"lang": "java", "code": "public static int getPositionForView ( @ NonNull final AbsListView absListView , @ NonNull final View view ) { int <mask> = absListView . getPositionForView ( view ) ; if ( absListView instanceof ListView ) { position -= ( ( ListView ) absListView ) . getHeaderViewsCount ( ) ; } return position ; }", "comment": "Returns the position within the adapter s dataset for the view where view is an adapter item or a descendant of an adapter item . Unlike { @link AdapterView#getPositionForView ( android . view . View ) } returned position will reflect the position of the item given view is representing by subtracting the header views count ."}
{"lang": "java", "code": "protected void successfulAuthentication ( HttpServletRequest <mask> , HttpServletResponse response , FilterChain chain , Authentication authResult ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"Authentication success. Updating SecurityContextHolder to contain: \" + authResult ) ; } SecurityContextHolder . getContext ( ) . setAuthentication ( authResult ) ; rememberMeServices . loginSuccess ( request , response , authResult ) ; // Fire event if ( this . eventPublisher != null ) { eventPublisher . publishEvent ( new InteractiveAuthenticationSuccessEvent ( authResult , this . getClass ( ) ) ) ; } successHandler . onAuthenticationSuccess ( request , response , authResult ) ; }", "comment": "Default behaviour for successful authentication . <ol > <li > Sets the successful <tt > Authentication< / tt > object on the { @link SecurityContextHolder } < / li > <li > Informs the configured <tt > RememberMeServices< / tt > of the successful login< / li > <li > Fires an { @link InteractiveAuthenticationSuccessEvent } via the configured <tt > ApplicationEventPublisher< / tt > < / li > <li > Delegates additional behaviour to the { @link AuthenticationSuccessHandler } . < / li > < / ol >"}
{"lang": "java", "code": "public void <mask> ( IAction action ) { if ( selectedNode == null ) { return ; } IWorkbenchBrowserSupport browserSupport = Activator . getDefault ( ) . getWorkbench ( ) . getBrowserSupport ( ) ; try { URL consoleURL = new URL ( extractGuvnorConsoleUrl ( selectedNode . getGuvnorRepository ( ) . getLocation ( ) ) ) ; if ( browserSupport . isInternalWebBrowserAvailable ( ) ) { browserSupport . createBrowser ( null ) . openURL ( consoleURL ) ; } else { browserSupport . getExternalBrowser ( ) . openURL ( consoleURL ) ; } } catch ( Exception e ) { Activator . getDefault ( ) . displayError ( IStatus . ERROR , e . getMessage ( ) , e , true ) ; } }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) void resize ( int newCapacity ) { Entry < K , V > [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry < K , V > [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; <mask> = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }", "comment": "Rehashes the contents of this map into a new array with a larger capacity . This method is called automatically when the number of keys in this map reaches its threshold ."}
{"lang": "java", "code": "protected void writeClazzTag ( Class expectedClass , Object o ) { if ( expectedClass == o . getClass ( ) ) { out . writeString ( \"{\" ) ; } else { String stringForType = mapper . getStringForType ( o . getClass ( ) ) ; <mask> . writeString ( stringForType + \" {\" ) ; } }", "comment": "determines classname tagging . Overrifing can enforce class tags always or ( JSon ) write as special attribute"}
{"lang": "java", "code": "public V remove ( Object key ) { if ( key == null ) { return null ; } purgeBeforeWrite ( ) ; return <mask> . remove ( key ) ; }", "comment": "Removes the specified mapping from this map ."}
{"lang": "java", "code": "public JavaWriter beginMethod ( String returnType , String name , Set < Modifier > modifiers , List < String > parameters , List < String > throwsTypes ) throws IOException { indent ( ) ; emitModifiers ( modifiers ) ; if ( returnType != null ) { emitCompressedType ( returnType ) ; out . write ( \" \" ) ; out . write ( name ) ; } else { emitCompressedType ( name ) ; } out . write ( \"(\" ) ; if ( parameters != null ) { for ( int p = 0 ; p < parameters . size ( ) ; ) { if ( p != 0 ) { out . write ( \", \" ) ; } emitCompressedType ( parameters . get ( p ++ ) ) ; out . write ( \" \" ) ; emitCompressedType ( parameters . get ( p ++ ) ) ; } } out . write ( \")\" ) ; if ( throwsTypes != null && throwsTypes . size ( ) > 0 ) { out . write ( \"\\n\" ) ; indent ( ) ; out . write ( \"    throws \" ) ; for ( int i = 0 ; i < throwsTypes . size ( ) ; i ++ ) { if ( i != 0 ) { out . write ( \", \" ) ; } emitCompressedType ( throwsTypes . get ( i ) ) ; } } if ( modifiers . contains ( ABSTRACT ) || Scope . INTERFACE_DECLARATION . equals ( scopes . peek ( ) ) ) { out . write ( \";\\n\" ) ; scopes . push ( Scope . ABSTRACT_METHOD ) ; } else { out . write ( \" {\\n\" ) ; scopes . <mask> ( returnType == null ? Scope . CONSTRUCTOR : Scope . NON_ABSTRACT_METHOD ) ; } return this ; }", "comment": "Emit a method declaration ."}
{"lang": "java", "code": "public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { <mask> val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }", "comment": "Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers ."}
{"lang": "java", "code": "public void endElement ( String namespaceURI , <mask> localName , String qName ) throws SAXException { if ( saxParser != null ) { saxParser . endElement ( namespaceURI , localName , qName ) ; } }", "comment": "The SAX2 <code > endElement< / code > method . Does nothing ."}
{"lang": "java", "code": "<mask> static < T extends Throwable > T forLocalHandling ( T th ) { if ( requiresNonLocalHandling ( th ) ) { AUnchecker . throwUnchecked ( th ) ; } return th ; }", "comment": "This method checks if a given Throwable is fit for local handling returning it if it is and throwing it otherwise ."}
{"lang": "java", "code": "public void init ( String title ) { super . init ( title ) ; Container contentPane = this . getContentPane ( ) ; contentPane . setLayout ( new BorderLayout ( ) ) ; m_properties = AppUtilities . readProperties ( m_strFileName = System . getProperty ( PROPERTY_FILENAME_PARAM , DEFAULT_PROPERTY_FILENAME ) ) ; JPanel panel = this . getPropertyView ( m_properties ) ; contentPane . add ( panel , BorderLayout . CENTER ) ; JPanel panelButtons = new JPanel ( ) ; contentPane . add ( panelButtons , BorderLayout . SOUTH ) ; panelButtons . setLayout ( new BorderLayout ( ) ) ; panelButtons . <mask> ( m_buttonGo = new JButton ( \"GO!\" ) , BorderLayout . EAST ) ; m_buttonGo . addActionListener ( this ) ; panelButtons . add ( progressBar = new JProgressBar ( 0 , 1 ) , BorderLayout . CENTER ) ; panelButtons . add ( m_buttonSave = new JButton ( \"Save\" ) , BorderLayout . WEST ) ; m_buttonSave . addActionListener ( this ) ; }", "comment": "/ * Constructor ."}
{"lang": "java", "code": "public SPFPersona getPersonaOf ( String appIdentifier ) { SQLiteDatabase db = mRegistryTable . getReadableDatabase ( ) ; String table = Contract . TABLE_NAME ; String [ ] columns = { Contract . COLUMN_PERSONA } ; String selection = Contract . COLUMN_APP_IDENTIFIER + \" = ? \" ; String [ ] selectionArgs = { appIdentifier } ; String groupBy = null ; String having = null ; String orderBy = null ; Cursor c = db . query ( table , columns , selection , selectionArgs , groupBy , having , orderBy ) ; if ( c . moveToNext ( ) ) { String persona = c . getString ( c . getColumnIndex ( Contract . COLUMN_PERSONA ) ) ; return new SPFPersona ( persona ) ; } c . <mask> ( ) ; return SPFPersona . DEFAULT ; }", "comment": "Returns the SPFPersona associated to the specified application . If the application does not exist returns the default SPFPersona ."}
{"lang": "java", "code": "public boolean contains ( K key ) { return new ReplicatedDataKeyClusteredCacheData < K , V > ( cacheData , <mask> , cluster ) . exists ( ) ; }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "<mask> static int serverPort ( ServerProperties serverProperties ) { return Objects . isNull ( serverProperties ) ? 0 : ( Objects . isNull ( serverProperties . getPort ( ) ) ? 8080 : serverProperties . getPort ( ) ) ; }", "comment": "\u6a21\u5757HTTP\u7aef\u53e3\u53f7"}
{"lang": "java", "code": "public Long zcount ( final String key , final double min , final double max ) { return this . execute ( new RedisClusterCallback < Long > ( ) { public Long doInRedisCluster ( RedisCluster redisCluster ) { return redisCluster . zcount ( key , min , max ) ; } public int getPartitionNumber ( ) { return GatewayPartitionNumber . <mask> ( key ) ; } public AffinityState getState ( ) { return AffinityState . READ ; } } ) ; }", "comment": "/ *"}
{"lang": "java", "code": "public void excludeKey ( HollowPrimaryKeyIndex idx , Object ... key ) { int excludeOrdinal = idx . getMatchingOrdinal ( <mask> ) ; if ( excludeOrdinal >= 0 ) { BitSet excludedOrdinals = this . excludedOrdinals . get ( idx . getTypeState ( ) ) ; if ( excludedOrdinals == null ) { excludedOrdinals = new BitSet ( idx . getTypeState ( ) . maxOrdinal ( ) + 1 ) ; this . excludedOrdinals . put ( idx . getTypeState ( ) , excludedOrdinals ) ; } excludedOrdinals . set ( excludeOrdinal ) ; } }", "comment": "Exclude the record which matches the specified key ."}
{"lang": "java", "code": "public void badURL ( HttpServletRequest request , HttpServletResponse response ) throws Exception { if ( Debug . isSet ( \"showResponse\" ) ) { log . <mask> ( \"Sending Bad URL Page.\" ) ; } //log.info(\"DODSServlet.badURL \" + rs.getRequest().getRequestURI()); response . setContentType ( \"text/html\" ) ; response . setHeader ( \"XDODS-Server\" , getServerVersion ( ) ) ; response . setHeader ( \"Content-Description\" , \"dods-error\" ) ; // Commented because of a bug in the OPeNDAP C++ stuff... //rs.getResponse().setHeader(\"Content-Encoding\", \"plain\"); PrintWriter pw = new PrintWriter ( new OutputStreamWriter ( response . getOutputStream ( ) , Util . UTF8 ) ) ; printBadURLPage ( pw ) ; printHelpPage ( pw ) ; pw . flush ( ) ; response . setStatus ( HttpServletResponse . SC_OK ) ; }", "comment": "Sends an html document to the client explaining that they have used a poorly formed URL and then the help page ..."}
{"lang": "java", "code": "<mask> Edge addEdge ( final String fromId , final String toId ) { return getStatements ( ) . addEdge ( fromId , toId , this ) ; }", "comment": "Convenience method to add and return an Edge between a Node / Subgraph and another Node / Subgraph within the immediate Statements in this Graph ."}
{"lang": "java", "code": "@ Override public StubResponse provideStubResponseFor ( final Request request ) { synchronized ( this ) { if ( this . configurable ) { this . configurable = false ; this . httpStubs = this . createHttpStubs ( ) ; } if ( this . recordRequests ) { this . receivedRequests . add ( request ) ; } } for ( final Iterator < HttpStub > it = this . httpStubs . descendingIterator ( ) ; it . hasNext ( ) ; ) { final HttpStub rule = it . next ( ) ; if ( rule . matches ( request ) ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"Following rule will be applied:\\n\" ) ; sb . append ( rule ) ; logger . debug ( sb . toString ( ) ) ; return rule . nextResponse ( request ) ; } } final StringBuilder sb = new StringBuilder ( ) ; sb . append ( \"No suitable rule found. Reason:\\n\" ) ; for ( final HttpStub <mask> : this . httpStubs ) { sb . append ( \"The rule '\" ) ; sb . append ( rule ) ; sb . append ( \"' cannot be applied. Mismatch:\\n\" ) ; sb . append ( rule . describeMismatch ( request ) ) ; sb . append ( \"\\n\" ) ; } logger . info ( sb . toString ( ) ) ; return NO_RULE_FOUND_RESPONSE ; }", "comment": "{"}
{"lang": "java", "code": "public static InetSocketAddress getHostPortPair ( <mask> svc ) { try { return new InetSocketAddress ( svc . getMetadata ( ) . get ( \"service.host\" ) , Integer . parseInt ( svc . getMetadata ( ) . get ( \"service.port\" ) ) ) ; } catch ( Exception e ) { logger . error ( \"Exception extracting metadata from service instance {}\" , svc , e ) ; return null ; } }", "comment": "Safely get the information from our convention"}
{"lang": "java", "code": "public <mask> < B > ImmutableTypeToInstanceMap < B > of ( ) { return new ImmutableTypeToInstanceMap < B > ( ImmutableMap . < TypeToken < ? extends B > , B > of ( ) ) ; }", "comment": "Returns an empty type to instance map ."}
{"lang": "java", "code": "public static void charValue ( final MethodVisitor mv ) { mv . visitTypeInsn ( CHECKCAST , SIGNATURE_JAVA_LANG_CHARACTER ) ; mv . visitMethodInsn ( INVOKEVIRTUAL , SIGNATURE_JAVA_LANG_CHARACTER , \"charValue\" , \"()C\" , <mask> ) ; }", "comment": "Converts <code > Character< / code > object to a <code > char< / code > ."}
{"lang": "java", "code": "public static com . google . cloud . datastore . Key raw ( final Key < ? > key ) { return <mask> == null ? null : key . getRaw ( ) ; }", "comment": "Null - safe extraction of the raw key"}
{"lang": "java", "code": "public static NinjaMode determineModeFromSystemPropertiesOrProdIfNotSet ( ) { Optional < NinjaMode > ninjaModeOptional = determineModeFromSystemProperties ( ) ; NinjaMode ninjaMode ; if ( ! ninjaModeOptional . isPresent ( ) ) { ninjaMode = NinjaMode . prod ; } else { ninjaMode = ninjaModeOptional . <mask> ( ) ; } logger . info ( \"Ninja is running in mode {}\" , ninjaMode . toString ( ) ) ; return ninjaMode ; }", "comment": "returns NinjaMode . dev if no mode is set . Or the valid mode set via a System Property called ninja . mode ."}
{"lang": "java", "code": "public static boolean isPackageAvailable ( @ NonNull Context <mask> , @ NonNull String packageName ) { return ( getPackageInfo ( context , packageName ) != null ) ; }", "comment": "A safe method to check if an app is installed ."}
{"lang": "java", "code": "<mask> ServletOutputStream createOutputStream ( ) throws IOException { GzipResponseStream gzstream = new GzipResponseStream ( origResponse ) ; gzstream . setBuffer ( threshold ) ; return gzstream ; }", "comment": "Creates and returns a ServletOutputStream to write the content associated with this Response ."}
{"lang": "java", "code": "public int findCellY ( int y ) { int ofs = 0 ; for ( int i = 0 ; i < <mask> . length ; i ++ ) { ofs += rows [ i ] ; if ( y < ofs + abspos . getY1 ( ) ) return i ; } return - 1 ; }", "comment": "Finds a grid cell that contains the specified point"}
{"lang": "java", "code": "public void add ( InputSplit split ) throws IOException , InterruptedException { splits . <mask> ( split ) ; totalSplitSizes += split . getLength ( ) ; locations = null ; }", "comment": "Add an InputSplit to this collection ."}
{"lang": "java", "code": "private void recomputeFocus ( MotionEvent event ) { for ( int i = 0 ; i < mHighlightViews . size ( ) ; i ++ ) { HighlightView hv = mHighlightViews . get ( i ) ; hv . setFocus ( <mask> ) ; hv . invalidate ( ) ; } for ( int i = 0 ; i < mHighlightViews . size ( ) ; i ++ ) { HighlightView hv = mHighlightViews . get ( i ) ; int edge = hv . getHit ( event . getX ( ) , event . getY ( ) ) ; if ( edge != HighlightView . GROW_NONE ) { if ( ! hv . hasFocus ( ) ) { hv . setFocus ( true ) ; hv . invalidate ( ) ; } break ; } } invalidate ( ) ; }", "comment": "hitting cropping rectangle ."}
{"lang": "java", "code": "protected void makeCoordinateTransforms ( NetcdfDataset ncDataset ) { for ( VarProcess vp : varList ) { if ( vp . isCoordinateTransform && vp . ct == null ) { vp . ct = CoordTransBuilder . makeCoordinateTransform ( vp . <mask> , vp . v , parseInfo , userAdvice ) ; } } }", "comment": "Take all previously identified Coordinate Transforms and create a CoordinateTransform object by calling CoordTransBuilder . makeCoordinateTransform () ."}
{"lang": "java", "code": "public static ServiceState fromString ( String state ) throws NullPointerException , IllegalArgumentException { if ( <mask> == null ) throw new NullPointerException ( \"state is null\" ) ; if ( state . equalsIgnoreCase ( INACTIVE_STRING ) ) return INACTIVE ; if ( state . equalsIgnoreCase ( ACTIVE_STRING ) ) return ACTIVE ; if ( state . equalsIgnoreCase ( STOPPING_STRING ) ) return STOPPING ; throw new IllegalArgumentException ( \"Invalid state: \" + state ) ; }", "comment": "Get a <code > ServiceState< / code > object from an integer value ."}
{"lang": "java", "code": "public Connection getProxyConnection ( long timeoutMs ) throws SQLException { int attempt = 1 ; ConnHolder connHolder = null ; SQLException sqlException = null ; long startNanoTime = System . nanoTime ( ) ; while ( connHolder == null ) { try { connHolder = getConnHolder ( timeoutMs ) ; } catch ( ViburDBCPException e ) { // thrown only if we can retry the operation, see getConnHolder(...) sqlException = chainSQLException ( e . unwrapSQLException ( ) , sqlException ) ; if ( attempt ++ > dataSource . getAcquireRetryAttempts ( ) ) { // check the max retries limit throw sqlException ; } if ( timeoutMs > 0 ) { // check the time limit if applicable timeoutMs = NANOSECONDS . toMillis ( connectionTimeoutInNanos - ( System . nanoTime ( ) - startNanoTime ) ) - dataSource . getAcquireRetryDelayInMs ( ) ; // calculates the remaining timeout if ( timeoutMs <= 0 ) { throw sqlException ; } } <mask> { MILLISECONDS . sleep ( dataSource . getAcquireRetryDelayInMs ( ) ) ; } catch ( InterruptedException ie ) { Thread . currentThread ( ) . interrupt ( ) ; throw chainSQLException ( new SQLException ( ie ) , sqlException ) ; } } } if ( logger . isTraceEnabled ( ) ) { logger . trace ( \"Taking rawConnection {}\" , connHolder . rawConnection ( ) ) ; } Connection proxy = newProxyConnection ( connHolder , this , dataSource ) ; if ( dataSource . isPoolEnableConnectionTracking ( ) ) { connHolder . setProxyConnection ( proxy ) ; } return proxy ; }", "comment": "//////////// getProxyConnection ( ... ) //////////////"}
{"lang": "java", "code": "private void configureWindow ( WebWindow web ) { if ( m_fullscreen ) { // We need to store the previous width and height values m_width = web . <mask> ( ) ; m_height = web . height ( ) ; web . showFullScreen ( ) ; } else { web . showNormal ( ) ; if ( ! m_resizable ) { web . setFixedSize ( new QSize ( m_width , m_height ) ) ; } else { web . setBaseSize ( new QSize ( m_width , m_height ) ) ; } web . resize ( m_width , m_height ) ; } if ( ! m_bar ) { web . menuBar ( ) . setVisible ( false ) ; } else { web . menuBar ( ) . setVisible ( true ) ; if ( m_icon != null ) { QIcon icon = new QIcon ( m_icon ) ; web . setWindowIcon ( icon ) ; } web . setWindowTitle ( m_appName ) ; } if ( ! m_contextMenu ) { web . setContextMenuPolicy ( ContextMenuPolicy . PreventContextMenu ) ; } else { web . setContextMenuPolicy ( ContextMenuPolicy . DefaultContextMenu ) ; } }", "comment": "Configures the browser window ."}
{"lang": "java", "code": "@ XmlElementDecl ( namespace = \"http://www.immobilienscout24.de/immobilientransfer\" , name = \"Strom\" , scope = BefeuerungsArtTyp . class ) public JAXBElement < <mask> > createBefeuerungsArtTypStrom ( Object value ) { return new JAXBElement < Object > ( _BefeuerungsArtTypStrom_QNAME , Object . class , BefeuerungsArtTyp . class , value ) ; }", "comment": "Create an instance of { @link JAXBElement } { @code < } { @link Object } { @code > }}"}
{"lang": "java", "code": "@ ExceptionHandler ( InvalidParameterException . <mask> ) @ ResponseBody public ResponseEntity < String > handleControllerException ( InvalidParameterException exception ) { HttpHeaders headers = new HttpHeaders ( ) ; headers . setContentType ( MediaType . TEXT_PLAIN ) ; return new ResponseEntity < String > ( exception . getMessage ( ) , headers , HttpStatus . BAD_REQUEST ) ; }", "comment": "<p > Handles { @link InvalidParameterException } generated by the controller itself when receives an invalid parameter . < / p >"}
{"lang": "java", "code": "<mask> void setStartPoint ( double x , double y , double z ) { this . x0 = x ; this . y0 = y ; this . z0 = z ; }", "comment": "Sets the position ( @a x @a y @a z ) of the start of the line segment to choose values along ."}
{"lang": "java", "code": "public long getId ( ) { // Find the category for this hierarchy attribute value. Tree < CategoryNode > category = attributeClass . lookup . <mask> ( value ) ; // Extract and return the id. return category . getElement ( ) . id ; }", "comment": "Returns the long id of the attribute ."}
{"lang": "java", "code": "public NetworkBuilder < N , E > expectedEdgeCount ( int expectedEdgeCount ) { this . expectedEdgeCount = Optional . of ( checkNonNegative ( expectedEdgeCount ) ) ; <mask> this ; }", "comment": "Specifies the expected number of edges in the network ."}
{"lang": "java", "code": "public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( <mask> != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }", "comment": "Do something when closing ."}
{"lang": "java", "code": "public boolean isMatchedTag ( final <mask> tag ) { if ( ! tag . nameEquals ( name ) ) { return false ; } if ( id != null ) { CharSequence tagId = tag . getId ( ) ; if ( tagId == null ) { return false ; } if ( ! CharSequenceUtil . equals ( id , tagId ) ) { return false ; } } return true ; }", "comment": "Returns <code > true< / code > if provided tag matches decorator tag ."}
{"lang": "java", "code": "public HttpResponse executeCommand ( HttpUriRequest request , boolean apiHeaders ) { if ( apiHeaders ) { setApiHeaders ( request ) ; } try { CloseableHttpResponse response = <mask> . getHttpClient ( ) . execute ( request ) ; try { checkResponseStatus ( response ) ; return response ; } finally { response . close ( ) ; } } catch ( IOException e ) { throw new UploadcareNetworkException ( e ) ; } }", "comment": "Executes the request et the Uploadcare API and return the HTTP Response object ."}
{"lang": "java", "code": "@ Nullable public static < T extends Fragment > T findById ( Activity a , @ IdRes int id ) { return findById ( a . getFragmentManager ( ) , <mask> ) ; }", "comment": "Get the Fragment with the ID ."}
{"lang": "java", "code": "public static Optional < Presence > importPresence ( ResourceModel resourceModel ) { <mask> resource = resourceModel . getResource ( ) ; try { //noinspection unchecked HashMap < String , Object > data = ( HashMap < String , Object > ) resource ; PresenceIndicatorLevel level ; try { level = PresenceIndicatorLevel . valueOf ( ( String ) data . get ( LEVEL_DESCRIPTOR ) ) ; } catch ( IllegalArgumentException e ) { level = PresenceIndicatorLevel . VERY_WEAK ; } boolean present = ( boolean ) data . get ( PRESENT_DESCRIPTOR ) ; boolean strict = ( boolean ) data . get ( STRICT_DESCRIPTOR ) ; boolean known = ( boolean ) data . get ( KNOWN_DESCRIPTOR ) ; return Optional . of ( new Presence ( level , present , strict , known ) ) ; } catch ( Exception e ) { return Optional . empty ( ) ; } }", "comment": "imports ( if no errors occurred ) the Presence from the ResourceModel"}
{"lang": "java", "code": "private CharSequence getJavaScript ( ) { final String divId = get ( \"triStateDiv\" ) . getMarkupId ( true ) ; get ( \"triStateDiv:triStateBtn\" ) . getMarkupId ( true ) ; final String valId = get ( \"triStateDiv:triStateValue\" ) . getMarkupId ( true ) ; final StringBuilder ret = new StringBuilder ( ) . append ( \"switch (dom.byId('\" ) . append ( valId ) . append ( \"').value)\" ) . append ( \"{\" ) . append ( \"case 'on':\" ) . append ( \"dom.byId('\" ) . append ( valId ) . append ( \"').value = 'off';\" ) . append ( \"domClass.replace('\" ) . append ( divId ) . append ( \"', 'off', 'on');\" ) . append ( \"break;\" ) . append ( \"case 'off':\" ) . append ( \"dom.byId('\" ) . append ( valId ) . append ( \"').value = '';\" ) . append ( \"domClass.remove('\" ) . append ( divId ) . append ( \"', 'off');\" ) . append ( \"break;\" ) . append ( \"default:\" ) . append ( \"dom.byId('\" ) . append ( valId ) . append ( \"').value = 'on';\" ) . append ( \"domClass.add('\" ) . append ( divId ) . append ( \"', 'on');\" ) . append ( \"}\" ) ; return DojoWrapper . <mask> ( ret , DojoClasses . domClass , DojoClasses . dom , DojoClasses . on , DojoClasses . query , DojoClasses . NodeListTraverse , DojoClasses . domReady ) ; }", "comment": "Gets the java script ."}
{"lang": "java", "code": "public boolean expireAllLeasesByVMId ( String vmId ) throws IllegalStateException { final String hostname = assignableVMs . getHostnameFromVMId ( vmId ) ; if ( hostname == null ) { return false ; } expireAllLeases ( hostname ) ; return <mask> ; }", "comment": "Call this method to instruct the task scheduler to reject all of the unused offers it is currently holding that concern resources offered by the host with the ID { @code vmId } ."}
{"lang": "java", "code": "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . CUSTOM ) public static Observable < Long > interval ( long period , TimeUnit <mask> , Scheduler scheduler ) { return interval ( period , period , unit , scheduler ) ; }", "comment": "Returns an Observable that emits a sequential number every specified interval of time on a specified Scheduler . <p > <img width = 640 height = 200 src = https : // raw . github . com / wiki / ReactiveX / RxJava / images / rx - operators / interval . s . png alt = > <dl > <dt > <b > Scheduler : < / b > < / dt > <dd > You specify which { @link Scheduler } this operator will use . < / dd > < / dl >"}
{"lang": "java", "code": "public static void setAppConfFolder ( <mask> appConfFolderFromConfig , String baseConfigFileName ) { WebApplicationProperties . appConfFolder = appConfFolderFromConfig ; WebApplicationProperties . baseConfigFileName = baseConfigFileName ; }", "comment": "The folder where the application s properties files are located ."}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) @ Deprecated public Form < T > bind ( Map < String , String > <mask> , String ... allowedFields ) { return bind ( ctxLang ( ) , ctxRequestAttrs ( ) , data , allowedFields ) ; }", "comment": "Binds data to this form - that is handles form submission ."}
{"lang": "java", "code": "@ SuppressWarnings ( \"unchecked\" ) public < K , V > Region < K , V > getRegion ( String regionName ) { if ( regionName == null || regionName . length ( ) == 0 ) return null ; Region < K , V > region = ( Region < K , V > ) clientCache . getRegion ( regionName ) ; if ( region != null ) return ( Region < K , V > ) region ; <mask> = ( Region < K , V > ) this . createRegion ( regionName ) ; //Client side data policy is typically NORMAL or EMPTY if ( cachingProxy ) { //NORMAL data policy are typically used for CACHING_PROXY //You should interest so updates for the server will be pushed to the clients region . registerInterestRegex ( \".*\" ) ; } return region ; }", "comment": "This is an example to get or create a region"}
{"lang": "java", "code": "public static int countStrHeadChar ( String str , <mask> c ) { int re = 0 ; if ( ! isEmpty ( str ) ) for ( ; re < str . length ( ) ; re ++ ) { if ( str . charAt ( re ) != c ) return re ; } return re ; }", "comment": "\u8ba1\u7b97\u4e00\u4e2a\u5b57\u7b26\u4e32\u5f00\u5934\u6709\u51e0\u4e2a\u91cd\u590d\u7684\u5b57\u7b26"}
{"lang": "java", "code": "private AnimatorListener createSweepAnimatorListener ( ) { return new AnimatorListener ( ) { @ Override public void onAnimationStart ( final Animator animation ) { } @ Override public void onAnimationEnd ( final Animator animation ) { } @ Override public void onAnimationCancel ( final Animator animation ) { } @ Override public void onAnimationRepeat ( <mask> Animator animation ) { appearing = ! appearing ; if ( appearing ) { currentGlobalAngleOffset = ( currentGlobalAngleOffset + MIN_SWEEP_ANGLE * 2 ) % MAX_DEGREES ; } } } ; }", "comment": "Creates and returns a listener which allows to restart the progress drawable s animation when it has been finished ."}
{"lang": "java", "code": "public void receiveResultmdfeRecepcaoLote ( com . fincatto . documentofiscal . mdfe3 . webservices . recepcao . MDFeRecepcaoStub . MdfeRecepcaoLoteResult <mask> ) { }", "comment": "auto generated Axis2 call back method for mdfeRecepcaoLote method override this method for handling normal response from mdfeRecepcaoLote operation"}
{"lang": "java", "code": "public void zrangeByScoreWithScores ( final byte [ ] key , final byte [ ] min , final byte [ ] max , final int offset , final int <mask> ) { sendCommand ( Command . ZRANGEBYSCORE , key , min , max , Keyword . LIMIT . raw , RedisProtocol . toByteArray ( offset ) , RedisProtocol . toByteArray ( count ) , Keyword . WITHSCORES . raw ) ; }", "comment": "Zrange by score with scores ."}
{"lang": "java", "code": "@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Observable < R > concatMapSingleDelayError ( Function < ? <mask> T , ? extends SingleSource < ? extends R > > mapper , boolean tillTheEnd , int prefetch ) { ObjectHelper . requireNonNull ( mapper , \"mapper is null\" ) ; ObjectHelper . verifyPositive ( prefetch , \"prefetch\" ) ; return RxJavaPlugins . onAssembly ( new ObservableConcatMapSingle < T , R > ( this , mapper , tillTheEnd ? ErrorMode . END : ErrorMode . BOUNDARY , prefetch ) ) ; }", "comment": "Maps the upstream items into {"}
{"lang": "java", "code": "protected final void adjust_code_for_locals_change ( MethodGen mgen , int index_first_moved_local , int <mask> ) { InstructionList il = mgen . getInstructionList ( ) ; for ( InstructionHandle ih = il . getStart ( ) ; ih != null ; ih = ih . getNext ( ) ) { Instruction inst = ih . getInstruction ( ) ; int orig_length = inst . getLength ( ) ; int operand ; if ( ( inst instanceof RET ) || ( inst instanceof IINC ) ) { IndexedInstruction index_inst = ( IndexedInstruction ) inst ; if ( index_inst . getIndex ( ) >= index_first_moved_local ) { index_inst . setIndex ( index_inst . getIndex ( ) + size ) ; } } else if ( inst instanceof LocalVariableInstruction ) { // BCEL handles all the details of which opcode and if index // is implicit or explicit; also, and if needs to be WIDE. operand = ( ( LocalVariableInstruction ) inst ) . getIndex ( ) ; if ( operand >= index_first_moved_local ) { ( ( LocalVariableInstruction ) inst ) . setIndex ( operand + size ) ; } } // Unfortunately, BCEL doesn't take care of incrementing the // offset within StackMapEntrys. int delta = inst . getLength ( ) - orig_length ; if ( delta > 0 ) { il . setPositions ( ) ; update_stack_map_offset ( ih . getPosition ( ) , delta ) ; modify_stack_maps_for_switches ( ih , il ) ; } } }", "comment": "Process the instruction list adding size ( 1 or 2 ) to the index of each Instruction that references a local that is equal or higher in the local map than index_first_moved_local . Size should be the size of the new local that was just inserted at index_first_moved_local ."}
{"lang": "java", "code": "public static Object getValue ( String expression , Object root , Class resultType ) throws OgnlException { return getValue ( parseExpression ( expression ) , <mask> , resultType ) ; }", "comment": "Convenience method that combines calls to <code > parseExpression < / code > and <code > getValue< / code > ."}
{"lang": "java", "code": "@ Override public SortedMap < String , String > getColumnsToParameters ( final Record <mask> , int op , Map < String , String > parameters , Map < String , String > columnsToFields ) { SortedMap < String , String > columnsToParameters = new TreeMap <> ( ) ; for ( Map . Entry < String , String > entry : columnsToFields . entrySet ( ) ) { String columnName = entry . getKey ( ) ; String fieldPath = getFieldPath ( columnName , columnsToFields , op ) ; if ( record . has ( fieldPath ) ) { columnsToParameters . put ( columnName , parameters . get ( columnName ) ) ; } else { LOG . trace ( \"Record is missing a field for column {} for the operation code {}\" , columnName , op ) ; } } return columnsToParameters ; }", "comment": "Records from MongoDB Oplog origin have a bit unique structure ."}
{"lang": "java", "code": "public void <mask> ( Runnable runnable , Executor executor ) { // Fail fast on a null. We throw NPE here because the contract of Executor states that it throws // NPE on null listener, so we propagate that contract up into the add method as well. checkNotNull ( runnable , \"Runnable was null.\" ) ; checkNotNull ( executor , \"Executor was null.\" ) ; // Lock while we check state. We must maintain the lock while adding the new pair so that // another thread can't run the list out from under us. We only add to the list if we have not // yet started execution. synchronized ( this ) { if ( ! executed ) { runnables = new RunnableExecutorPair ( runnable , executor , runnables ) ; return ; } } // Execute the runnable immediately. Because of scheduling this may end up getting called before // some of the previously added runnables, but we're OK with that. If we want to change the // contract to guarantee ordering among runnables we'd have to modify the logic here to allow // it. executeListener ( runnable , executor ) ; }", "comment": "Adds the { @code Runnable } and accompanying { @code Executor } to the list of listeners to execute . If execution has already begun the listener is executed immediately ."}
{"lang": "java", "code": "public static void logMemoryUsage ( Logger logger , LogLevel priority ) { if ( LoggerWrap . isEnabledFor ( logger , priority ) ) { // Getting the runtime reference from system Runtime runtime = Runtime . getRuntime ( ) ; LoggerWrap . log ( logger , <mask> , \"Memory (MB) Used/Total/Max: \" + ( runtime . totalMemory ( ) - runtime . freeMemory ( ) ) / megaBytes + \"/\" + runtime . totalMemory ( ) / megaBytes + \"/\" + runtime . maxMemory ( ) / megaBytes ) ; } }", "comment": "Log the current total memory usage with the specified priority ."}
{"lang": "java", "code": "public byte [ ] decrypt ( final String encodedJSON ) { byte [ ] result = null ; if ( encodedJSON == null ) throw new OSecurityException ( \"OSymmetricKey.decrypt(String) encodedJSON is null\" ) ; try { byte [ ] decoded = convertFromBase64 ( encodedJSON ) ; if ( decoded == null ) throw new OSecurityException ( \"OSymmetricKey.decrypt(String) encodedJSON could not be decoded\" ) ; String json = new String ( decoded , \"UTF8\" ) ; // Convert the JSON content to an ODocument to make parsing it easier. final ODocument doc = new ODocument ( ) . fromJSON ( json , \"noMap\" ) ; // Set a default in case the JSON document does not contain an \"algorithm\" property. String algorithm = secretKeyAlgorithm ; if ( doc . containsField ( \"algorithm\" ) ) algorithm = doc . field ( \"algorithm\" ) ; // Set a default in case the JSON document does not contain a \"transform\" property. String transform = defaultCipherTransformation ; if ( doc . containsField ( \"transform\" ) ) transform = doc . field ( \"transform\" ) ; String payloadBase64 = <mask> . field ( \"payload\" ) ; String ivBase64 = doc . field ( \"iv\" ) ; byte [ ] payload = null ; byte [ ] iv = null ; if ( payloadBase64 != null ) payload = convertFromBase64 ( payloadBase64 ) ; if ( ivBase64 != null ) iv = convertFromBase64 ( ivBase64 ) ; // Throws NoSuchAlgorithmException and NoSuchPaddingException. Cipher cipher = Cipher . getInstance ( transform ) ; if ( iv != null ) cipher . init ( Cipher . DECRYPT_MODE , secretKey , new IvParameterSpec ( iv ) ) ; else cipher . init ( Cipher . DECRYPT_MODE , secretKey ) ; result = cipher . doFinal ( payload ) ; } catch ( Exception ex ) { throw OException . wrapException ( new OSecurityException ( \"OSymmetricKey.decrypt(String) Exception: \" + ex . getMessage ( ) ) , ex ) ; } return result ; }", "comment": "This method decrypts the Base64 - encoded JSON document using the specified algorithm and cipher transformation ."}
{"lang": "java", "code": "private String getCacheName ( ) { <mask> cacheName = ncDataset . getLocation ( ) ; if ( cacheName == null ) cacheName = ncDataset . getCacheName ( ) ; return cacheName ; }", "comment": "has the name getCacheName ()"}
{"lang": "java", "code": "public static DataBuffer . Type getDtypeFromContext ( String dType ) { switch ( dType ) { case \"double\" : return DataBuffer . Type . DOUBLE ; case \"float\" : return DataBuffer . Type . FLOAT ; <mask> \"int\" : return DataBuffer . Type . INT ; case \"half\" : return DataBuffer . Type . HALF ; default : return DataBuffer . Type . FLOAT ; } }", "comment": "Get the allocation mode from the context"}
{"lang": "java", "code": "@ Override public byte [ ] getRecord ( int position ) { buffer . position ( position + 2 ) ; final int recordSize = buffer . getInt ( ) ; final byte [ ] record = new byte [ recordSize ] ; buffer . get ( record ) ; return <mask> ; }", "comment": "{"}
{"lang": "java", "code": "public synchronized V remove ( Object key , boolean internal ) { // noinspection SuspiciousMethodCalls CacheObject < V > cacheObject = map . remove ( key ) ; // If the object is not in cache, stop trying to remove it. if ( cacheObject == null ) { return null ; } // Remove from the cache order list cacheObject . lastAccessedListNode . remove ( ) ; cacheObject . ageListNode . remove ( ) ; // Remove references to linked list nodes cacheObject . ageListNode = null ; cacheObject . lastAccessedListNode = null ; return cacheObject . <mask> ; }", "comment": "/ * Remove operation with a flag so we can tell coherence if the remove was caused by cache internal processing such as eviction or loading"}
{"lang": "java", "code": "public <mask> < JAXBElement < ? extends DeploymentDescriptorType > > getDeploymentDescriptor ( ) { if ( deploymentDescriptor == null ) { deploymentDescriptor = new ArrayList < JAXBElement < ? extends DeploymentDescriptorType > > ( ) ; } return this . deploymentDescriptor ; }", "comment": "Gets the value of the deploymentDescriptor property ."}
{"lang": "java", "code": "public static String encodeBase16 ( byte [ ] bytesParam ) { if ( bytesParam == null ) { return null ; } if ( bytesParam . <mask> == 0 ) { return UtilGlobal . EMPTY ; } return DatatypeConverter . printHexBinary ( bytesParam ) . toUpperCase ( ) ; }", "comment": "Encodes the { @code bytesParam } as { @code java . lang . String } ."}
{"lang": "java", "code": "public static < T , S extends T > Comparator < Iterable < S > > lexicographical ( Comparator < T > comparator ) { return <mask> LexicographicalOrdering < S > ( checkNotNull ( comparator ) ) ; }", "comment": "think tip it over into being worthwhile ."}
{"lang": "java", "code": "ASCIIBits clear ( String chars ) { for ( int i = 0 , n = chars . length ( ) ; i < n ; ++ i ) { <mask> ch = chars . charAt ( i ) ; if ( ch < 64 ) { _lowerMask &= ~ ( 1L << ch ) ; } else { _upperMask &= ~ ( 1L << ch ) ; } } return this ; }", "comment": "Clears the bit ( sets to 0 ) for each character in the argument string ."}
{"lang": "java", "code": "public static boolean isValidSchematron ( @ Nullable final IMicroNode aNode ) { if ( aNode == null ) return <mask> ; return isValidSchematron ( TransformSourceFactory . create ( MicroWriter . getNodeAsString ( aNode ) ) ) ; }", "comment": "Check if the passed micro node is a valid schematron instance ."}
{"lang": "java", "code": "private boolean processStatusCodeReply ( ByteBuf in ) { int length = lineLength ( ) ; if ( length == 0 ) { return false ; } in . skipBytes ( length ) ; return <mask> ; }", "comment": "Process status code reply ."}
{"lang": "java", "code": "public Flowable < ReactiveSensorEvent > observeSensor ( int sensorType , final int samplingPeriodInUs , final Handler handler , final BackpressureStrategy strategy ) { if ( ! hasSensor ( sensorType ) ) { String format = \"Sensor with id = %d is not available on this device\" ; String message = String . format ( Locale . getDefault ( ) , format , sensorType ) ; return Flowable . <mask> ( new SensorNotFoundException ( message ) ) ; } final Sensor sensor = sensorManager . getDefaultSensor ( sensorType ) ; final SensorEventListenerWrapper wrapper = new SensorEventListenerWrapper ( ) ; final SensorEventListener listener = wrapper . create ( ) ; return Flowable . create ( new FlowableOnSubscribe < ReactiveSensorEvent > ( ) { @ Override public void subscribe ( final FlowableEmitter < ReactiveSensorEvent > emitter ) throws Exception { wrapper . setEmitter ( emitter ) ; if ( handler == null ) { sensorManager . registerListener ( listener , sensor , samplingPeriodInUs ) ; } else { sensorManager . registerListener ( listener , sensor , samplingPeriodInUs , handler ) ; } } } , strategy ) . doOnCancel ( new Action ( ) { @ Override public void run ( ) throws Exception { sensorManager . unregisterListener ( listener ) ; } } ) ; }", "comment": "Returns RxJava Observable which allows to monitor hardware sensors as a stream of ReactiveSensorEvent object with defined sampling period"}
{"lang": "java", "code": "<mask> void setShadowXOffset ( int dimenResId ) { int shadowXOffset = getResources ( ) . getDimensionPixelSize ( dimenResId ) ; if ( mShadowXOffset != shadowXOffset ) { mShadowXOffset = shadowXOffset ; requestLayout ( ) ; updateBackground ( ) ; } }", "comment": "Sets the shadow x offset of the <b > FloatingActionButton< / b > and invalidates its layout ."}
{"lang": "java", "code": "public String [ ] getProperties ( String <mask> ) { // Try to get the callers class name and method name by throwing an exception an searching the stack frames. String className = null ; String methodName = null ; /* Java 1.4 onwards only.\n           try {\n             throw new Exception();\n           } catch (Exception e) {\n             StackTraceElement[] stack = e.getStackTrace();\n             // Check that the stack trace contains at least two elements, one for this method and one for the caller.\n             if (stack.length >= 2) {\n               className = stack[1].getClassName();\n               methodName = stack[1].getMethodName();\n             }\n           }*/ return getProperties ( className , methodName , key ) ; }", "comment": "Looks up an array property value relative to the environment callers class and method . The default environment will be checked for a matching array property if defaults are being used . In order to work out the callers class and method this method throws an exception and then searches one level up its stack frames ."}
{"lang": "java", "code": "private void onOperationFinished ( @ NonNull final OperationDelivery < ? > operationResult ) { logd ( \"onOperationFinished \" + operationResult ) ; <mask> ( mState ) { case PAUSED : storeResult ( operationResult ) ; break ; case RESUMED : deliverResult ( operationResult ) ; break ; default : throw new IllegalStateException ( \"Unknown state: \" + mState ) ; } }", "comment": "A dispatcher method which decides what to do with an operation result ."}
{"lang": "java", "code": "@ Override public StructureData getStructureData ( int index ) { assert ( super . sdata != null ) ; if ( index < 0 || index >= this . dimsize ) throw new IllegalArgumentException ( index + \" >= \" + super . sdata . length ) ; assert ( super . sdata [ index ] != null ) ; return super . sdata [ <mask> ] ; }", "comment": "Get the index th StructureData ( StructureDataA ) object We need instances of StructureData to give to the user . We use StructureDataA so we can centralize everything in this class . The total number of StructureData objects is dimsize ."}
{"lang": "java", "code": "<mask> double computeArea ( Polygon2D_F64 a , Polygon2D_F64 b ) { ssss = 0 ; sclx = 0 ; scly = 0 ; return inter ( a , b ) ; }", "comment": "Computes the area of the intersection between the two polygons ."}
{"lang": "java", "code": "@ DontLabel public Rule noneOf ( final <mask> characters ) { Objects . requireNonNull ( characters ) ; return noneOf ( characters . toCharArray ( ) ) ; }", "comment": "Match any characters <em > except< / em > the ones contained in the strings"}
{"lang": "java", "code": "public static boolean canEncode ( <mask> str , int off , int len ) { return canEncode ( str . substring ( off , off + len ) ) ; }", "comment": "Returns whether the specified range in the given { @code String } can be encoded into UTF - 8 ."}
{"lang": "java", "code": "GivenRuleBuilder < T , U > given ( String name , T <mask> ) { return given ( new Fact < T > ( name , value ) ) ; }", "comment": "Adds a fact to the Rule ."}
{"lang": "java", "code": "public static < T , D > Flux < T > using ( Callable < ? extends D > resourceSupplier , Function < ? super D , ? extends <mask> < ? extends T > > sourceSupplier , Consumer < ? super D > resourceCleanup , boolean eager ) { return onAssembly ( new FluxUsing <> ( resourceSupplier , sourceSupplier , resourceCleanup , eager ) ) ; }", "comment": "Uses a resource generated by a supplier for each individual Subscriber while streaming the values from a Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or the Subscriber cancels . <p > <ul > <li > Eager resource cleanup happens just before the source termination and exceptions raised by the cleanup Consumer may override the terminal even . < / li > <li > Non - eager cleanup will drop any exception . < / li > < / ul > <p > <img class = marble src = doc - files / marbles / usingForFlux . svg alt = > <p > For an asynchronous version of the cleanup with distinct path for onComplete onError and cancel terminations see { @link #usingWhen ( Publisher Function Function Function Function ) } ."}
{"lang": "java", "code": "private Model doModel ( Type type , Model model ) { Map < String , Property > properties = <mask> . getProperties ( ) ; if ( properties != null ) { BeanDescription desc = Json . mapper ( ) . getSerializationConfig ( ) . introspect ( Json . mapper ( ) . constructType ( type ) ) ; for ( BeanPropertyDefinition beanProperty : desc . findProperties ( ) ) { Property property = properties . get ( beanProperty . getName ( ) ) ; if ( property != null ) { property . setRequired ( beanProperty . isRequired ( ) ) ; } } } return model ; }", "comment": "Mostly for kotlin null safe operator and immutable properties ."}
{"lang": "java", "code": "public synchronized InputStreamHandle executeSelect ( SPARQLQueryDefinition qdef , InputStreamHandle handle , Long offset , Long limit ) { if ( <mask> == null ) { this . sparqlQueryManager . clearPageLength ( ) ; } else { this . sparqlQueryManager . setPageLength ( limit ) ; } if ( offset != null ) { return this . sparqlQueryManager . executeSelect ( qdef , handle , offset , currentTransaction ) ; } else { return this . sparqlQueryManager . executeSelect ( qdef , handle , currentTransaction ) ; } }", "comment": "synchronization needed because of setting of page length"}
{"lang": "java", "code": "private ReceivedEmail addAttachment ( final Part part , final InputStream content , final File attachmentStorage ) throws MessagingException , IOException { final EmailAttachmentBuilder builder = addAttachmentInfo ( <mask> ) ; builder . content ( content , part . getContentType ( ) ) ; if ( attachmentStorage != null ) { String name = messageId + \"-\" + ( this . attachments ( ) . size ( ) + 1 ) ; return storeAttachment ( builder . buildFileDataSource ( name , attachmentStorage ) ) ; } return storeAttachment ( builder . buildByteArrayDataSource ( ) ) ; }", "comment": "Adds received attachment ."}
{"lang": "java", "code": "public static Statement getInstance ( Statement stmt ) { InvocationHandler handler = new JdbcLogStatement ( stmt ) ; ClassLoader cl = Statement . class . getClassLoader ( ) ; return ( Statement ) Proxy . newProxyInstance ( cl , new Class [ ] { Statement . class } , <mask> ) ; }", "comment": "Creates a logging version of a Statement"}
{"lang": "java", "code": "public void <mask> ( KeyValueBag inputOptions , KeyValueBag unsetOptions ) { VideoJNI . Coder_open ( swigCPtr , this , KeyValueBag . getCPtr ( inputOptions ) , inputOptions , KeyValueBag . getCPtr ( unsetOptions ) , unsetOptions ) ; }", "comment": "Open this Coder using the given bag of Codec - specific options . <br > <br >"}
{"lang": "java", "code": "@ Override public void getDataset ( Dataset ds , Object context ) { if ( ds . hasAccess ( ) ) { DataFactory tdataFactory = new DataFactory ( ) ; Access access = tdataFactory . chooseDatasetAccess ( ds . getAccess ( ) ) ; if ( access == null ) throw new IllegalStateException ( ) ; MFileRemote mfile = new MFileRemote ( access ) ; if ( mfile . getPath ( ) . endsWith ( \".xml\" ) ) return ; // eliminate latest.xml  LOOK kludge-o-rama mfiles . add ( mfile ) ; if ( debug ) <mask> . out . format ( \"add %s %n\" , mfile . getPath ( ) ) ; } }", "comment": "CatalogCrawler . Listener"}
{"lang": "java", "code": "protected void paintTrack ( Graphics g , JComponent c , Rectangle bounds ) { g . setColor ( colorScheme . getToolingBackground ( ) ) ; g . fillRect ( bounds . x , bounds . y , bounds . width , bounds . <mask> ) ; }", "comment": "{"}
{"lang": "java", "code": "private static ServiceConfiguration upgradeServicesIfNeeded ( StageLibraryTask library , StageConfiguration stageConf , ServiceConfiguration conf , IssueCreator issueCreator , List < Issue > issues ) { ServiceDefinition def = library . getServiceDefinition ( conf . getService ( ) , <mask> ) ; if ( def == null ) { issues . add ( issueCreator . create ( ContainerError . CONTAINER_0903 , conf . getService ( ) . getName ( ) ) ) ; } int fromVersion = conf . getServiceVersion ( ) ; int toVersion = def . getVersion ( ) ; // In case we don't need an upgrade if ( ! needsUpgrade ( toVersion , fromVersion , issueCreator , issues ) ) { return conf ; } ClassLoader cl = Thread . currentThread ( ) . getContextClassLoader ( ) ; try { LOG . warn ( \"Upgrading service instance from version '{}' to version '{}'\" , conf . getServiceVersion ( ) , def . getVersion ( ) ) ; UpgradeContext upgradeContext = new UpgradeContext ( \"\" , def . getName ( ) , stageConf . getInstanceName ( ) , fromVersion , toVersion ) ; List < Config > configs = def . getUpgrader ( ) . upgrade ( conf . getConfiguration ( ) , upgradeContext ) ; if ( ! upgradeContext . registeredServices . isEmpty ( ) ) { throw new StageException ( ContainerError . CONTAINER_0904 ) ; } conf . setServiceVersion ( toVersion ) ; conf . setConfig ( configs ) ; } catch ( StageException ex ) { issues . add ( issueCreator . create ( ex . getErrorCode ( ) , ex . getParams ( ) ) ) ; } finally { Thread . currentThread ( ) . setContextClassLoader ( cl ) ; } return conf ; }", "comment": "Internal method that will upgrade service configuration if needed ."}
{"lang": "java", "code": "public static DocumentRoot < QName > makeSBOL2SequenceComponent ( ) { TopLevelDocument < QName > pLac = TopLevelDocument ( Sbol2Terms . <mask> . sequenceComponent , sbolExample . namespacedUri ( \"sequenceComponent/pLac\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"pLac\" ) , NamedProperty ( Sbol2Terms . documented . displayId , \"pLac\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"DNA\" ) ) , NamedProperty ( Sbol2Terms . component . sequenceType , URI . create ( \"http://purl.org/obo/owl/SO#SO_0000167\" ) ) ) ) ; NestedDocument < QName > instantiationpLac = NestedDocument ( Sbol2Terms . instantiation . componentInstantiation , sbolExample . namespacedUri ( \"sequenceComponent/pLac/instantiation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"pLac\" ) , NamedProperty ( Sbol2Terms . component . component , pLac . getIdentity ( ) ) ) ) ; NestedDocument < QName > pLacAnnotation = NestedDocument ( Sbol2Terms . component . sequenceAnnotation , sbolExample . namespacedUri ( \"sequenceComponent/UU_002/pLac_annotation\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . component . orientation , \"inline\" ) , NamedProperty ( Sbol2Terms . instantiation . subComponentInstantiation , instantiationpLac ) ) ) ; TopLevelDocument < QName > lacIRepressibleGeneSequence = TopLevelDocument ( Sbol2Terms . component . sequence , sbolExample . namespacedUri ( \"sequenceComponent/UU_002/sequence\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . component . elements , \"atg\" ) ) ) ; TopLevelDocument < QName > lacIRepressibleGene = TopLevelDocument ( Sbol2Terms . component . sequenceComponent , sbolExample . namespacedUri ( \"sequenceComponent/UU_002\" ) , NamedProperties ( NamedProperty ( Sbol2Terms . documented . name , \"LacI Repressible Gene\" ) , NamedProperty ( Sbol2Terms . documented . displayId , \"UU_002\" ) , NamedProperty ( RdfTerms . rdfType , URI . create ( \"DNA\" ) ) , NamedProperty ( Sbol2Terms . component . sequenceType , URI . create ( \"http://purl.org/obo/owl/SO#SO_0000774\" ) ) , NamedProperty ( Sbol2Terms . component . annotation , pLacAnnotation ) , NamedProperty ( Sbol2Terms . component . hasSequence , lacIRepressibleGeneSequence . getIdentity ( ) ) ) ) ; return DocumentRoot ( NamespaceBindings ( SbolTerms . sbol2 ) , TopLevelDocuments ( lacIRepressibleGene , pLac , lacIRepressibleGeneSequence ) ) ; }", "comment": "Creates an example {"}
{"lang": "java", "code": "protected boolean isArrayStenoEvent ( @ Nullable <mask> Marker marker ) { return marker != null && marker . contains ( StenoMarker . ARRAY_MARKER ) ; }", "comment": "Determine whether the <code > marker< / code > represents an array event ."}
{"lang": "java", "code": "public static MethodInvocation createFromClass ( Object targetObject , Class < ? > clazz , String methodName , Class < ? > [ ] classArgs , Object [ ] args ) { Assert . notNull ( clazz , \"Class required\" ) ; Assert . hasText ( methodName , \"MethodName required\" ) ; Method method ; try { <mask> = clazz . getMethod ( methodName , classArgs ) ; } catch ( NoSuchMethodException e ) { return null ; } return new SimpleMethodInvocation ( targetObject , method , args ) ; }", "comment": "Generates a <code > MethodInvocation< / code > for specified <code > methodName< / code > on the passed class using the <code > args< / code > to locate the method ."}
{"lang": "java", "code": "public void transmitAll ( JSONObject <mask> ) { List < PnPeer > peerList = this . pcClient . getPeers ( ) ; for ( PnPeer p : peerList ) { transmit ( p . getId ( ) , message ) ; } }", "comment": "Send a custom JSONObject user message to all peers ."}
{"lang": "java", "code": "@ Override public Graphics create ( ) { SVGGraphics2D copy = new SVGGraphics2D ( this ) ; copy . setRenderingHints ( getRenderingHints ( ) ) ; copy . setTransform ( getTransform ( ) ) ; copy . setClip ( getClip ( ) ) ; copy . setPaint ( getPaint ( ) ) ; copy . setColor ( getColor ( ) ) ; copy . setComposite ( getComposite ( ) ) ; copy . setStroke ( getStroke ( ) ) ; copy . setFont ( getFont ( ) ) ; copy . setBackground ( getBackground ( ) ) ; copy . setFilePrefix ( getFilePrefix ( ) ) ; <mask> . setFileSuffix ( getFileSuffix ( ) ) ; return copy ; }", "comment": "Creates a new graphics object that is a copy of this graphics object ( except that it has not accumulated the drawing operations ) . Not sure yet when or why this would be useful when creating SVG output . Note that the { @code fontMapper } object ( { @link #getFontMapper () } ) is shared between the existing instance and the new one ."}
{"lang": "java", "code": "public static HrefSet create ( Document document , QualifiedName name ) { Assert . isNotNull ( document ) ; Assert . isTrue ( document . getOwnerDocument ( ) == null ) ; Assert . isNotNull ( name ) ; Assert . isTrue ( DAV_NS . equals ( name . getQualifier ( ) ) ) ; Element element = create ( document , name . getLocalName ( ) ) ; try { return new HrefSet ( element , name ) ; } catch ( MalformedElementException e ) { Assert . isTrue ( <mask> , Policy . bind ( \"assert.internalError\" ) ) ; //$NON-NLS-1$ return null ; // Never reached. } }", "comment": "Creates a new href set element with the given name and sets it as the root of the given document . Returns an editor on the new href set element . The document must not be <code > null< / code > and must not already have a root element ."}
{"lang": "java", "code": "@ SuppressWarnings ( \"deprecation\" ) protected void additionalAuthenticationChecks ( UserDetails userDetails , UsernamePasswordAuthenticationToken authentication ) throws AuthenticationException { if ( authentication . getCredentials ( ) == null ) { logger . debug ( \"Authentication failed: no credentials provided\" ) ; throw new BadCredentialsException ( messages . getMessage ( \"AbstractUserDetailsAuthenticationProvider.badCredentials\" , \"Bad credentials\" ) ) ; } String presentedPassword = authentication . getCredentials ( ) . toString ( ) ; if ( ! passwordEncoder . matches ( presentedPassword , userDetails . getPassword ( ) ) ) { logger . <mask> ( \"Authentication failed: password does not match stored value\" ) ; throw new BadCredentialsException ( messages . getMessage ( \"AbstractUserDetailsAuthenticationProvider.badCredentials\" , \"Bad credentials\" ) ) ; } }", "comment": "========================================================================================================"}
{"lang": "java", "code": "public static String productInfo ( File installDirectory , String action ) throws PluginExecutionException { <mask> pr = null ; InputStream is = null ; Scanner s = null ; Worker worker = null ; try { String command ; if ( OSUtil . isWindows ( ) ) { command = installDirectory + \"\\\\bin\\\\productInfo.bat \" + action ; } else { command = installDirectory + \"/bin/productInfo \" + action ; } pr = Runtime . getRuntime ( ) . exec ( command ) ; worker = new Worker ( pr ) ; worker . start ( ) ; worker . join ( 300000 ) ; if ( worker . exit == null ) { throw new PluginExecutionException ( \"productInfo command timed out\" ) ; } int exitValue = pr . exitValue ( ) ; if ( exitValue != 0 ) { throw new PluginExecutionException ( \"productInfo exited with return code \" + exitValue ) ; } is = pr . getInputStream ( ) ; s = new Scanner ( is ) ; // use regex to match the beginning of the input s . useDelimiter ( \"\\\\A\" ) ; if ( s . hasNext ( ) ) { return s . next ( ) ; } return null ; } catch ( IOException ex ) { throw new PluginExecutionException ( \"productInfo error: \" + ex ) ; } catch ( InterruptedException ex ) { worker . interrupt ( ) ; Thread . currentThread ( ) . interrupt ( ) ; throw new PluginExecutionException ( \"productInfo error: \" + ex ) ; } finally { if ( s != null ) { s . close ( ) ; } if ( is != null ) { try { is . close ( ) ; } catch ( IOException e ) { } } if ( pr != null ) { pr . destroy ( ) ; } } }", "comment": "Runs the productInfo command and returns the output"}
{"lang": "java", "code": "public JsonFlattener withSeparator ( <mask> separator ) { isTrue ( ! Character . toString ( separator ) . matches ( \"[\\\"\\\\s]\" ) , \"Separator contains illegal chracter(%s)\" , Character . toString ( separator ) ) ; isTrue ( ! leftBracket . equals ( separator ) && ! rightBracket . equals ( separator ) , \"Separator(%s) is already used in brackets\" , Character . toString ( separator ) ) ; this . separator = separator ; flattenedMap = null ; return this ; }", "comment": "A fluent setter to setup the separator within a key in the flattened JSON . The default separator is a dot ( . ) ."}
{"lang": "java", "code": "private static String getFieldValue ( HollowDiffViewRow row , boolean useFrom ) { Field field = useFrom ? <mask> . getFieldPair ( ) . getFrom ( ) : row . getFieldPair ( ) . getTo ( ) ; if ( row . getFieldPair ( ) . isLeafNode ( ) ) { return field . getValue ( ) == null ? \"null\" : field . getValue ( ) . toString ( ) . replace ( \"|\" , \"&#x2502\" ) ; } else { String suffix = field . getValue ( ) == null ? \" [null]\" : \"\" ; return \"(\" + field . getTypeName ( ) + \")\" + suffix ; } }", "comment": "Returns a String representation of the provided row s field value . If useFrom is true this will use the from value from the pair otherwise this will use the to value ."}
{"lang": "java", "code": "public static < E > ErrorMessageFactory shouldBeLenientEqualByIgnoring ( Object actual , List < String > rejectedFields , List < Object > expectedValues , List < String > ignoredFields ) { if ( rejectedFields . size ( ) == 1 ) { if ( ignoredFields . isEmpty ( ) ) { return new ShouldBeLenientEqualByIgnoring ( <mask> , rejectedFields . get ( 0 ) , expectedValues . get ( 0 ) ) ; } else { return new ShouldBeLenientEqualByIgnoring ( actual , rejectedFields . get ( 0 ) , expectedValues . get ( 0 ) , ignoredFields ) ; } } else { if ( ignoredFields . isEmpty ( ) ) { return new ShouldBeLenientEqualByIgnoring ( actual , rejectedFields , expectedValues ) ; } else { return new ShouldBeLenientEqualByIgnoring ( actual , rejectedFields , expectedValues , ignoredFields ) ; } } }", "comment": "Creates a new < / code > {"}
{"lang": "java", "code": "public DeployableUnitDescriptor [ ] getDescriptors ( DeployableUnitID [ ] duIds ) throws NullPointerException , ManagementException { if ( duIds == null ) throw new NullPointerException ( \"Null arg!\" ) ; final DeployableUnitManagement deployableUnitManagement = getSleeContainer ( ) . getDeployableUnitManagement ( ) ; try { <mask> < DeployableUnitDescriptor > result = new HashSet < DeployableUnitDescriptor > ( ) ; for ( DeployableUnitID deployableUnitID : deployableUnitManagement . getDeployableUnits ( ) ) { DeployableUnit deployableUnit = deployableUnitManagement . getDeployableUnit ( deployableUnitID ) ; result . add ( deployableUnit . getSpecsDeployableUnitDescriptor ( ) ) ; } return result . toArray ( new DeployableUnitDescriptor [ 0 ] ) ; } catch ( Throwable ex ) { throw new ManagementException ( \"Error in tx manager \" , ex ) ; } }", "comment": "/ * ( non - Javadoc )"}
{"lang": "java", "code": "protected void startTimer ( TimerImpl timer ) { // if there's no transaction, then trigger a schedule immediately. // Else, the timer will be scheduled on tx synchronization callback if ( ! transactionActive ( ) ) { this . timers . put ( <mask> . getId ( ) , timer ) ; // set active if the timer is started if it was read // from persistence as current running to ensure correct schedule here timer . setTimerState ( TimerState . ACTIVE , null ) ; // create and schedule a timer task this . registerTimerResource ( timer . getId ( ) ) ; timer . scheduleTimeout ( true ) ; } else { addWaitingOnTxCompletionTimer ( timer ) ; registerSynchronization ( new TimerCreationTransactionSynchronization ( timer ) ) ; } }", "comment": "Registers a timer with a transaction ( if any in progress ) and then moves the timer to an active state so that it becomes eligible for timeouts"}
{"lang": "java", "code": "<mask> void setDepLabel ( String v ) { if ( Token_Type . featOkTst && ( ( Token_Type ) jcasType ) . casFeat_depLabel == null ) jcasType . jcas . throwFeatMissing ( \"depLabel\" , \"edu.cmu.lti.oaqa.type.nlp.Token\" ) ; jcasType . ll_cas . ll_setStringValue ( addr , ( ( Token_Type ) jcasType ) . casFeatCode_depLabel , v ) ; }", "comment": "setter for depLabel - sets The dependency label of the token with respect to its head ."}
{"lang": "java", "code": "private String getAuthMethod ( <mask> Deployment dep ) { for ( final Endpoint ejbEndpoint : dep . getService ( ) . getEndpoints ( ) ) { final String beanAuthMethod = ejb3SecurityAccessor . getAuthMethod ( ejbEndpoint ) ; final boolean hasBeanAuthMethod = beanAuthMethod != null ; if ( hasBeanAuthMethod ) { // First found auth-method defines war // login-config/auth-method return beanAuthMethod ; } } return null ; }", "comment": "Returns deployment authentication method ."}
{"lang": "java", "code": "void getLuma12Unsafe ( byte [ ] pic , int picW , int imgH , byte [ ] blk , int blkOff , int blkStride , int x , int y , int blkW , int blkH ) { int tmpW = blkW + 7 ; getLuma02UnsafeNoRound ( pic , picW , imgH , tmp1 , 0 , tmpW , x - 2 , y , tmpW , blkH ) ; getLuma20NoRoundInt ( tmp1 , tmpW , tmp2 , blkOff , blkStride , 2 , 0 , blkW , blkH ) ; int off = 2 ; for ( int j = 0 ; j < blkH ; j ++ ) { for ( int i = 0 ; i < blkW ; i ++ ) { int rounded = clip ( ( tmp2 [ blkOff + i ] + 512 ) >> 10 , - 128 , 127 ) ; int rounded2 = <mask> ( ( tmp1 [ off + i ] + 16 ) >> 5 , - 128 , 127 ) ; blk [ blkOff + i ] = ( byte ) ( ( rounded + rounded2 + 1 ) >> 1 ) ; } blkOff += blkStride ; off += tmpW ; } }", "comment": "Qpel ( 1 2 ) unsafe"}
{"lang": "java", "code": "public QRCode toFile ( String qrcodeFile , String appendFile ) { return toFile ( new File ( qrcodeFile ) , new <mask> ( appendFile ) ) ; }", "comment": "\u628a\u6307\u5b9a\u7684\u5185\u5bb9\u751f\u6210\u4e3a\u4e00\u4e2a QRCode \u7684\u56fe\u7247\uff0c\u5e76\u5728\u8be5\u56fe\u7247\u4e2d\u95f4\u6dfb\u52a0\u4e0a\u6307\u5b9a\u7684\u56fe\u7247\uff1b\u4e4b\u540e\u4fdd\u5b58\u5230\u6307\u5b9a\u7684\u6587\u4ef6\u5185\u3002"}
{"lang": "java", "code": "private static void addPuService ( final DeploymentPhaseContext phaseContext , final ArrayList < PersistenceUnitMetadataHolder > puList , final boolean startEarly , final Platform platform ) throws DeploymentUnitProcessingException { if ( puList . size ( ) > 0 ) { final DeploymentUnit deploymentUnit = phaseContext . getDeploymentUnit ( ) ; final <mask> module = deploymentUnit . getAttachment ( Attachments . MODULE ) ; final EEModuleDescription eeModuleDescription = deploymentUnit . getAttachment ( org . jboss . as . ee . component . Attachments . EE_MODULE_DESCRIPTION ) ; final ServiceTarget serviceTarget = phaseContext . getServiceTarget ( ) ; final ModuleClassLoader classLoader = module . getClassLoader ( ) ; for ( PersistenceUnitMetadataHolder holder : puList ) { setAnnotationIndexes ( holder , deploymentUnit ) ; for ( PersistenceUnitMetadata pu : holder . getPersistenceUnits ( ) ) { // only start the persistence unit if JPA_CONTAINER_MANAGED is true String jpaContainerManaged = pu . getProperties ( ) . getProperty ( Configuration . JPA_CONTAINER_MANAGED ) ; boolean deployPU = ( jpaContainerManaged == null ? true : Boolean . parseBoolean ( jpaContainerManaged ) ) ; if ( deployPU ) { final PersistenceProviderDeploymentHolder persistenceProviderDeploymentHolder = getPersistenceProviderDeploymentHolder ( deploymentUnit ) ; final PersistenceProvider provider = lookupProvider ( pu , persistenceProviderDeploymentHolder , deploymentUnit ) ; final PersistenceProviderAdaptor adaptor = getPersistenceProviderAdaptor ( pu , persistenceProviderDeploymentHolder , deploymentUnit , provider , platform ) ; final boolean twoPhaseBootStrapCapable = ( adaptor instanceof TwoPhaseBootstrapCapable ) && Configuration . allowTwoPhaseBootstrap ( pu ) ; if ( startEarly ) { if ( twoPhaseBootStrapCapable ) { deployPersistenceUnitPhaseOne ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , adaptor ) ; } else if ( false == Configuration . needClassFileTransformer ( pu ) ) { // will start later when startEarly == false ROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is configured to not need class transformer to be set, no class rewriting will be allowed\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) ) ; } else { // we need class file transformer to work, don't allow cdi bean manager to be access since that // could cause application classes to be loaded (workaround by setting jboss.as.jpa.classtransformer to false).  WFLY-1463 final boolean allowCdiBeanManagerAccess = false ; deployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; } } else { // !startEarly if ( twoPhaseBootStrapCapable ) { deployPersistenceUnitPhaseTwo ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor ) ; } else if ( false == Configuration . needClassFileTransformer ( pu ) ) { final boolean allowCdiBeanManagerAccess = true ; // PUs that have Configuration.JPA_CONTAINER_CLASS_TRANSFORMER = false will start during INSTALL phase deployPersistenceUnit ( deploymentUnit , eeModuleDescription , serviceTarget , classLoader , pu , provider , adaptor , allowCdiBeanManagerAccess ) ; } } } else { ROOT_LOGGER . tracef ( \"persistence unit %s in deployment %s is not container managed (%s is set to false)\" , pu . getPersistenceUnitName ( ) , deploymentUnit . getName ( ) , Configuration . JPA_CONTAINER_MANAGED ) ; } } } } }", "comment": "Add one PU service per top level deployment that represents"}
{"lang": "java", "code": "public static < E > UnicastProcessor < E > create ( Queue < E > <mask> , Disposable endcallback ) { return new UnicastProcessor <> ( queue , endcallback ) ; }", "comment": "Create a new { @link UnicastProcessor } that will buffer on a provided queue in an unbounded fashion ."}
{"lang": "java", "code": "public static < T extends Annotation > Collection < Field > getFieldsWithAnnotationInClass ( Class < ? > inClazz , Class < T > annotationClass ) { Collection < Field > fieldCollection = null ; Field [ ] <mask> = inClazz . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) || Modifier . isFinal ( field . getModifiers ( ) ) ) { continue ; } T t = readAnnotationValueOnField ( field , annotationClass ) ; if ( t == null ) { continue ; } if ( fieldCollection == null ) { fieldCollection = new ArrayList < Field > ( ) ; } fieldCollection . add ( field ) ; } return fieldCollection ; }", "comment": "\u5728\u7c7b\u5185\u641c\u7d22\u4f7f\u7528annotationClass\u6ce8\u89e3\u7684\u5b57\u6bb5\uff08\u5305\u62ec\u5728get\u3001set\u65b9\u6cd5\u4e0a\u6ce8\u89e3\uff09"}
{"lang": "java", "code": "public void createPartControl ( Composite parent ) { viewer = new PaletteViewer ( ) ; viewer . createControl ( parent ) ; PaletteRoot root = new PaletteRoot ( ) ; String [ ] category = getCategories ( ) ; for ( int i = 0 ; i < category . length ; i ++ ) { PaletteDrawer group = new PaletteDrawer ( category [ i ] ) ; IPaletteItem [ ] items = getPaletteItems ( category [ i ] ) ; for ( int j = 0 ; j < items . length ; j ++ ) { HTMLPaletteEntry entry = new HTMLPaletteEntry ( items [ j ] . getLabel ( ) , null , items [ j ] . getImageDescriptor ( ) ) ; tools . put ( entry , items [ j ] ) ; group . add ( entry ) ; } root . <mask> ( group ) ; } viewer . setPaletteRoot ( root ) ; viewer . getControl ( ) . addMouseListener ( new MouseAdapter ( ) { @ Override public void mouseDoubleClick ( MouseEvent e ) { //\t\t\t\tIWorkbenchPage page = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage(); \r //\t\t\t\tIEditorPart editorPart = page.getActiveEditor();\r //\t\t\t\tif(editorPart!=null){\r //\t\t\t\t\teditorPart.setFocus();\r //\t\t\t\t}\r if ( e . button == 1 ) { EditPart part = PaletteView . this . viewer . findObjectAt ( new Point ( e . x , e . y ) ) ; IPaletteItem item = null ; if ( part != null ) { if ( part . getModel ( ) instanceof HTMLPaletteEntry ) item = tools . get ( part . getModel ( ) ) ; } if ( item != null ) insert ( item ) ; } } } ) ; }", "comment": "create controls and apply configurations ."}
{"lang": "java", "code": "public ArrayStructure readStructure ( int start , int count ) throws IOException , ucar . ma2 . InvalidRangeException { if ( getRank ( ) != 1 ) throw new java . lang . UnsupportedOperationException ( \"not a vector structure\" ) ; int [ ] origin = new int [ ] { start } ; int [ ] shape = new int [ ] { count } ; if ( NetcdfFile . debugStructureIterator ) System . out . println ( \"readStructure \" + start + \" \" + <mask> ) ; return ( ArrayStructure ) read ( origin , shape ) ; }", "comment": "For rank 1 array of Structures read count Structures and return the data as an ArrayStructure . Use only when this is a one dimensional array of Structures ."}
{"lang": "java", "code": "public int getParallelism ( ) throws StageException { if ( originParallelism == 0 ) { //origin parallelism is not yet calculated originParallelism = kafkaValidationUtil . getPartitionCount ( conf . metadataBrokerList , conf . <mask> , new HashMap < String , Object > ( conf . kafkaConsumerConfigs ) , 3 , 1000 ) ; if ( originParallelism < 1 ) { throw new StageException ( KafkaErrors . KAFKA_42 , conf . topic ) ; } } return originParallelism ; }", "comment": "This API is being used by ClusterKafkaSource"}
{"lang": "java", "code": "public static < E > <mask> < E > createSameAsFilter ( final E base ) { return new Filter < E > ( ) { public boolean isValid ( E obj ) { return ( base == obj ) ; } } ; }", "comment": "Creates a filter where valid when an object in a collection is the <strong > same as< / strong > the base object ."}
{"lang": "java", "code": "private String fixPath ( String path ) { if ( ! path . isEmpty ( ) ) { if ( ! path . endsWith ( \"/\" ) ) return path + ' ' ; else return <mask> ; } else return path ; }", "comment": "Helps to fix path"}
{"lang": "java", "code": "public static < T > T deref ( final Object obj , <mask> < T > expected ) { Object result = deref ( obj ) ; if ( result == null ) return null ; return expected . cast ( result ) ; }", "comment": "Dereference an object"}
{"lang": "java", "code": "@ Deprecated public static Result ofSource ( Long entityLength , Source < ByteString , ? > source , String fileName , String contentType ) { return ofSource ( Http . Context . current ( ) . request ( ) , entityLength , <mask> , fileName , contentType ) ; }", "comment": "Returns the stream as a result considering Range header . If the header is present and it is satisfiable then a Result containing just the requested part will be returned . If the header is not present or is unsatisfiable then a regular Result will be returned ."}
{"lang": "java", "code": "private FutureCallback < ResultSet > wrapCallbackRow ( FutureCallback < Row > callback ) { return new FutureCallback < ResultSet > ( ) { @ Override public void onSuccess ( ResultSet result ) { try { <mask> . onSuccess ( result . one ( ) ) ; } finally { asyncSemaphore . release ( ) ; } } @ Override public void onFailure ( Throwable t ) { try { callback . onFailure ( t ) ; } finally { asyncSemaphore . release ( ) ; } } } ; }", "comment": "/ * ----------------------------------------------------------------------"}
{"lang": "java", "code": "public void layoutContainer ( Container target ) { synchronized ( target . getTreeLock ( ) ) { if ( debug ) System . out . println ( name + \" layoutContainer \" ) ; // first layout any nested LayoutM components // it seems that generally Swing laysout from outer to inner ??? int n = <mask> . getComponentCount ( ) ; for ( int i = 0 ; i < n ; i ++ ) { Component comp = target . getComponent ( i ) ; if ( comp instanceof Container ) { Container c = ( Container ) comp ; LayoutManager m = c . getLayout ( ) ; if ( m instanceof LayoutM ) m . layoutContainer ( c ) ; } } // now layout this container reset ( target ) ; globalBounds = new Rectangle ( 0 , 0 , 0 , 0 ) ; while ( ! layoutPass ( target ) ) target . setPreferredSize ( globalBounds . getSize ( ) ) ; // ?? } }", "comment": "Lays out the specified container ."}
{"lang": "java", "code": "private void setReadTimeout ( javax . <mask> . rs . client . Client client ) { // The timeout value. int timeout = mSettings . getReadTimeout ( ) ; synchronized ( mReadTimeoutLock ) { if ( mCurrentReadTimeout == timeout ) { // The given value is the same as the current one. // Let's skip calling property() method. return ; } // The given value is different from the current value. // Let's update the configuration. mCurrentReadTimeout = timeout ; } //---------------------------------------------------------------------- // Note that there was no standardized way to set the read timeout // before JAX-RS API 2.1 (Java EE 8) (cf. ClientBuilder.readTimeout). //---------------------------------------------------------------------- // Convert int to Integer before calling property() method multiple times // in order to reduce the number of object creation by autoboxing. Integer value = Integer . valueOf ( timeout ) ; // For Jersey client . property ( \"jersey.config.client.readTimeout\" , value ) ; // For Apache CXF client . property ( \"http.receive.timeout\" , value ) ; // For WebSphere (8.5.5.7+) client . property ( \"com.ibm.ws.jaxrs.client.receive.timeout\" , value ) ; }", "comment": "Set a read timeout ."}
{"lang": "java", "code": "protected String fixRelativeUrl ( final String url , final String offsetPath ) { final StringBuilder res = new StringBuilder ( ) ; res . append ( \"url('\" ) ; if ( ! url . startsWith ( StringPool . SLASH ) ) { res . append ( \"../\" ) . append ( offsetPath ) ; } res . append ( url ) . append ( \"')\" ) ; return <mask> . toString ( ) ; }", "comment": "For a given URL ( optionally quoted ) produces CSS URL where relative paths are fixed and prefixed with offsetPath ."}
{"lang": "java", "code": "public static Collection < URL > forPackage ( String <mask> , ClassLoader ... classLoaders ) { return forResource ( resourceName ( name ) , classLoaders ) ; }", "comment": "Returns a distinct collection of URLs based on a package name . <p > This searches for the package name as a resource using { @link ClassLoader#getResources ( String ) } . For example { @code forPackage ( org . reflections ) } effectively returns URLs from the classpath containing packages starting with { @code org . reflections } . <p > If the optional { @link ClassLoader } s are not specified then both { @link #contextClassLoader () } and { @link #staticClassLoader () } are used for { @link ClassLoader#getResources ( String ) } . <p > The returned URLs retains the order of the given { @code classLoaders } ."}
{"lang": "java", "code": "public void update ( final DBObject update ) { new BulkUpdateRequestBuilder ( bulkWriteOperation , query , false , codec , replacementCodec , collation , null ) . <mask> ( update ) ; }", "comment": "Adds a request to update all documents in the collection that match the query with which this builder was created ."}
{"lang": "java", "code": "@ Override public Socket createSocket ( InetAddress host , int port ) throws IOException { SSLSocket <mask> = ( SSLSocket ) delegate . createSocket ( host , port ) ; parameters . configure ( new SSLConfigurableSocket ( socket ) ) ; return socket ; }", "comment": "{"}
{"lang": "java", "code": "<mask> Dimension getScaledSize ( ) { if ( scaledPicture != null ) return new Dimension ( scaledPicture . getWidth ( ) , scaledPicture . getHeight ( ) ) ; else return new Dimension ( 0 , 0 ) ; }", "comment": "return the size of the scaled image or Zero if there is none"}
{"lang": "java", "code": "@ Override public void init ( ) throws ServletException { <mask> . init ( ) ; String casServiceHost = System . getProperty ( \"cas.service.host\" , \"localhost:8443\" ) ; targetUrl = \"https://\" + casServiceHost + \"/cas-sample/secure/\" ; }", "comment": "Initialize the target URL . It allows for the host to change based upon the cas . service . host system property . If the property is not set the default is localhost : 8443 ."}
{"lang": "java", "code": "protected int submit ( String name , Config conf , TopologyBuilder builder ) { // register Metadata for serialization with FieldsSerializer Config . registerSerialization ( conf , Metadata . class ) ; if ( isLocal ) { LocalCluster cluster = new LocalCluster ( ) ; cluster . submitTopology ( name , conf , <mask> . createTopology ( ) ) ; if ( ttl != - 1 ) { Utils . sleep ( ttl * 1000 ) ; cluster . shutdown ( ) ; } } else { try { StormSubmitter . submitTopology ( name , conf , builder . createTopology ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return - 1 ; } } return 0 ; }", "comment": "Submits the topology under a specific name *"}
{"lang": "java", "code": "public IconRow getIcon ( FeatureRow featureRow , GeometryType geometryType ) { <mask> getIcon ( featureRow . getId ( ) , geometryType ) ; }", "comment": "Get the icon of the feature row with the provided geometry type searching in order : feature geometry type icon feature default icon table geometry type icon table default icon"}
{"lang": "java", "code": "<mask> final void setJwtValidatorFactory ( Function < ClientRegistration , OAuth2TokenValidator < Jwt > > jwtValidatorFactory ) { Assert . notNull ( jwtValidatorFactory , \"jwtValidatorFactory cannot be null\" ) ; this . jwtValidatorFactory = jwtValidatorFactory ; }", "comment": "Sets the factory that provides an { @link OAuth2TokenValidator } which is used by the { @link JwtDecoder } . The default is { @link OidcIdTokenValidator } ."}
{"lang": "java", "code": "public static Point2D_F64 closestPoint ( EllipseRotated_F64 ellipse , Point2D_F64 p ) { ClosestPointEllipseAngle_F64 alg = new ClosestPointEllipseAngle_F64 ( GrlConstants . TEST_F64 , 30 ) ; alg . setEllipse ( ellipse ) ; alg . <mask> ( p ) ; return alg . getClosest ( ) ; }", "comment": "Computes the closest point on an ellipse to the provided point . If there are multiple solutions then one is arbitrarily chosen ."}
{"lang": "java", "code": "public static ShareStats readShareStatsFromStream ( final InputStream inStream ) throws ParserConfigurationException , SAXException , IOException { SAXParser saxParser = Utility . getSAXParser ( ) ; ShareStatsHandler handler = new ShareStatsHandler ( ) ; saxParser . <mask> ( inStream , handler ) ; return handler . stats ; }", "comment": "Constructs a { @link ShareStats } object from an XML document received from the service ."}
{"lang": "java", "code": "public boolean isHigherLevel ( TraceLevel other ) throws NullPointerException { if ( other == null ) throw new NullPointerException ( \"other is null\" ) ; return this . <mask> < other . level ; }", "comment": "Determine if this TraceLevel object represents a level that is higher than some other TraceLevel object . For the purposes of the comparison OFF is considered a higher level than SEVERE and FINEST is the lowest level ."}
{"lang": "java", "code": "public < TArg0 , TArg1 , TArg2 > TriggerWithParameters3 < TArg0 , TArg1 , TArg2 , TTrigger > setTriggerParameters ( TTrigger <mask> , Class < TArg0 > classe0 , Class < TArg1 > classe1 , Class < TArg2 > classe2 ) { TriggerWithParameters3 < TArg0 , TArg1 , TArg2 , TTrigger > configuration = new TriggerWithParameters3 <> ( trigger , classe0 , classe1 , classe2 ) ; saveTriggerConfiguration ( configuration ) ; return configuration ; }", "comment": "Specify the arguments that must be supplied when a specific trigger is fired"}
{"lang": "java", "code": "@ Beta public static < K , V > Map < K , <mask> < V > > asMap ( Multimap < K , V > multimap ) { return multimap . asMap ( ) ; }", "comment": "Returns { @link Multimap#asMap multimap . asMap () } . This is provided for parity with the other more strongly - typed { @code asMap () } implementations ."}
{"lang": "java", "code": "public synchronized boolean isLocatorCurrentInDiscoveryLayer ( Locator loc ) { LocatorCacheEntry entry = insertedLocators . getIfPresent ( loc . toString ( ) ) ; return entry != null && <mask> . isDiscoveryCurrent ( ) ; }", "comment": "Checks if Locator is recently inserted in the discovery layer"}
{"lang": "java", "code": "private boolean tryComplete ( Consumer < FutureImpl < T > > c ) { if ( completed . compareAndSet ( false , true ) ) { //This Try is only here to manage any unforeseen exception raised by the Future event listener //See issue#41 Try ( ( ) -> c . <mask> ( future ) ) ; return true ; } return false ; }", "comment": "Internal try complete method that takes a consumer to apply the Future this Promise holds . <br > Performs a check if this Promise already has been fulfilled or not ."}
{"lang": "java", "code": "public void addSecuredAttributeWithDisplay ( String vaultBlock , String attributeName , char [ ] attributeValue ) throws <mask> { vault . store ( vaultBlock , attributeName , attributeValue , null ) ; attributeCreatedDisplay ( vaultBlock , attributeName ) ; }", "comment": "Add secured attribute to specified vault block . This method can be called only after successful startVaultSession () call . After successful storage the secured attribute information will be displayed at standard output . For silent method @see addSecuredAttribute"}
{"lang": "java", "code": "public static String <mask> ( InputStream in , Charset charset ) throws IOException { return read ( new InputStreamReader ( in , charset ) ) ; }", "comment": "Reads the whole content of the given { @code InputStream } into a { @code String } using the specified charset ."}
{"lang": "java", "code": "public void connectionFailed ( SocketConnector connector , Exception ex ) { if ( ex instanceof InterruptedException ) { addWarn ( \"connector interrupted\" , ex ) ; } else if ( <mask> instanceof ConnectException ) { addWarn ( receiverId + \"connection refused\" , ex ) ; } else { addWarn ( receiverId + \"unspecified error\" , ex ) ; } }", "comment": "{"}
{"lang": "java", "code": "@ Override public boolean hasNext ( ) { if ( this . current >= odomset . size ( ) ) return false ; Odometer ocurrent = odomset . get ( this . <mask> ) ; if ( ocurrent . hasNext ( ) ) return true ; // Try to move to next odometer this . current ++ ; return hasNext ( ) ; }", "comment": "Iterator API Overrides"}
{"lang": "java", "code": "public static Object create ( Class superclass , <mask> [ ] interfaces , CallbackFilter filter , Callback [ ] callbacks ) { Enhancer e = new Enhancer ( ) ; e . setSuperclass ( superclass ) ; e . setInterfaces ( interfaces ) ; e . setCallbackFilter ( filter ) ; e . setCallbacks ( callbacks ) ; return e . create ( ) ; }", "comment": "Helper method to create an intercepted object . For finer control over the generated instance use a new instance of <code > Enhancer< / code > instead of this static method ."}
{"lang": "java", "code": "public static int addDataForArr ( FlatBufferBuilder bufferBuilder , INDArray arr ) { int offset = DataBufferStruct . createDataBufferStruct ( bufferBuilder , arr . data ( ) ) ; int ret = <mask> . createBuffer ( bufferBuilder , offset , arr . data ( ) . length ( ) * arr . data ( ) . getElementSize ( ) ) ; return ret ; }", "comment": "Create a {"}
{"lang": "java", "code": "static public String join ( String [ ] array , String sep , int from , int upto ) { if ( sep == null ) sep = \"\" ; if ( from < 0 || upto > array . length ) throw new IndexOutOfBoundsException ( ) ; if ( upto <= from ) return \"\" ; StringBuilder result = new StringBuilder ( ) ; boolean <mask> = true ; for ( int i = from ; i < upto ; i ++ , first = false ) { if ( ! first ) result . append ( sep ) ; result . append ( array [ i ] ) ; } return result . toString ( ) ; }", "comment": "Given an Array of Strings and a separator and a count concat the first count elements of an array with separator between them . A null string is treated like ."}
{"lang": "java", "code": "@ XmlElementDecl ( namespace = \"\" , <mask> = \"cloudiness\" , scope = LocationType . class ) public JAXBElement < Cloudiness > createLocationTypeCloudiness ( Cloudiness value ) { return new JAXBElement < Cloudiness > ( _LocationTypeCloudiness_QNAME , Cloudiness . class , LocationType . class , value ) ; }", "comment": "Create an instance of { @link JAXBElement } { @code < } { @link Cloudiness } { @code > }}"}
{"lang": "java", "code": "@ Override public void persistInstance ( InstanceKey instanceKey , Object instance ) { // at this point managed class and instance are guaranteed to be non null\r ThreadLocal < Object > tls = instancesPool . get ( instanceKey ) ; if ( tls == null ) { throw new BugError ( \"Invalid methods invocation sequence. Ensure getInstance() is invoked before and is executed in the same thread.\" ) ; } tls . <mask> ( instance ) ; }", "comment": "Persist instance on current thread bound to given managed class . This method simply uses provided instance key argument to add instance to { @link #instancesPool } . Both arguments should to be not null ."}
{"lang": "java", "code": "public String serialize ( final ILoggingEvent event , final String eventName , final String jsonData ) throws Exception { final StringWriter jsonWriter = new StringWriter ( ) ; final JsonGenerator jsonGenerator = _jsonFactory . createGenerator ( jsonWriter ) ; // Start wrapper StenoSerializationHelper . startStenoWrapper ( event , eventName , jsonGenerator , _objectMapper ) ; // Write event data jsonGenerator . writeFieldName ( \"data\" ) ; if ( jsonData == null ) { jsonGenerator . writeStartObject ( ) ; jsonGenerator . writeEndObject ( ) ; } else { jsonGenerator . writeRawValue ( jsonData ) ; } // TODO(vkoskela): Support writing null objects as-is via configuration [ISSUE-4] // e.g. \"data\":null -- although this is not supported by the current Steno specification // Output throwable StenoSerializationHelper . writeThrowable ( event . getThrowableProxy ( ) , jsonGenerator , _objectMapper ) ; // End wrapper StenoSerializationHelper . endStenoWrapper ( <mask> , eventName , jsonGenerator , _objectMapper , _encoder ) ; return jsonWriter . toString ( ) ; }", "comment": "Serialize an event ."}
{"lang": "java", "code": "public boolean isHigherLevel ( AlarmLevel other ) throws NullPointerException { if ( other == null ) throw new NullPointerException ( \"other is null\" ) ; return this . <mask> < other . level ; }", "comment": "Determine if this AlarmLevel object represents a level that is higher than some other AlarmLevel object . For the purposes of the comparison the following order from highest to lowest severity is assumed for alarm levels : <ul > <li > CLEAR <li > CRITICAL <li > MAJOR <li > WARNING <li > INDETERMINATE <li > MINOR < / ul >"}
{"lang": "java", "code": "public void addSoftConstraintMatch ( RuleContext kcontext , BigDecimal softWeight ) { softScore = softScore . <mask> ( softWeight ) ; registerConstraintMatch ( kcontext , ( ) -> softScore = softScore . subtract ( softWeight ) , ( ) -> HardMediumSoftBigDecimalScore . of ( BigDecimal . ZERO , BigDecimal . ZERO , softWeight ) ) ; }", "comment": "Add a soft constraint match of specified weighting ."}
{"lang": "java", "code": "@ Override public void addTag ( String tagName , int value , String attrName , String attrValue ) { addTag ( tagName , String . valueOf ( <mask> ) , attrName , attrValue ) ; }", "comment": "Adds a tag which contains an attribute"}
{"lang": "java", "code": "private void getMoreBytes ( ) throws IOException { currentOffset = 0 ; // reset current array offset to 0\r int bytesRead = 0 ; // bytes read so far\r int lookingFor = 0 ; // character in endSequence to look for\r for ( ; bytesRead < lineBuf . length ; bytesRead ++ ) { int c = in . read ( ) ; if ( c == - 1 ) break ; // break on EOL and return what we have so far\r lineBuf [ bytesRead ] = ( byte ) c ; if ( lineBuf [ bytesRead ] == endSequence [ lookingFor ] ) { lookingFor ++ ; if ( lookingFor == endSequence . length ) { endFound = <mask> ; break ; } } else if ( lineBuf [ bytesRead ] == endSequence [ 0 ] ) { // CHANGED JC\r lookingFor = 1 ; } else { lookingFor = 0 ; } } bytesRemaining = bytesRead ; // number of bytes we've read\r }", "comment": "Get more bytes into buffer . Stop when endSequence is found ."}
{"lang": "java", "code": "@ Override public void process ( final Resource resource , final Reader reader , final Writer writer ) throws IOException { final String resourceContent = IOUtils . toString ( reader ) ; final Reader innerReader = new StringReader ( resourceContent ) ; final StringWriter innerWriter = new StringWriter ( ) ; try { super . process ( <mask> , innerReader , innerWriter ) ; writer . write ( innerWriter . toString ( ) ) ; } catch ( final Exception e ) { final String processorName = toString ( ) ; if ( isIgnoreFailingProcessor ( ) ) { LOG . debug ( \"Ignoring failed processor. Original Exception\" , e ) ; writer . write ( resourceContent ) ; // don't wrap exception unless required } else { LOG . error ( \"Failed to process the resource: {} using processor: {}. Reason: {}\" , resource , processorName , e . getMessage ( ) ) ; final String resourceUri = resource != null ? resource . getUri ( ) : null ; throw WroRuntimeException . wrap ( e , \"The processor: \" + processorName + \" faile while processing uri: \" + resourceUri ) . setResource ( resource ) ; } } finally { reader . close ( ) ; writer . close ( ) ; } }", "comment": "{"}
{"lang": "java", "code": "protected final void assertContains ( @ NotNull Object ... objects ) { isNotNull ( ) ; checkNotNull ( <mask> ) ; Collection < Object > notFound = notFoundInActual ( objects ) ; if ( notFound . isEmpty ( ) ) { return ; } throw failureIfExpectedElementsNotFound ( notFound ) ; }", "comment": "Verifies that the actual actual group of objects contains the given objects in any order ."}
{"lang": "java", "code": "protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse <mask> ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; } // Check for the parameter and use that if available String targetUrl = null ; if ( targetUrlParameter != null ) { targetUrl = request . getParameter ( targetUrlParameter ) ; if ( StringUtils . hasText ( targetUrl ) ) { logger . debug ( \"Found targetUrlParameter in request: \" + targetUrl ) ; return targetUrl ; } } if ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { targetUrl = request . getHeader ( \"Referer\" ) ; logger . debug ( \"Using Referer header: \" + targetUrl ) ; } if ( ! StringUtils . hasText ( targetUrl ) ) { targetUrl = defaultTargetUrl ; logger . debug ( \"Using default Url: \" + targetUrl ) ; } return targetUrl ; }", "comment": "Builds the target URL according to the logic defined in the main class Javadoc ."}
{"lang": "java", "code": "public boolean supportsColumnScale ( String type ) { <mask> < String > columnSet = new HashSet < String > ( ) ; columnSet . add ( \"number\" ) ; columnSet . add ( \"numeric\" ) ; columnSet . add ( \"dec\" ) ; columnSet . add ( \"decimal\" ) ; return columnSet . contains ( type . toLowerCase ( ) ) ; }", "comment": "\u54ea\u4e9b\u6570\u636e\u5e93\u5b57\u6bb5\u8fd0\u884c\u6307\u5b9a\u7cbe\u5ea6 ."}
{"lang": "java", "code": "@ VisibleForTesting ReferenceEntry < K , V > newEntry ( K key , int hash , @ NullableDecl ReferenceEntry < K , V > next ) { Segment < K , V > segment = segmentFor ( hash ) ; segment . lock ( ) ; <mask> { return segment . newEntry ( key , hash , next ) ; } finally { segment . unlock ( ) ; } }", "comment": "This method is a convenience for testing . Code should call {"}
{"lang": "java", "code": "public static String formatByteSize ( double size ) { String unit = null ; if ( size > 1.0e15 ) { unit = \"Pbytes\" ; size *= 1.0e-15 ; } else if ( size > 1.0e12 ) { unit = \"Tbytes\" ; <mask> *= 1.0e-12 ; } else if ( size > 1.0e9 ) { unit = \"Gbytes\" ; size *= 1.0e-9 ; } else if ( size > 1.0e6 ) { unit = \"Mbytes\" ; size *= 1.0e-6 ; } else if ( size > 1.0e3 ) { unit = \"Kbytes\" ; size *= 1.0e-3 ; } else { unit = \"bytes\" ; } return Format . d ( size , 4 ) + \" \" + unit ; }", "comment": "Nicely formatted representation of bytes eg turn 5 . 636E7 into"}
{"lang": "java", "code": "public final boolean isPositiveUp ( GridRecord gr ) { int type = gr . getLevelType1 ( ) ; if ( ( <mask> == 1 ) || ( type == 5 ) ) { return false ; } return true ; }", "comment": "is this a PositiveUp VerticalCoordinate ."}
{"lang": "java", "code": "public double probability ( int x ) { double ret ; if ( x < 0 || x > numberOfTrials ) { ret = 0.0 ; } else { ret = FastMath . exp ( SaddlePointExpansion . logBinomialProbability ( x , numberOfTrials , probabilityOfSuccess , 1.0 - probabilityOfSuccess ) ) ; } return <mask> ; }", "comment": "{"}
{"lang": "java", "code": "@ OnClose public void onClose ( Session userSessionParam , CloseReason reasonParam ) { this . userSession = null ; if ( this . messageHandlers != null ) { this . messageHandlers . values ( ) . forEach ( <mask> -> { handle . connectionClosed ( ) ; } ) ; } }", "comment": "Callback hook for Connection close events ."}
{"lang": "java", "code": "public void setComment ( int lineNumber , String commentString ) { ResponseString <mask> = new ResponseString ( lineNumber , commentString ) ; comments . add ( comment ) ; }", "comment": "Sets the non - error message generated in the output of the &lt ; git - add&gt ; command ."}
{"lang": "java", "code": "protected Codec . ID getSupportedCodecId ( int n ) { return Codec . <mask> . swigToEnum ( VideoJNI . DemuxerFormat_getSupportedCodecId ( swigCPtr , this , n ) ) ; }", "comment": "Get the CodecId for the n th codec supported by this container . <br > <br >"}
{"lang": "java", "code": "static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > <mask> , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ; // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here.  If you change the type make sure to update // SingletonScope as well. Provider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T > ( injector , creator ) ) ; return new InternalFactoryToProviderAdapter < T > ( scoped , source ) ; }", "comment": "Scopes an internal factory ."}
{"lang": "java", "code": "private List < FieldValidator > lookupTheListOfValidatorsAndInitializeThemWithMetaDataProperties ( List < ValidatorMetaData > validationMetaDataList ) { List < FieldValidator > validatorsList = new ArrayList <> ( ) ; /*\n         * Look up the crank validators and then apply the properties from the\n         * validationMetaData to them.\n         */ for ( ValidatorMetaData validationMetaData : validationMetaDataList ) { /* Look up the FieldValidator. */ FieldValidator validator = lookupValidatorInRegistry ( validationMetaData . getName ( ) ) ; /*\n             * Apply the properties from the validationMetaData to the\n             * validator.\n             */ applyValidationMetaDataPropertiesToValidator ( validationMetaData , validator ) ; validatorsList . <mask> ( validator ) ; } return validatorsList ; }", "comment": "Lookup the list of validators for the current field and initialize them with validation meta - data properties ."}
{"lang": "java", "code": "public Provider < T > getProvider ( ) { return new ProviderWithDependencies < T > ( ) { @ Override public T get ( ) { Provider < T > <mask> = delegate ; if ( local == null ) { throw new IllegalStateException ( \"This Provider cannot be used until the Injector has been created.\" ) ; } return local . get ( ) ; } @ Override public Set < Dependency < ? > > getDependencies ( ) { // We depend on Provider<T>, not T directly.  This is an important distinction // for dependency analysis tools that short-circuit on providers. Key < ? > providerKey = getKey ( ) . ofType ( Types . providerOf ( getKey ( ) . getTypeLiteral ( ) . getType ( ) ) ) ; return ImmutableSet . < Dependency < ? > > of ( Dependency . get ( providerKey ) ) ; } @ Override public String toString ( ) { return \"Provider<\" + getKey ( ) . getTypeLiteral ( ) + \">\" ; } } ; }", "comment": "Returns the looked up provider . The result is not valid until this lookup has been initialized which usually happens when the injector is created . The provider will throw an {"}
{"lang": "java", "code": "public static String formatHttpDate ( final long millis ) { final Date <mask> = new Date ( millis ) ; return HTTP_DATE_FORMAT . format ( date ) ; }", "comment": "Formats time to HTTP date / time format . Note that number of milliseconds is lost ."}
{"lang": "java", "code": "public File generate ( ) { QRCode qrCode = new QRCode ( ) ; File file = qrCode . encode ( profile ) ; return <mask> ; }", "comment": "\u751f\u6210\u6587\u4ef6"}
{"lang": "java", "code": "public void endMessage ( ) { delegate . endMessage ( ) ; validateMissingFields ( <mask> . peek ( ) . asGroupType ( ) . getFieldCount ( ) ) ; previousField . pop ( ) ; }", "comment": "{"}
{"lang": "java", "code": "protected boolean cleanDirectory ( <mask> directory ) { if ( directory . isDirectory ( ) && directory . listFiles ( ) . length != 0 ) { for ( File file : directory . listFiles ( ) ) { if ( file . isFile ( ) ) { file . delete ( ) ; } } } return directory . delete ( ) ; }", "comment": "Delete all file of a directory and then delete this directory"}
{"lang": "java", "code": "public void visitTypeInsn ( int opcode , String <mask> ) { if ( mv != null ) { mv . visitTypeInsn ( opcode , type ) ; } }", "comment": "Visits a type instruction . A type instruction is an instruction that takes the internal name of a class as parameter ."}
{"lang": "java", "code": "public < T > Callback < T > wrapCallbackErrors ( final String operationDescription , final Callback < T > callback , final Callback < ? > errorHandler , final Logger logger ) { return callbackBuilder ( ) . setCallback ( new Callback < T > ( ) { @ Override public void accept ( T t ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( \"{} returned {}\" , operationDescription , t ) ; } callback . resolve ( t ) ; } /* Provide some boiler plate error handling. */ } ) . setOnError ( error -> { logger . error ( String . format ( \"ERROR calling %s\" , operationDescription ) , error ) ; errorHandler . onError ( error ) ; } ) . setOnTimeout ( ( ) -> { logger . error ( \"TIMEOUT calling {}\" , operationDescription ) ; errorHandler . onTimeout ( ) ; } ) . <mask> ( ) ; }", "comment": "Used for quickly delegating one callback to another when the return types are different . This is usually the case if you want to do some transformation of the object and not just return it . <p > This allows one liners so you don t have to create a builder for this common case ."}
{"lang": "java", "code": "@ Override <mask> GeoPackageTile getTile ( int x , int y , int zoom ) { // Get the bounding box of the requested tile BoundingBox webMercatorBoundingBox = TileBoundingBoxUtils . getWebMercatorBoundingBox ( x , y , zoom ) ; GeoPackageTile tile = tileCreator . getTile ( webMercatorBoundingBox ) ; return tile ; }", "comment": "{"}
{"lang": "java", "code": "public boolean apply ( WebContext context ) { Method method = context . method ( ) ; try { Verb verb = null ; try { verb = Verb . valueOf ( context . request ( ) . getMethod ( ) ) ; } catch ( Exception e ) { throw new CannotAcceptRequestException ( HttpServletResponse . SC_METHOD_NOT_ALLOWED , \"HTTP verb [\" + context . request ( ) . getMethod ( ) + \"] is not supported\" ) ; } // Is the HTTP method allowable? if ( method . isAnnotationPresent ( Allows . class ) ) { Allows allows = method . getAnnotation ( Allows . class ) ; List < Verb > verbs = Arrays . asList ( allows . value ( ) ) ; if ( ! verbs . contains ( verb ) ) { throw new CannotAcceptRequestException ( HttpServletResponse . SC_METHOD_NOT_ALLOWED , \"Endpoint method [\" + <mask> . getDeclaringClass ( ) . getName ( ) + \"#\" + method . getName ( ) + \"] is not capable of accepting [\" + verb + \"] method\" ) ; } } // Is the MIME media type of the request acceptable? Accepts accepts = method . getAnnotation ( Accepts . class ) ; String type = context . request ( ) . getContentType ( ) ; if ( accepts != null ) { boolean acceptable = false ; for ( String value : accepts . value ( ) ) { if ( type . startsWith ( value ) ) { acceptable = true ; break ; } } if ( ! acceptable ) { throw new CannotAcceptRequestException ( HttpServletResponse . SC_UNSUPPORTED_MEDIA_TYPE , \"Endpoint method [\" + method . getDeclaringClass ( ) . getName ( ) + \"#\" + method . getName ( ) + \"] is not capable of accepting [\" + type + \"] media type\" ) ; } } Class < ? extends Request > requestType = context . configuration ( ) . requestTypes ( ) . get ( type ) ; if ( requestType == null ) { throw new CannotAcceptRequestException ( HttpServletResponse . SC_UNSUPPORTED_MEDIA_TYPE , \"Configuration [\" + context . configuration ( ) . getClass ( ) . getName ( ) + \"] does not provide a request type corresponding to [\" + type + \"] media type\" ) ; } Request request = requestType . newInstance ( ) ; request . from ( context ) ; // Parameter construction. List < Object > parameters = new ArrayList < Object > ( ) ; Annotation [ ] [ ] parameterAnnotations = method . getParameterAnnotations ( ) ; Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; for ( int i = 0 ; i < parameterTypes . length ; i ++ ) { List < Annotation > sources = new ArrayList < Annotation > ( ) ; for ( Annotation annotation : parameterAnnotations [ i ] ) { if ( annotation . annotationType ( ) . isAnnotationPresent ( Source . class ) ) { sources . add ( annotation ) ; } } parameters . add ( request . get ( parameterTypes [ i ] , sources ) ) ; } context . parameters ( parameters ) ; return true ; } catch ( CannotAcceptRequestException exception ) { logger . warn ( \"Failed to accept HTTP request\" , exception ) ; try { context . response ( ) . sendError ( exception . status ( ) ) ; return false ; } catch ( IOException e ) { throw new UncheckedException ( e ) ; } } catch ( Exception e ) { throw new UncheckedException ( e ) ; } }", "comment": "Validates HTTP request and constructs Web endpoint method parameters . This method processes the request as the following steps : <ol > <li > Checks the requested HTTP method is allowable . If the Web endpoint method is qualified by { @code @Allows } this class allows only the HTTP methods qualified in it . < / li > <li > Checks the requested MIME media type is acceptable . If the Web endpoint method is qualified by { @code @Accepts } this class accepts only the qualified MIME media types . < / li > <li > Determines { @code Request } type from the content type on HTTP request header by invoking { @code Configuration#requestType ( String ) } method with the content type . < / li > <li > Constructs Web endpoint method parameters by invoking { @code Request#get () } methods and sets them to the current HTTP request processing context . < / li > < / ol >"}
{"lang": "java", "code": "<mask> SDVariable localResponseNormalization ( SDVariable inputs , LocalResponseNormalizationConfig lrnConfig ) { return localResponseNormalization ( null , inputs , lrnConfig ) ; }", "comment": "Local response normalization operation ."}
{"lang": "java", "code": "protected static String getBits ( int b ) { Formatter s = new Formatter ( ) ; for ( int i = 31 ; i >= 0 ; i -- ) { if ( ( b & ( 1 << i ) ) != 0 ) { s . <mask> ( \"1\" ) ; } else { s . format ( \"0\" ) ; } if ( i % 8 == 0 ) { s . format ( \"|\" ) ; } } return s . toString ( ) ; }", "comment": "Get a bit string for an integer"}
{"lang": "java", "code": "@ XmlElementDecl ( namespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , name = \"adapter\" , substitutionHeadNamespace = \"http://www.tibco.com/xmlns/ApplicationManagement\" , substitutionHeadName = \"baseService\" ) public JAXBElement < Adapter > createAdapter ( Adapter value ) { return new JAXBElement < Adapter > ( _Adapter_QNAME , Adapter . class , null , <mask> ) ; }", "comment": "Create an instance of { @link JAXBElement } { @code < } { @link Adapter } { @code > }}"}
{"lang": "java", "code": "private static String retrieveUserToken ( String url , String username , String password ) { Response response = null ; try { <mask> < String , String > loginJson = new HashMap <> ( ) ; loginJson . put ( \"userName\" , username ) ; loginJson . put ( \"password\" , password ) ; response = ClientBuilder . newClient ( ) . target ( url + \"/security/public-rest/v1/authentication/login\" ) . register ( new CsrfProtectionFilter ( \"CSRF\" ) ) . request ( ) . post ( Entity . json ( loginJson ) ) ; if ( response . getStatus ( ) != Response . Status . OK . getStatusCode ( ) ) { throw new RuntimeException ( Utils . format ( \"DPM Login failed, status code '{}': {}\" , response . getStatus ( ) , response . readEntity ( String . class ) ) ) ; } } finally { if ( response != null ) { response . close ( ) ; } } return response . getHeaderString ( SSOConstants . X_USER_AUTH_TOKEN ) ; }", "comment": "Login user and retrieve authentication token ."}
{"lang": "cpp", "code": "protected function parentId()\n\t{\n\t\tswitch ( $this->position )\n\t\t{\n\t\t\tcase 'root':\n\t\t\t\treturn null;\n\n\t\t\tcase 'child':\n\t\t\t\treturn $this->target->getKey();\n\n\t\t\tdefault:\n\t\t\t\treturn $this->target->getParentId();\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (p *MediaPlaylist) SetWinSize(winsize uint) error {\n\tif winsize > p.capacity {\n\t\treturn errors.New(\"capacity must be greater than winsize or equal\")\n\t}\n\tp.winsize = winsize\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "function() {\n        var options = this.options;\n\n        if (options.hideOthers) {\n            this.secondary.each(function() {\n                var sidebar = $(this);\n\n                if (sidebar.hasClass('is-expanded')) {\n                    sidebar.toolkit('offCanvas', 'hide');\n                }\n            });\n        }\n\n        this.fireEvent('showing');\n\n        this.container.addClass('move-' + this.opposite);\n\n        this.element\n            .reveal()\n            .addClass('is-expanded')\n            .aria('expanded', true);\n\n        if (options.stopScroll) {\n            $('body').addClass('no-scroll');\n        }\n\n        this.fireEvent('shown');\n    }", "comment": ""}
{"lang": "cpp", "code": "def nextGen(self):\n        \n        self.current_gen += 1\n        self.change_gen[self.current_gen % 3] = copy.copy(self.grid)\n        grid_cp = copy.copy(self.grid)\n\n        for cell in self.grid:\n            y, x = cell\n            y1 = (y - 1) % self.y_grid\n            y2 = (y + 1) % self.y_grid\n            x1 = (x - 1) % self.x_grid\n            x2 = (x + 1) % self.x_grid\n            n = self.countNeighbours(cell)\n\n            if n < 2 or n > 3:\n                del grid_cp[cell]\n                self.addchar(y + self.y_pad, x + self.x_pad, ' ')\n            else:\n                grid_cp[cell] = min(self.grid[cell] + 1, self.color_max)\n\n            for neighbour in product([y1, y, y2], [x1, x, x2]):\n                if not self.grid.get(neighbour):\n                    if self.countNeighbours(neighbour) == 3:\n                        y, x = neighbour\n                        y = y % self.y_grid\n                        x = x % self.x_grid\n                        neighbour = y, x\n                        grid_cp[neighbour] = 1\n\n        self.grid = grid_cp", "comment": ""}
{"lang": "cpp", "code": "def key_to_kind(cls, key):\n    \n    if key.kind() == Kind.KIND_NAME:\n      return key.id()\n    else:\n      return key.parent().id()", "comment": ""}
{"lang": "cpp", "code": "private function getRecursiveTraits($class = null)\n    {\n        if (null == $class) {\n            $class = get_class($this);\n        }\n\n        $reflection = new \\ReflectionClass($class);\n        $traits = array_keys($reflection->getTraits());\n\n        foreach ($traits as $trait) {\n            $traits = array_merge($traits, $this->getRecursiveTraits($trait));\n        }\n\n        if ($parent = $reflection->getParentClass()) {\n            $traits = array_merge($traits, $this->getRecursiveTraits($parent->getName()));\n        }\n\n        return $traits;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *DescribeSnapshotCopyGrantsInput) SetMaxRecords(v int64) *DescribeSnapshotCopyGrantsInput {\n\ts.MaxRecords = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public function valid() : bool\n    {\n        if ($this->pointer >= 0 && $this->pointer < count($this->members)) {\n            return true;\n        }\n        return false;\n    }", "comment": ""}
{"lang": "cpp", "code": "public TopicProducer<Object> createTopicJsonProducer(final String topic)\n    {\n        Preconditions.checkState(connectionFactory != null, \"connection factory was never injected!\");\n        return new TopicProducer<Object>(connectionFactory, jmsConfig, topic, producerCallback);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function addSettingItems($owner, array $definitions)\n    {\n        foreach ($definitions as $code => $definition) {\n            $this->addSettingItem($owner, $code, $definition);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def update_brand(self) -> None:\n        \"\"\"\"\"\"\n        self.update(path=URL_GET + GROUP.format(group=BRAND))", "comment": ""}
{"lang": "cpp", "code": "protected function getControlKey($disconnect = false)\n    {\n        $key = '';\n\n        if ($disconnect) {\n            return \"*immed\";\n        }\n\n        /*\n        if(?) *justproc\n        if(?) *debug\n        if(?) *debugproc\n        if(?) *nostart\n        if(?) *rpt*/\n\n        // Idle timeout supported by XMLSERVICE 1.62\n        // setting idle for *sbmjob protects the time taken by program calls\n        // Do that with *idle(30/kill) or whatever the time in seconds.\n        if (trim($this->getOption('idleTimeout')) != '') {\n            $idleTimeout = $this->getOption('idleTimeout');\n            $key .= \" *idle($idleTimeout/kill)\"; // ends idle only, but could end MSGW with *call(30/kill)\n        }\n\n        // if cdata requested, request it. XMLSERVICE will then wrap all output in CDATA tags.\n        if ($this->getOption('cdata')) {\n            $key .= \" *cdata\";\n        }\n\n        /* stateless calls in stored procedure job\n         *\n         * Add *here, which will run everything inside the current PHP/transport job\n         * without spawning or submitting a separate XTOOLKIT job.\n         */\n        if ($this->isStateless()) {\n            $key .= \" *here\";\n        } else {\n            // not stateless, so could make sense to supply *sbmjob parameters for spawning a separate job.\n            if (trim($this->getOption('sbmjobParams')) != '') {\n               $sbmjobParams = $this->getOption('sbmjobParams');\n               $key .= \" *sbmjob($sbmjobParams)\";\n            }\n        }\n\n        // if internal XMLSERVICE tracing, into database table XMLSERVLOG/LOG, is desired\n        if ($this->getOption('trace')) {\n            $key .= \" *log\";\n        }\n\n        // directive not to run any program, but to parse XML and return parsed output, including dim/dou.\n        if ($this->getOption('parseOnly')) {\n            $key .= \" *test\";\n\n            // add a debugging level (1-9) to the parse, to make *test(n) where n is the debugging level\n            if ($parseDebugLevel = $this->getOption('parseDebugLevel')) {\n                $key .= \"($parseDebugLevel)\";\n            }\n        }\n\n        // return XMLSERVICE version/license information (no XML calls)\n        if ($this->getOption('license')) {\n            $key .= \" *license\";\n        }\n\n        // check proc call speed (no XML calls)\n        if ($this->getOption('transport')) {\n            $key .= \" *justproc\";\n        }\n\n        // get performance of last call data (no XML calls)\n        if ($this->getOption('performance')) {\n            $key .= \" *rpt\";\n        }\n\n        // *fly is number of ticks of each operation. *nofly is the default\n        if ($this->getOption('timeReport')) {\n            $key .= \" *fly\";\n        }\n\n        // PASE CCSID for <sh> type of functions such as WRKACTJOB ('system' command in PASE)\n        if ($paseCcsid = $this->getOption('paseCcsid')) {\n            $key .= \" *pase($paseCcsid)\";\n        }\n\n        // allow custom control keys\n        if ($this->getOption('customControl')) {\n            $key .= \" {$this->getOption('customControl')}\";\n        }\n\n        return trim($key); // trim off any extra blanks on beginning or end\n    }", "comment": ""}
{"lang": "cpp", "code": "def check_symbol_to_proc\n      return unless method_call.block_argument_names.count == 1\n      return if method_call.block_body.nil?\n      return unless method_call.block_body.sexp_type == :call\n      return if method_call.arguments.count > 0\n\n      body_method_call = MethodCall.new(method_call.block_body)\n\n      return unless body_method_call.arguments.count.zero?\n      return if body_method_call.has_block?\n      return unless body_method_call.receiver.name == method_call.block_argument_names.first\n\n      add_offense(:block_vs_symbol_to_proc)\n    end", "comment": ""}
{"lang": "cpp", "code": "public synchronized static <D extends Dao<T, ?>, T> D lookupDao(ConnectionSource connectionSource,\n\t\t\tDatabaseTableConfig<T> tableConfig) {\n\t\tif (connectionSource == null) {\n\t\t\tthrow new IllegalArgumentException(\"connectionSource argument cannot be null\");\n\t\t}\n\t\tTableConfigConnectionSource key = new TableConfigConnectionSource(connectionSource, tableConfig);\n\t\tDao<?, ?> dao = lookupDao(key);\n\t\tif (dao == null) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tD castDao = (D) dao;\n\t\t\treturn castDao;\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (c Caser) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {\n\tnSrc = len(src) // Always read all the bytes of src\n\tresult := c.Bytes(src)\n\tif len(result) > len(dst) {\n\t\terr = transform.ErrShortDst\n\t}\n\tnDst = copy(dst, result)\n\treturn\n}", "comment": ""}
{"lang": "cpp", "code": "def create_or_update(cls, build):\n        \n\n        test_summary = build.test_summary\n        metrics_summary = MetricsSummary(build)\n        now = timezone.now()\n        test_runs_total = build.test_runs.count()\n        test_runs_completed = build.test_runs.filter(completed=True).count()\n        test_runs_incomplete = build.test_runs.filter(completed=False).count()\n        regressions = None\n        fixes = None\n\n        previous_build = Build.objects.filter(\n            status__finished=True,\n            datetime__lt=build.datetime,\n            project=build.project,\n        ).order_by('datetime').last()\n        if previous_build is not None:\n            comparison = TestComparison(previous_build, build)\n            if comparison.regressions:\n                regressions = yaml.dump(comparison.regressions)\n            if comparison.fixes:\n                fixes = yaml.dump(comparison.fixes)\n\n        finished, _ = build.finished\n        data = {\n            'tests_pass': test_summary.tests_pass,\n            'tests_fail': test_summary.tests_fail,\n            'tests_xfail': test_summary.tests_xfail,\n            'tests_skip': test_summary.tests_skip,\n            'metrics_summary': metrics_summary.value,\n            'has_metrics': metrics_summary.has_metrics,\n            'last_updated': now,\n            'finished': finished,\n            'test_runs_total': test_runs_total,\n            'test_runs_completed': test_runs_completed,\n            'test_runs_incomplete': test_runs_incomplete,\n            'regressions': regressions,\n            'fixes': fixes\n        }\n\n        status, created = cls.objects.get_or_create(build=build, defaults=data)\n        if not created and test_summary.tests_total >= status.tests_total:\n            # XXX the test above for the new total number of tests prevents\n            # results that arrived earlier, but are only being processed now,\n            # from overwriting a ProjectStatus created by results that arrived\n            # later but were already processed.\n            status.tests_pass = test_summary.tests_pass\n            status.tests_fail = test_summary.tests_fail\n            status.tests_xfail = test_summary.tests_xfail\n            status.tests_skip = test_summary.tests_skip\n            status.metrics_summary = metrics_summary.value\n            status.has_metrics = metrics_summary.has_metrics\n            status.last_updated = now\n            finished, _ = build.finished\n            status.finished = finished\n            status.build = build\n            status.test_runs_total = test_runs_total\n            status.test_runs_completed = test_runs_completed\n            status.test_runs_incomplete = test_runs_incomplete\n            status.regressions = regressions\n            status.fixes = fixes\n            status.save()\n        return status", "comment": ""}
{"lang": "cpp", "code": "def p44(msg):\n    \n    d = hex2bin(data(msg))\n\n    if d[34] == '0':\n        return None\n\n    p = bin2int(d[35:46])    # hPa\n\n    return p", "comment": ""}
{"lang": "cpp", "code": "def trace(fout=None, format=None, byteorder=sys.byteorder, nanosecond=False):\n    \n    str_check(fout or '', format or '')\n    return TraceFlow(fout=fout, format=format, byteorder=byteorder, nanosecond=nanosecond)", "comment": ""}
{"lang": "cpp", "code": "public void setUrl(final String url) {\n\t\tMenuItemModel model = getOrCreateComponentModel();\n\t\tmodel.url = url;\n\t\tmodel.action = null;\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (s *Ec2Config) SetSecurityGroupArns(v []*string) *Ec2Config {\n\ts.SecurityGroupArns = v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "static Field lookupField(Class<?> javaClass, String fieldName) throws NoSuchFieldException {\n        if (System.getSecurityManager() != null) {\n            try {\n                return AccessController.doPrivileged(new FieldLookupAction(javaClass, fieldName));\n            } catch (PrivilegedActionException e) {\n                if (e.getCause() instanceof NoSuchFieldException) {\n                    throw (NoSuchFieldException) e.getCause();\n                }\n                throw new WeldException(e.getCause());\n            }\n        } else {\n            return FieldLookupAction.lookupField(javaClass, fieldName);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function migrateRetryJobs($queue)\n    {\n        $luaScript = <<<LUA\n-- Get all of the jobs with an expired \"score\"...\nlocal val = redis.call('zrangebyscore', KEYS[1], '-inf', ARGV[1])\n\n-- If we have values in the array, we will remove them from the first queue\n-- and add them onto the destination queue in chunks of 100, which moves\n-- all of the appropriate jobs onto the destination queue very safely.\nif(next(val) ~= nil) then\n    redis.call('zremrangebyrank', KEYS[1], 0, #val - 1)\n\n    for i = 1, #val, 100 do\n        redis.call('rpush', KEYS[2], unpack(val, i, math.min(i+99, #val)))\n    end\nend\n\nreturn val\nLUA;\n\n        return $this->client->eval(\n            $luaScript,\n            2,\n            $this->getRetryZsetNameWithPrefix($queue),\n            $this->getQueueNameWithPrefix($queue),\n            time()\n        );\n    }", "comment": ""}
{"lang": "cpp", "code": "def jsonify_payload(self):\n        \n        # Assume already json serialized\n        if isinstance(self.payload, string_types):\n            return self.payload\n        return json.dumps(self.payload, cls=StandardJSONEncoder)", "comment": ""}
{"lang": "cpp", "code": "public static function trace($trace = null, $addObject = false)\r\n    {\r\n        if (!self::isDebug()) {\r\n            return false;\r\n        }\r\n\r\n        $_this = self::i();\r\n\r\n        $trace = $trace ? $trace : debug_backtrace($addObject);\r\n        unset($trace[0]);\r\n\r\n        $result = $_this->convertTrace($trace, $addObject);\r\n\r\n        return $_this->dump($result, '! backtrace !');\r\n    }", "comment": ""}
{"lang": "cpp", "code": "@Api\n\tpublic void getValue(String name, ShortAttribute attribute) {\n\t\tattribute.setValue(toShort(formWidget.getValue(name)));\n\t}", "comment": ""}
{"lang": "cpp", "code": "public void submit(String name, Map<String, String> additionalMetadata) {\n    if(this.metricContext.isPresent()) {\n      Map<String, String> finalMetadata = Maps.newHashMap(this.metadata);\n      if(!additionalMetadata.isEmpty()) {\n        finalMetadata.putAll(additionalMetadata);\n      }\n\n      // Timestamp is set by metric context.\n      this.metricContext.get().submitEvent(new GobblinTrackingEvent(0l, this.namespace, name, finalMetadata));\n    }\n  }", "comment": ""}
{"lang": "cpp", "code": "func FallbackAddr(fallbackAddr btcutil.Address) func(*Invoice) {\n\treturn func(i *Invoice) {\n\t\ti.FallbackAddr = fallbackAddr\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "def get_manager_cmd(self):\n        \"\"\"\"\"\"\n        cmd = os.path.abspath(os.path.join(os.path.dirname(__file__), \"server\", \"notebook_daemon.py\"))\n        assert os.path.exists(cmd)\n        return cmd", "comment": ""}
{"lang": "cpp", "code": "func (s *LabelingJobStoppingConditions) SetMaxHumanLabeledObjectCount(v int64) *LabelingJobStoppingConditions {\n\ts.MaxHumanLabeledObjectCount = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public FeatureInfoWithActions getFeatureInfoWidgetWithActions(MapPresenter mapPresenter) {\n\t\tFeatureInfoWithActions widgetWithActions = new FeatureInfoWithActions();\n\t\twidgetWithActions.addHasFeature(new ZoomToObjectAction(mapPresenter));\n\n\t\treturn widgetWithActions;\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (s *TaskFailedEventDetails) SetError(v string) *TaskFailedEventDetails {\n\ts.Error = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "def monitor(self):\n        \n        if self._monitor is None:\n            from twilio.rest.monitor import Monitor\n            self._monitor = Monitor(self)\n        return self._monitor", "comment": ""}
{"lang": "cpp", "code": "func (p *Engine) ExecuteRaw(src string, wr io.Writer, binding interface{}) (err error) {\n\tset := pongo2.NewSet(\"\", pongo2.DefaultLoader)\n\tset.Globals = getPongoContext(p.Config.Globals)\n\ttmpl, err := set.FromString(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn tmpl.ExecuteWriter(getPongoContext(binding), wr)\n}", "comment": ""}
{"lang": "cpp", "code": "public function getInArray($name, array $array)\n    {\n        $value = $this->get($name);\n        return in_array($value, $array) ? $value : $array[key($array)];\n    }", "comment": ""}
{"lang": "cpp", "code": "private void setJCRProperties(NodeImpl parent, Properties props) throws Exception\n   {\n      if (!parent.isNodeType(\"dc:elementSet\"))\n      {\n         parent.addMixin(\"dc:elementSet\");\n      }\n\n      ValueFactory vFactory = parent.getSession().getValueFactory();\n      LocationFactory lFactory = parent.getSession().getLocationFactory();\n\n      for (Entry entry : props.entrySet())\n      {\n         QName qname = (QName)entry.getKey();\n         JCRName jcrName = lFactory.createJCRName(new InternalQName(qname.getNamespace(), qname.getName()));\n\n         PropertyDefinitionData definition =\n            parent\n               .getSession()\n               .getWorkspace()\n               .getNodeTypesHolder()\n               .getPropertyDefinitions(jcrName.getInternalName(), ((NodeData)parent.getData()).getPrimaryTypeName(),\n                  ((NodeData)parent.getData()).getMixinTypeNames()).getAnyDefinition();\n\n         if (definition != null)\n         {\n            if (definition.isMultiple())\n            {\n               Value[] values = {createValue(entry.getValue(), vFactory)};\n               parent.setProperty(jcrName.getAsString(), values);\n            }\n            else\n            {\n               Value value = createValue(entry.getValue(), vFactory);\n               parent.setProperty(jcrName.getAsString(), value);\n            }\n         }\n      }\n   }", "comment": ""}
{"lang": "cpp", "code": "protected function getGroupedProfiles()\n    {\n        $this->analytics->requireAuthentication();\n\n        $groupedProfiles = [];\n        $accounts = $this->analytics->management_accounts->listManagementAccounts();\n        foreach ($accounts as $account) {\n            $groupedProfiles[$account->getId()]['label'] = $account->getName();\n            $groupedProfiles[$account->getId()]['items'] = [];\n        }\n        $webproperties = $this->analytics->management_webproperties->listManagementWebproperties('~all');\n        $webpropertiesById = [];\n        foreach ($webproperties as $webproperty) {\n            $webpropertiesById[$webproperty->getId()] = $webproperty;\n        }\n        $profiles = $this->analytics->management_profiles->listManagementProfiles('~all', '~all');\n        foreach ($profiles as $profile) {\n            if (isset($webpropertiesById[$profile->getWebpropertyId()])) {\n                $webproperty = $webpropertiesById[$profile->getWebpropertyId()];\n                $groupedProfiles[$profile->getAccountId()]['items'][$profile->getId()] = ['label' => $webproperty->getName() . ' > ' . $profile->getName(), 'value' => $profile->getId()];\n            }\n        }\n\n        return $groupedProfiles;\n    }", "comment": ""}
{"lang": "cpp", "code": "func addValueToMap(keys []string, value interface{}, target map[string]interface{}) {\n\tnext := target\n\n\tfor i := range keys {\n\t\t// If we are on last key set or overwrite the val.\n\t\tif i == len(keys)-1 {\n\t\t\tnext[keys[i]] = value\n\t\t\tbreak\n\t\t}\n\n\t\tif iface, ok := next[keys[i]]; ok {\n\t\t\tswitch typed := iface.(type) {\n\t\t\tcase map[string]interface{}:\n\t\t\t\t// If we already had a map inside, keep\n\t\t\t\t// stepping through.\n\t\t\t\tnext = typed\n\t\t\tdefault:\n\t\t\t\t// If we didn't, then overwrite value\n\t\t\t\t// with a map and iterate with that.\n\t\t\t\tm := map[string]interface{}{}\n\t\t\t\tnext[keys[i]] = m\n\t\t\t\tnext = m\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\n\t\t// Otherwise, it wasn't present, so make it and step\n\t\t// into.\n\t\tm := map[string]interface{}{}\n\t\tnext[keys[i]] = m\n\t\tnext = m\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "func (s *Service) Run() {\n\tflag.Usage = s.Usage\n\tflag.Parse()\n\targs := flag.Args()\n\tif len(args) == 0 && s.defaultCommand != \"\" {\n\t\targs = append([]string{s.defaultCommand}, args...)\n\t}\n\tif len(args) == 0 {\n\t\ts.Usage()\n\t\tBootPrintln()\n\t\treturn\n\t}\n\terr := s.RunCommand(args[0], args[1:]...)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "def _put_one(self, item):\n        ''' \n        '''\n        # prepare values\n        values = []\n        for k, v in item.items():\n            if k == '_id':\n                continue\n            if 'dblite_serializer' in item.fields[k]:\n                serializer = item.fields[k]['dblite_serializer']\n                v = serializer.dumps(v)\n                if v is not None:\n                    v = sqlite3.Binary(buffer(v))\n            values.append(v)\n\n        # check if Item is new => update it\n        if '_id' in item:\n            fieldnames = ','.join(['%s=?' % f for f in item if f != '_id'])\n            values.append(item['_id'])\n            SQL = 'UPDATE %s SET %s WHERE rowid=?;' % (self._table, fieldnames)\n        # new Item\n        else:\n            fieldnames = ','.join([f for f in item if f != '_id'])\n            fieldnames_template = ','.join(['?' for f in item if f != '_id'])\n            SQL = 'INSERT INTO %s (%s) VALUES (%s);' % (self._table, fieldnames, fieldnames_template)\n\n        try:\n            self._cursor.execute(SQL, values)\n        except sqlite3.OperationalError, err:\n            raise RuntimeError('Item put() error, %s, SQL: %s, values: %s' % (err, SQL, values) )\n        except sqlite3.IntegrityError:\n            raise DuplicateItem('Duplicate item, %s' % item)\n        self._do_autocommit()", "comment": ""}
{"lang": "cpp", "code": "function() {\n        return {\n            theta: Math.atan2(this.z, this.x),\n            phi: Math.asin(this.y / this.length())\n        };\n    }", "comment": ""}
{"lang": "cpp", "code": "public static function linspace($start, $stop, int $num): \\CArray\n    {\n        return parent::linspace($start, $stop, $num);\n    }", "comment": ""}
{"lang": "cpp", "code": "func Digests(key Trits, spongeFunc ...SpongeFunction) (Trits, error) {\n\tvar err error\n\tfragments := int(math.Floor(float64(len(key)) / KeyFragmentLength))\n\tdigests := make(Trits, fragments*HashTrinarySize)\n\tbuf := make(Trits, HashTrinarySize)\n\n\th := GetSpongeFunc(spongeFunc, kerl.NewKerl)\n\tdefer h.Reset()\n\n\t// iterate through each key fragment\n\tfor i := 0; i < fragments; i++ {\n\t\tkeyFragment := key[i*KeyFragmentLength : (i+1)*KeyFragmentLength]\n\n\t\t// each fragment consists of 27 segments\n\t\tfor j := 0; j < KeySegmentsPerFragment; j++ {\n\t\t\tcopy(buf, keyFragment[j*HashTrinarySize:(j+1)*HashTrinarySize])\n\n\t\t\t// hash each segment 26 times\n\t\t\tfor k := 0; k < KeySegmentHashRounds; k++ {\n\t\t\t\th.Absorb(buf)\n\t\t\t\tbuf, err = h.Squeeze(HashTrinarySize)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\th.Reset()\n\t\t\t}\n\n\t\t\tcopy(keyFragment[j*HashTrinarySize:], buf)\n\t\t}\n\n\t\t// hash the key fragment (which now consists of hashed segments)\n\t\tif err := h.Absorb(keyFragment); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tbuf, err := h.Squeeze(HashTrinarySize)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcopy(digests[i*HashTrinarySize:], buf)\n\n\t\th.Reset()\n\t}\n\n\treturn digests, nil\n}", "comment": ""}
{"lang": "cpp", "code": "def create_hparams_from_json(json_path, hparams=None):\n  \"\"\"\"\"\"\n  tf.logging.info(\"Loading hparams from existing json %s\" % json_path)\n  with tf.gfile.Open(json_path, \"r\") as f:\n    hparams_values = json.load(f)\n    # Prevent certain keys from overwriting the passed-in hparams.\n    # TODO(trandustin): Remove this hack after registries are available to avoid\n    # saving them as functions.\n    hparams_values.pop(\"bottom\", None)\n    hparams_values.pop(\"loss\", None)\n    hparams_values.pop(\"name\", None)\n    hparams_values.pop(\"top\", None)\n    hparams_values.pop(\"weights_fn\", None)\n    new_hparams = hparam.HParams(**hparams_values)\n    # Some keys are in new_hparams but not hparams, so we need to be more\n    #   careful than simply using parse_json() from HParams\n    if hparams:  # hparams specified, so update values from json\n      for key in sorted(new_hparams.values().keys()):\n        if hasattr(hparams, key):  # Overlapped keys\n          value = getattr(hparams, key)\n          new_value = getattr(new_hparams, key)\n          if value != new_value:  # Different values\n            tf.logging.info(\"Overwrite key %s: %s -> %s\" % (\n                key, value, new_value))\n            setattr(hparams, key, new_value)\n    else:\n      hparams = new_hparams\n\n  return hparams", "comment": ""}
{"lang": "cpp", "code": "public function sortBy( \\Closure $callback, bool $save_keys = true )\n\t{\n\t\t$items = $this->items;\n\t\t$save_keys ? uasort($items, $callback) : usort($items, $callback);\n\t\treturn new static($items);\n\t}", "comment": ""}
{"lang": "cpp", "code": "def upload(self, tool: Tool) -> bool:\n        \n        return self.__installation.build.upload(tool.image)", "comment": ""}
{"lang": "cpp", "code": "public function checks($name, $arg = null) {\n        if (empty($arg)) {\n            $this->checks[] = $name;\n        } else {\n            $this->checks[$name] = $arg;\n        }\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "List<JCClassDecl> listClasses(List<JCCompilationUnit> trees) {\n        List<JCClassDecl> result = new ArrayList<>();\n        for (JCCompilationUnit t : trees) {\n            for (JCTree def : t.defs) {\n                if (def.hasTag(JCTree.Tag.CLASSDEF))\n                    result.add((JCClassDecl)def);\n            }\n        }\n        return result;\n    }", "comment": ""}
{"lang": "cpp", "code": "@Override\n\tpublic void configure(Configuration parameters) {\n\n\t\t// enforce sequential configuration() calls\n\t\tsynchronized (CONFIGURE_MUTEX) {\n\t\t\tif (mapreduceInputFormat instanceof Configurable) {\n\t\t\t\t((Configurable) mapreduceInputFormat).setConf(configuration);\n\t\t\t}\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "public static String getParamFromState(String state, String paramName) {\n\n        String prefix = PARAM_SEPARATOR + paramName + PARAM_ASSIGN;\n        if (state.contains(prefix)) {\n            String result = state.substring(state.indexOf(prefix) + prefix.length());\n            if (result.contains(PARAM_SEPARATOR)) {\n                result = result.substring(0, result.indexOf(PARAM_SEPARATOR));\n            }\n            return CmsEncoder.decode(result, CmsEncoder.ENCODING_UTF_8);\n        }\n        return null;\n    }", "comment": ""}
{"lang": "cpp", "code": "func intIf(cnd bool, a, b int) int {\n\tif cnd {\n\t\treturn a\n\t}\n\treturn b\n}", "comment": ""}
{"lang": "cpp", "code": "@Nonnull\n  public static EbInterfaceWriter <Ebi41InvoiceType> ebInterface41 ()\n  {\n    final EbInterfaceWriter <Ebi41InvoiceType> ret = EbInterfaceWriter.create (Ebi41InvoiceType.class);\n    ret.setNamespaceContext (EbInterface41NamespaceContext.getInstance ());\n    return ret;\n  }", "comment": ""}
{"lang": "cpp", "code": "func (s *GetObjectLegalHoldInput) SetKey(v string) *GetObjectLegalHoldInput {\n\ts.Key = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "func Range(str string, params ...string) bool {\n\tif len(params) == 2 {\n\t\tvalue, _ := ToFloat(str)\n\t\tmin, _ := ToFloat(params[0])\n\t\tmax, _ := ToFloat(params[1])\n\t\treturn InRange(value, min, max)\n\t}\n\n\treturn false\n}", "comment": ""}
{"lang": "cpp", "code": "def add_arguments(self, parser):\n        \"\"\"\"\"\"\n        parser.add_argument(self._source_param, **self._source_kwargs)\n        parser.add_argument('--base', '-b', action='store',\n            help=   'Supply the base currency as code or a settings variable name. '\n                    'The default is taken from settings CURRENCIES_BASE or SHOP_DEFAULT_CURRENCY, '\n                    'or the db, otherwise USD')", "comment": ""}
{"lang": "cpp", "code": "public function server(string $index = '', $xss_clean = false)\n    {\n        return $this->fetchFromArray($_SERVER, $index, $xss_clean);\n    }", "comment": ""}
{"lang": "cpp", "code": "@Override\n    public Server choose(Object key) {\n        ILoadBalancer lb = getLoadBalancer();\n        Optional<Server> server = getPredicate().chooseRoundRobinAfterFiltering(lb.getAllServers(), key);\n        if (server.isPresent()) {\n            return server.get();\n        } else {\n            return null;\n        }       \n    }", "comment": ""}
{"lang": "cpp", "code": "public function validateGt($attribute, $value, $parameters)\n    {\n        $this->requireParameterCount(1, $parameters, 'gt');\n\n        $comparedToValue = $this->getValue($parameters[0]);\n\n        $this->shouldBeNumeric($attribute, 'Gt');\n\n        if (is_null($comparedToValue) && (is_numeric($value) && is_numeric($parameters[0]))) {\n            return $this->getSize($attribute, $value) > $parameters[0];\n        }\n\n        if (! $this->isSameType($value, $comparedToValue)) {\n            return false;\n        }\n\n        return $this->getSize($attribute, $value) > $this->getSize($attribute, $comparedToValue);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (r *Rets) SetErrorCode() string {\n\tconst code = `if r0 != 0 {\n\t\t%s = %sErrno(r0)\n\t}`\n\tif r.Name == \"\" && !r.ReturnsError {\n\t\treturn \"\"\n\t}\n\tif r.Name == \"\" {\n\t\treturn r.useLongHandleErrorCode(\"r1\")\n\t}\n\tif r.Type == \"error\" {\n\t\treturn fmt.Sprintf(code, r.Name, syscalldot())\n\t}\n\ts := \"\"\n\tswitch {\n\tcase r.Type[0] == '*':\n\t\ts = fmt.Sprintf(\"%s = (%s)(unsafe.Pointer(r0))\", r.Name, r.Type)\n\tcase r.Type == \"bool\":\n\t\ts = fmt.Sprintf(\"%s = r0 != 0\", r.Name)\n\tdefault:\n\t\ts = fmt.Sprintf(\"%s = %s(r0)\", r.Name, r.Type)\n\t}\n\tif !r.ReturnsError {\n\t\treturn s\n\t}\n\treturn s + \"\\n\\t\" + r.useLongHandleErrorCode(r.Name)\n}", "comment": ""}
{"lang": "cpp", "code": "func (co *Coordinator) StartPlugins() {\n\t// Launch routers\n\tfor _, router := range co.routers {\n\t\tlogrus.Debug(\"Starting \", reflect.TypeOf(router))\n\t\tif err := router.Start(); err != nil {\n\t\t\tlogrus.WithError(err).Errorf(\"Failed to start router of type '%s'\", reflect.TypeOf(router))\n\t\t}\n\t}\n\n\t// Launch producers\n\tco.state = coordinatorStateStartProducers\n\tfor _, producer := range co.producers {\n\t\tproducer := producer\n\t\tgo tgo.WithRecoverShutdown(func() {\n\t\t\tlogrus.Debug(\"Starting \", reflect.TypeOf(producer))\n\t\t\tproducer.Produce(co.producerWorker)\n\t\t})\n\t}\n\n\t// Set final log target and purge the intermediate buffer\n\tif core.StreamRegistry.IsStreamRegistered(core.LogInternalStreamID) {\n\t\t// The _GOLLUM_ stream has listeners, so use LogConsumer to write to it\n\t\tif *flagLogColors == \"always\" {\n\t\t\tlogrus.SetFormatter(logger.NewConsoleFormatter())\n\t\t}\n\t\tlogrusHookBuffer.SetTargetHook(co.logConsumer)\n\t\tlogrusHookBuffer.Purge()\n\n\t} else {\n\t\tlogrusHookBuffer.SetTargetWriter(logger.FallbackLogDevice)\n\t\tlogrusHookBuffer.Purge()\n\t}\n\n\t// Launch consumers\n\tco.state = coordinatorStateStartConsumers\n\tfor _, consumer := range co.consumers {\n\t\tconsumer := consumer\n\t\tgo tgo.WithRecoverShutdown(func() {\n\t\t\tlogrus.Debug(\"Starting \", reflect.TypeOf(consumer))\n\t\t\tconsumer.Consume(co.consumerWorker)\n\t\t})\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "def consumer(self, conn):\n        \"\"\"\"\"\"\n        return Consumer(\n            connection=conn,\n            queue=self.queue.name,\n            exchange=self.exchange.name,\n            exchange_type=self.exchange.type,\n            durable=self.exchange.durable,\n            auto_delete=self.exchange.auto_delete,\n            routing_key=self.routing_key,\n            no_ack=self.no_ack,\n        )", "comment": ""}
{"lang": "cpp", "code": "def _get_qgen_var(self, generators, base_mva):\n        \n        Qg = array([g.q / base_mva for g in generators])\n\n        Qmin = array([g.q_min / base_mva for g in generators])\n        Qmax = array([g.q_max / base_mva for g in generators])\n\n        return Variable(\"Qg\", len(generators), Qg, Qmin, Qmax)", "comment": ""}
{"lang": "cpp", "code": "public function getAssociationLabels(RepositoryInterface $table) : array\n    {\n        /** @var \\Cake\\ORM\\Table */\n        $table = $table;\n\n        $result = [];\n        foreach ($table->associations() as $association) {\n            if (!in_array($association->type(), $this->searchableAssociations)) {\n                continue;\n            }\n\n            $result[$association->getName()] = Inflector::humanize(current((array)$association->getForeignKey()));\n        }\n\n        return $result;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function get_comments($page = '') {\n        global $DB, $CFG, $USER, $OUTPUT;\n        if (!$this->can_view()) {\n            return false;\n        }\n        if (!is_numeric($page)) {\n            $page = 0;\n        }\n        $params = array();\n        $perpage = (!empty($CFG->commentsperpage))?$CFG->commentsperpage:15;\n        $start = $page * $perpage;\n        $ufields = user_picture::fields('u');\n\n        list($componentwhere, $component) = $this->get_component_select_sql('c');\n        if ($component) {\n            $params['component'] = $component;\n        }\n\n        $sql = \"SELECT $ufields, c.id AS cid, c.content AS ccontent, c.format AS cformat, c.timecreated AS ctimecreated\n                  FROM {comments} c\n                  JOIN {user} u ON u.id = c.userid\n                 WHERE c.contextid = :contextid AND\n                       c.commentarea = :commentarea AND\n                       c.itemid = :itemid AND\n                       $componentwhere\n              ORDER BY c.timecreated DESC\";\n        $params['contextid'] = $this->contextid;\n        $params['commentarea'] = $this->commentarea;\n        $params['itemid'] = $this->itemid;\n\n        $comments = array();\n        $formatoptions = array('overflowdiv' => true, 'blanktarget' => true);\n        $rs = $DB->get_recordset_sql($sql, $params, $start, $perpage);\n        foreach ($rs as $u) {\n            $c = new stdClass();\n            $c->id          = $u->cid;\n            $c->content     = $u->ccontent;\n            $c->format      = $u->cformat;\n            $c->timecreated = $u->ctimecreated;\n            $c->strftimeformat = get_string('strftimerecentfull', 'langconfig');\n            $url = new moodle_url('/user/view.php', array('id'=>$u->id, 'course'=>$this->courseid));\n            $c->profileurl = $url->out(false); // URL should not be escaped just yet.\n            $c->fullname = fullname($u);\n            $c->time = userdate($c->timecreated, $c->strftimeformat);\n            $c->content = format_text($c->content, $c->format, $formatoptions);\n            $c->avatar = $OUTPUT->user_picture($u, array('size'=>18));\n            $c->userid = $u->id;\n\n            $candelete = $this->can_delete($c->id);\n            if (($USER->id == $u->id) || !empty($candelete)) {\n                $c->delete = true;\n            }\n            $comments[] = $c;\n        }\n        $rs->close();\n\n        if (!empty($this->plugintype)) {\n            // moodle module will filter comments\n            $comments = plugin_callback($this->plugintype, $this->pluginname, 'comment', 'display', array($comments, $this->comment_param), $comments);\n        }\n\n        return $comments;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (ne *ne_IN) WeekdayWide(weekday time.Weekday) string {\n\treturn ne.daysWide[weekday]\n}", "comment": ""}
{"lang": "cpp", "code": "function relatedObjects()\n    {\n        $return = false;\n        if ( $this->ObjectAttributeID )\n        {\n            $return = array();\n\n            // Fetch words\n            $db = eZDB::instance();\n\n            $wordArray = $db->arrayQuery( \"SELECT * FROM ezkeyword_attribute_link\n                                           WHERE objectattribute_id='\" . $this->ObjectAttributeID .\"' \" );\n\n            $keywordIDArray = array();\n            // Fetch the objects which have one of these words\n            foreach ( $wordArray as $word )\n            {\n                $keywordIDArray[] = $word['keyword_id'];\n            }\n\n            $keywordCondition = $db->generateSQLINStatement( $keywordIDArray, 'keyword_id' );\n\n            if ( count( $keywordIDArray ) > 0 )\n            {\n                $objectArray = $db->arrayQuery( \"SELECT DISTINCT ezcontentobject_attribute.contentobject_id FROM ezkeyword_attribute_link, ezcontentobject_attribute\n                                                  WHERE $keywordCondition AND\n                                                        ezcontentobject_attribute.id = ezkeyword_attribute_link.objectattribute_id\n                                                        AND  objectattribute_id <> '\" . $this->ObjectAttributeID .\"' \" );\n\n                $objectIDArray = array();\n                foreach ( $objectArray as $object )\n                {\n                    $objectIDArray[] = $object['contentobject_id'];\n                }\n\n                if ( count( $objectIDArray ) > 0 )\n                {\n                    $aNodes = eZContentObjectTreeNode::findMainNodeArray( $objectIDArray );\n\n                    foreach ( $aNodes as $key => $node )\n                    {\n                        $theObject = $node->object();\n                        if ( $theObject->canRead() )\n                        {\n                            $return[] = $node;\n                        }\n                    }\n                }\n            }\n        }\n        return $return;\n    }", "comment": ""}
{"lang": "cpp", "code": "public static Object extract(final DeviceAttribute da) throws DevFailed {\n\tif (da == null) {\n\t\tthrow DevFailedUtils.newDevFailed(ERROR_MSG_DA);\n\t}\n\treturn InsertExtractFactory.getAttributeExtractor(da.getType()).extract(da);\n    }", "comment": ""}
{"lang": "cpp", "code": "public OrderItem withPromotionIds(String... values) {\r\n        List<String> list = getPromotionIds();\r\n        for (String value : values) {\r\n            list.add(value);\r\n        }\r\n        return this;\r\n    }", "comment": ""}
{"lang": "cpp", "code": "def get_html_content(self):\n        \n\n        # Extract full element node content (including subelements)\n        html_content = ''\n        if hasattr(self, 'xml_element'):\n            xml = self.xml_element\n            content_list = [\"\" if xml.text is None else xml.text]\n\n            def to_string(xml):\n                if isinstance(xml, _Comment):\n                    return str(xml)\n                else:\n                    return ElementTree.tostring(xml).decode('utf-8')\n\n            content_list += [to_string(e) for e in xml.getchildren()]\n\n            full_xml_content = \"\".join(content_list)\n\n            # Parse tags to generate HTML valid content\n            first_regex = r'html:'\n            second_regex = r' xmlns:html=([\"\\'])(?:(?=(\\\\?))\\2.)*?\\1'\n            html_content = re.sub(first_regex, '',\n                                  re.sub(second_regex, '', full_xml_content))\n\n        return html_content", "comment": ""}
{"lang": "cpp", "code": "public function getChangedFiles($rev)\n    {\n        $raw_changes = $this->execute('hg status --change ' . $rev);\n        $this->repository_type = 'hg';\n\n        $changes = [];\n        foreach ($raw_changes as $key => $change) {\n            $exploded_change = explode(' ', $change);\n            $changes[$key]['type'] = $exploded_change[0];\n            $changes[$key]['path'] = $exploded_change[1];\n        }\n\n        return $changes;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getBehaviors()\n    {\n        if (null === $this->behaviors) {\n            // find behaviors in composer.lock file\n            $lock = $this->findComposerLock();\n\n            if (null === $lock) {\n                $this->behaviors = [];\n            } else {\n                $this->behaviors = $this->loadBehaviors($lock);\n            }\n\n            // find behavior in composer.json (useful when developing a behavior)\n            $json = $this->findComposerJson();\n\n            if (null !== $json) {\n                $behavior = $this->loadBehavior(json_decode($json->getContents(), true));\n\n                if (null !== $behavior) {\n                    $this->behaviors[$behavior['name']] = $behavior;\n                }\n            }\n        }\n\n        return $this->behaviors;\n    }", "comment": ""}
{"lang": "cpp", "code": "function() {\n        if (this.components) {\n            var len = this.components.length;\n            if (len > 0 && len <= 2) {\n                return this.components[0].clone();\n            } else if (len > 2) {\n                var sumX = 0.0;\n                var sumY = 0.0;\n                var x0 = this.components[0].x;\n                var y0 = this.components[0].y;\n                var area = -1 * this.getArea();\n                if (area != 0) {\n                    for (var i = 0; i < len - 1; i++) {\n                        var b = this.components[i];\n                        var c = this.components[i+1];\n                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));\n                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));\n                    }\n                    var x = x0 + sumX / (6 * area);\n                    var y = y0 + sumY / (6 * area);\n                } else {\n                    for (var i = 0; i < len - 1; i++) {\n                        sumX += this.components[i].x;\n                        sumY += this.components[i].y;\n                    }\n                    var x = sumX / (len - 1);\n                    var y = sumY / (len - 1);\n                }\n                return new OpenLayers.Geometry.Point(x, y);\n            } else {\n                return null;\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public static final double bearing(double lat1, double lon1, double lat2, double lon2)\r\n    {\r\n        return Math.toDegrees(radBearing(lat1, lon1, lat2, lon2));\r\n    }", "comment": ""}
{"lang": "cpp", "code": "def flow_pipeminor(Diam, HeadLossExpans, KMinor):\n    \n    #Checking input validity - inputs not checked here are checked by\n    #functions this function calls.\n    ut.check_range([HeadLossExpans, \">=0\", \"Headloss due to expansion\"],\n                   [KMinor, \">0\", \"K minor\"])\n    return (area_circle(Diam).magnitude * np.sqrt(2 * gravity.magnitude\n                                                  * HeadLossExpans\n                                                  / KMinor)\n            )", "comment": ""}
{"lang": "cpp", "code": "function(inlines) {\n  var m;\n  if ((m = this.match(reMain))) {\n    inlines.push({ t: 'Str', c: m });\n    return m.length;\n  } else {\n    return 0;\n  }\n}", "comment": ""}
{"lang": "cpp", "code": "public SyntacticCategory assignAllFeatures(String value) {\n    Set<Integer> featureVars = Sets.newHashSet();\n    getAllFeatureVariables(featureVars);\n\n    Map<Integer, String> valueMap = Maps.newHashMap();\n    for (Integer var : featureVars) {\n      valueMap.put(var, value);\n    }\n    return assignFeatures(valueMap, Collections.<Integer, Integer>emptyMap());\n  }", "comment": ""}
{"lang": "cpp", "code": "def almost_unitary(gate: Gate) -> bool:\n    \"\"\"\"\"\"\n    res = (gate @ gate.H).asoperator()\n    N = gate.qubit_nb\n    return np.allclose(asarray(res), np.eye(2**N), atol=TOLERANCE)", "comment": ""}
{"lang": "cpp", "code": "public function addLimitOffset(int $limit, int $offset): void\n    {\n        if ($limit === 0 && $offset === 0) {\n            return;\n        }\n        if ($limit === 0 && $offset <> 0) {\n            return;\n        }\n        if ($offset === 0) {\n            $this->statement .= ' LIMIT ' . $limit;\n        } else {\n            $this->statement .= sprintf(' LIMIT %d, %d', $offset, $limit);\n        }\n        $this->statement .= PHP_EOL;\n    }", "comment": ""}
{"lang": "cpp", "code": "def box_actions(results, times, N_matrix, ifprint):\n    \n    if(ifprint):\n        print(\"\\n=====\\nUsing triaxial harmonic toy potential\")\n\n    t = time.time()\n    # Find best toy parameters\n    omega = toy.findbestparams_ho(results)\n    if(ifprint):\n        print(\"Best omega \"+str(omega)+\" found in \"+str(time.time()-t)+\" seconds\")\n\n    # Now find toy actions and angles\n    AA = np.array([toy.angact_ho(i,omega) for i in results])\n    AA = AA[~np.isnan(AA).any(1)]\n    if(len(AA)==0):\n        return\n\n    t = time.time()\n    act = solver.solver(AA, N_matrix)\n    if act==None:\n        return\n\n    if(ifprint):\n        print(\"Action solution found for N_max = \"+str(N_matrix)+\", size \"+str(len(act[0]))+\" symmetric matrix in \"+str(time.time()-t)+\" seconds\")\n\n    np.savetxt(\"GF.Sn_box\",np.vstack((act[1].T,act[0][3:])).T)\n\n    ang = solver.angle_solver(AA,times,N_matrix,np.ones(3))\n    if(ifprint):\n        print(\"Angle solution found for N_max = \"+str(N_matrix)+\", size \"+str(len(ang))+\" symmetric matrix in \"+str(time.time()-t)+\" seconds\")\n\n    # Just some checks\n    if(len(ang)>len(AA)):\n        print(\"More unknowns than equations\")\n\n    return act[0], ang, act[1], AA, omega", "comment": ""}
{"lang": "cpp", "code": "public void populate(Object target, Map properties) throws BeanMappingException {\n        BeanMappingParam param = new BeanMappingParam();\n        param.setSrcRef(properties);\n        param.setTargetRef(target);\n        param.setConfig(this.populateConfig);\n        param.setProcesses(BeanMappingEnvironment.getBeanMapVps());\n        // \u6267\u884cmapping\u5904\u7406\n        BeanMappingExecutor.execute(param);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *Server) getOrCreateAutopilotConfig() *autopilot.Config {\n\tstate := s.fsm.State()\n\t_, config, err := state.AutopilotConfig()\n\tif err != nil {\n\t\ts.logger.Printf(\"[ERR] autopilot: failed to get config: %v\", err)\n\t\treturn nil\n\t}\n\tif config != nil {\n\t\treturn config\n\t}\n\n\tif !ServersMeetMinimumVersion(s.LANMembers(), minAutopilotVersion) {\n\t\ts.logger.Printf(\"[WARN] autopilot: can't initialize until all servers are >= %s\", minAutopilotVersion.String())\n\t\treturn nil\n\t}\n\n\tconfig = s.config.AutopilotConfig\n\treq := structs.AutopilotSetConfigRequest{Config: *config}\n\tif _, err = s.raftApply(structs.AutopilotRequestType, req); err != nil {\n\t\ts.logger.Printf(\"[ERR] autopilot: failed to initialize config: %v\", err)\n\t\treturn nil\n\t}\n\n\treturn config\n}", "comment": ""}
{"lang": "cpp", "code": "public function setDisplayBank($displayBank = true)\n    {\n        $this->isBool($displayBank, 'displayBank');\n        $this->displayBank = $displayBank;\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (e *Engine) fullCompactionStrategy(group CompactionGroup, optimize bool) *compactionStrategy {\n\ts := &compactionStrategy{\n\t\tgroup:     group,\n\t\tlogger:    e.logger.With(zap.String(\"tsm1_strategy\", \"full\"), zap.Bool(\"tsm1_optimize\", optimize)),\n\t\tfileStore: e.FileStore,\n\t\tcompactor: e.Compactor,\n\t\tfast:      optimize,\n\t\tengine:    e,\n\t\tlevel:     5,\n\t\ttracker:   e.compactionTracker,\n\t}\n\n\tif optimize {\n\t\ts.level = 4\n\t}\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public function modal_template() {\n\n\t\t$output = '<script type=\"text/html\" id=\"' . esc_attr( $this->id() ) . '-components\">';\n\t\tforeach ( $this->modals as $modal ) {\n\n\t\t\t$label         = $modal->struct['label'];\n\t\t\t$data          = $modal->get_data();\n\t\t\t$data_template = $this->drill_in( $data[ $modal->slug ], '{{@root' );\n\t\t\t$modal->set_data( array( $modal->slug => $data_template ) );\n\n\t\t\t$modal->render();\n\n\t\t\t$setup = null;\n\t\t\tif ( count( $modal->child ) > 1 ) {\n\t\t\t\t$setup = ' data-setup=\"true\" ';\n\t\t\t}\n\n\t\t\t$output .= '<button type=\"button\" class=\"button uix-component-trigger\" style=\"margin:12px 0 0 12px;\" data-label=\"' . esc_attr( $modal->attributes['data-title'] ) . '\" data-type=\"' . $modal->slug . '\" ' . $setup . ' data-id=\"' . esc_attr( $modal->id() ) . '\">' . $label . '</button> ';\n\n\t\t}\n\t\t$output .= '</script>';\n\n\t\treturn $output;\n\t}", "comment": ""}
{"lang": "cpp", "code": "public static String resolveUriPrefix(URI serverURI)\n      throws URISyntaxException {\n    if (RESTLI_SCHEMES.contains(serverURI.getScheme())) {\n      return new URI(serverURI.getScheme(), serverURI.getAuthority(), null, null, null).toString() + \"/\";\n    }\n\n    throw new RuntimeException(\"Unrecognized scheme for URI \" + serverURI);\n  }", "comment": ""}
{"lang": "cpp", "code": "private static void writeValue(Object value, JsonWriter writer) throws IOException {\n    if (value == null) {\n      writer.nullValue();\n    } else if (value instanceof Number) {\n      writer.value((Number) value);\n    } else if (value instanceof Boolean) {\n      writer.value((Boolean) value);\n    } else if (value instanceof List) {\n      listToWriter((List) value, writer);\n    } else if (value instanceof Map) {\n      mapToWriter((Map) value, writer);\n    } else if (value.getClass().isArray()) {\n      arrayToWriter(value, writer);\n    } else {\n      writer.value(String.valueOf(value));\n    }\n  }", "comment": ""}
{"lang": "cpp", "code": "public function createProcedure($name)\n    {\n        $definition = array(\n            'parent' => $this->context,\n            'name' => $name,\n            'sources' => array(),\n            'workers' => array(),\n            'targets' => array(),\n            'children' => array(),\n        );\n\n        $this->definitions[$name] = $definition;\n\n        $this->context = $name;\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function convert($to, $val)\n    {\n        $val = $this->parseValue($val);\n\n        return base_convert($val, $this->unit, $to);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *ListAlgorithmsInput) SetMaxResults(v int64) *ListAlgorithmsInput {\n\ts.MaxResults = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public static function collectionOf(IType $elementType, string $collectionClass = ITypedCollection::class) : CollectionType\n    {\n        $elementTypeString = $elementType->asTypeString();\n\n        if (!isset(self::$collections[$collectionClass][$elementTypeString])) {\n            self::$collections[$collectionClass][$elementTypeString] = new CollectionType($elementType, $collectionClass);\n        }\n\n        return self::$collections[$collectionClass][$elementTypeString];\n    }", "comment": ""}
{"lang": "cpp", "code": "function computeGameStateOfTaskEnvironment(taskEnvironment) {\n  const { pastActions, currentAction } = taskEnvironment;\n  const initialState = getInitialGameState(taskEnvironment);\n  let currentState = doActionMoves(initialState, pastActions);\n  if (currentAction !== null) {\n    currentState = doAction(currentState, currentAction);\n  }\n  /*\n  const someActionsTaken = taskEnvironment.pastActions.length > 0;\n  // TODO: DRY identical someActionsTaken computation at two places (or avoid\n  // finalGameStage computation altogether, it feels like a hack...)\n  const finalGameStage = decideGameStage(\n    currentState.fields,\n    currentState.spaceship,\n    taskEnvironment.interpreting,\n    someActionsTaken);\n  return { ...currentState, stage: finalGameStage };\n  */\n  return currentState;\n}", "comment": ""}
{"lang": "cpp", "code": "def upsert_all(cls, engine, obj_or_data):\n        \n        cls.update_all(\n            engine=engine,\n            obj_or_data=obj_or_data,\n            upsert=True,\n        )", "comment": ""}
{"lang": "cpp", "code": "func (s *ADMMessage) SetBody(v string) *ADMMessage {\n\ts.Body = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public static function clearCache($postId, $post)\n    {\n        if (wp_is_post_revision($postId) || get_post_status($postId) != 'publish') {\n            return false;\n        }\n\n        wp_cache_delete($postId, self::getKeyGroup());\n        wp_cache_delete($post->post_type, self::getKeyGroup());\n\n        // Empty post type for all sites in network (?)\n        if (function_exists('is_multisite') && is_multisite() && apply_filters('Municipio\\Cache\\EmptyForAllBlogs', false, $post)) {\n            $blogs = get_sites();\n\n            foreach ($blogs as $blog) {\n                wp_cache_delete($post->post_type, self::getKeyGroup($blog->blog_id));\n            }\n        }\n\n        return true;\n    }", "comment": ""}
{"lang": "cpp", "code": "private void synchronizeElement(\n        CmsObject cms,\n        String elementPath,\n        Collection<String> skipPaths,\n        Locale sourceLocale) {\n\n        if (elementPath.contains(\"/\")) {\n            String parentPath = CmsXmlUtils.removeLastXpathElement(elementPath);\n            List<I_CmsXmlContentValue> parentValues = getValuesByPath(parentPath, sourceLocale);\n            String elementName = CmsXmlUtils.getLastXpathElement(elementPath);\n            for (I_CmsXmlContentValue parentValue : parentValues) {\n                String valuePath = CmsXmlUtils.concatXpath(parentValue.getPath(), elementName);\n                boolean skip = false;\n                for (String skipPath : skipPaths) {\n                    if (valuePath.startsWith(skipPath)) {\n                        skip = true;\n                        break;\n                    }\n                }\n                if (!skip) {\n                    if (hasValue(valuePath, sourceLocale)) {\n                        List<I_CmsXmlContentValue> subValues = getValues(valuePath, sourceLocale);\n                        removeSurplusValuesInOtherLocales(elementPath, subValues.size(), sourceLocale);\n                        for (I_CmsXmlContentValue value : subValues) {\n                            if (value.isSimpleType()) {\n                                setValueForOtherLocales(cms, value, CmsXmlUtils.removeLastXpathElement(valuePath));\n                            } else {\n                                List<I_CmsXmlContentValue> simpleValues = getAllSimpleSubValues(value);\n                                for (I_CmsXmlContentValue simpleValue : simpleValues) {\n                                    setValueForOtherLocales(cms, simpleValue, parentValue.getPath());\n                                }\n                            }\n                        }\n                    } else {\n                        removeValuesInOtherLocales(valuePath, sourceLocale);\n                    }\n                }\n            }\n        } else {\n            if (hasValue(elementPath, sourceLocale)) {\n                List<I_CmsXmlContentValue> subValues = getValues(elementPath, sourceLocale);\n                removeSurplusValuesInOtherLocales(elementPath, subValues.size(), sourceLocale);\n                for (I_CmsXmlContentValue value : subValues) {\n                    if (value.isSimpleType()) {\n                        setValueForOtherLocales(cms, value, null);\n                    } else {\n                        List<I_CmsXmlContentValue> simpleValues = getAllSimpleSubValues(value);\n                        for (I_CmsXmlContentValue simpleValue : simpleValues) {\n                            setValueForOtherLocales(cms, simpleValue, null);\n                        }\n                    }\n                }\n            } else {\n                removeValuesInOtherLocales(elementPath, sourceLocale);\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (l *Netlist) UnmarshalTOML(fn func(interface{}) error) error {\n\tvar masks []string\n\tif err := fn(&masks); err != nil {\n\t\treturn err\n\t}\n\tfor _, mask := range masks {\n\t\t_, n, err := net.ParseCIDR(mask)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t*l = append(*l, *n)\n\t}\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "private function _write_log($daily = false, $hourly = false, $backtrace = false) {\n\n        // if we are using a callback function to handle logs\n        if (is_callable($this->log_path) && !isset($this->log_path_is_function))\n\n            // set flag\n            $this->log_path_is_function = true;\n\n        // if we are writing logs to a file\n        else {\n\n            // set flag\n            $this->log_path_is_function = false;\n\n            $pathinfo = pathinfo($this->log_path);\n\n            // if log_path is given as full path to a file, together with extension\n            if (isset($pathinfo['filename']) && isset($pathinfo['extension'])) {\n\n                // use those values\n                $file_name = $pathinfo['dirname'] . '/' . $pathinfo['filename'];\n                $extension = '.' . $pathinfo['extension'];\n\n            // otherwise\n            } else {\n\n                // the file name is \"log\" and the extension is \".txt\"\n                $file_name = rtrim($this->log_path, '/\\\\') . '/log';\n                $extension = '.txt';\n\n            }\n\n            // if $hourly is set to TRUE, $daily *must* be true\n            if ($hourly) $daily = true;\n\n            // are we writing daily logs?\n            // (suppress \"strict standards\" warning for PHP 5.4+)\n            $file_name .= ($daily ? '-' . @date('Ymd') : '');\n\n            // are we writing hourly logs?\n            // (suppress \"strict standards\" warning for PHP 5.4+)\n            $file_name .= ($hourly ? '-' . @date('H') : '');\n\n            // log file's extension\n            $file_name .= $extension;\n\n        }\n\n        // all the labels that may be used in a log entry\n        $labels = array(\n            strtoupper($this->language['date']),\n            strtoupper('query'),\n            strtoupper($this->language['execution_time']),\n            strtoupper($this->language['warning']),\n            strtoupper($this->language['error']),\n            strtoupper($this->language['from_cache']),\n            strtoupper($this->language['yes']),\n            strtoupper($this->language['no']),\n            strtoupper($this->language['backtrace']),\n            strtoupper($this->language['file']),\n            strtoupper($this->language['line']),\n            strtoupper($this->language['function']),\n            strtoupper($this->language['unbuffered']),\n        );\n\n        // determine the longest label (for proper indenting)\n        $longest_label_length = 0;\n\n        // iterate through the labels\n        foreach ($labels as $label)\n\n            // if the label is longer than the longest label so far\n            if (strlen($label) > $longest_label_length)\n\n                // this is the longes label, so far\n                // we use utf8_decode so that strlen counts correctly with accented chars\n                $longest_label_length = strlen(utf8_decode($label));\n\n        $longest_label_length--;\n\n        // the following regular expressions strips newlines and indenting from the MySQL string, so that\n        // we have it in a single line\n        $pattern = array(\n            \"/\\s*(.*)\\n|\\r/\",\n            \"/\\n|\\r/\"\n        );\n\n        $replace = array(\n            ' $1',\n            ' '\n        );\n\n        // if we are using a callback function for logs or we are writing the logs to a file and we can create/write to the log file\n        if ($this->log_path_is_function || $handle = @fopen($file_name, 'a+')) {\n\n            // we need to show both successful and unsuccessful queries\n            $sections = array('successful-queries', 'unsuccessful-queries');\n\n            // iterate over the sections we need to show\n            foreach ($sections as $section) {\n\n                // if there are any queries in the section\n                if (isset($this->debug_info[$section])) {\n\n                    // iterate through the debug information\n                    foreach ($this->debug_info[$section] as $debug_info) {\n\n                        // the output\n                        $output =\n\n                            // date\n                            $labels[0] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[0])), ' ', STR_PAD_RIGHT) . ': ' . @date('Y-m-d H:i:s') . \"\\n\" .\n\n                            // query\n                            $labels[1] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[1])), ' ', STR_PAD_RIGHT) . ': ' . trim(preg_replace($pattern, $replace, $debug_info['query'])) . \"\\n\" .\n\n                            // if execution time is available\n                            // (is not available for unsuccessful queries)\n                            (isset($debug_info['execution_time']) ? $labels[2] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[2])), ' ', STR_PAD_RIGHT) . ': ' . $this->_fix_pow($debug_info['execution_time']) . ' ' . $this->language['seconds'] . \"\\n\" : '') .\n\n                            // if there is a warning message\n                            (isset($debug_info['warning']) && $debug_info['warning'] != '' ? $labels[3] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[3])), ' ', STR_PAD_RIGHT) . ': ' . strip_tags($debug_info['warning']) . \"\\n\" : '') .\n\n                            // if there is an error message\n                            (isset($debug_info['error']) && $debug_info['error'] != '' ? $labels[4] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[4])), ' ', STR_PAD_RIGHT) . ': ' . $debug_info['error'] . \"\\n\" : '') .\n\n                            // if not an action query, show whether the query was returned from the cache or was executed\n                            (isset($debug_info['affected_rows']) && $debug_info['affected_rows'] === false && isset($debug_info['from_cache']) && $debug_info['from_cache'] != 'nocache' ? $labels[5] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[5])), ' ', STR_PAD_RIGHT) . ': ' . $labels[6] . \"\\n\" : '') .\n\n                            // if query was an unbuffered one\n                            (isset($debug_info['unbuffered']) && $debug_info['unbuffered'] ? $labels[12] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[12])), ' ', STR_PAD_RIGHT) . ': ' . $labels[6] . \"\\n\" : '');\n\n                        // if we are writing the logs to a file, write to the log file\n                        if (!$this->log_path_is_function) fwrite($handle, print_r($output, true));\n\n                        $backtrace_output = '';\n\n                        // if backtrace information should be written to the log file\n                        if ($backtrace) {\n\n                            $backtrace_output = $labels[8] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[8])), ' ', STR_PAD_RIGHT) . ':' . \"\\n\";\n\n                            // if we are writing the logs to a file, write to the log file\n                            if (!$this->log_path_is_function) fwrite($handle, print_r($backtrace_output, true));\n\n                            // handle full backtrace info\n                            foreach ($debug_info['backtrace'] as $backtrace) {\n\n                                // output\n                                $tmp =\n                                    \"\\n\" .\n                                    $labels[9] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[9])), ' ', STR_PAD_RIGHT) . ': ' . $backtrace[$this->language['file']] . \"\\n\" .\n                                    $labels[10] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[10])), ' ', STR_PAD_RIGHT) . ': ' . $backtrace[$this->language['line']] . \"\\n\" .\n                                    $labels[11] . str_pad('', $longest_label_length - strlen(utf8_decode($labels[11])), ' ', STR_PAD_RIGHT) . ': ' . $backtrace[$this->language['function']] . \"\\n\";\n\n                                // if we are writing the logs to a file, write to the log file\n                                if (!$this->log_path_is_function) fwrite($handle, print_r($tmp, true));\n\n                                // otherwise, add to the string\n                                else $backtrace_output .= $tmp;\n\n                            }\n\n                        }\n\n                        // if we are writing the logs to a file, finish writing to the log file by adding a bottom border\n                        if (!$this->log_path_is_function) fwrite($handle, str_pad('', $longest_label_length + 1, '-', STR_PAD_RIGHT) . \"\\n\");\n\n                        // if we are using a callback to manage logs, pass log information to the log file\n                        else call_user_func_array($this->log_path, array($output, $backtrace_output));\n\n                    }\n\n                }\n\n            }\n\n            // if we are writing the logs to a file, close the log file\n            if (!$this->log_path_is_function) fclose($handle);\n\n        // if log file could not be created/opened\n        } else\n\n            trigger_error($this->language['could_not_write_to_log'], E_USER_ERROR);\n\n    }", "comment": ""}
{"lang": "cpp", "code": "public static String getNameOfMissingClassLoaderDependency(Throwable e) {\n        if (e instanceof NoClassDefFoundError) {\n            // NoClassDefFoundError sometimes includes CNFE as the cause. Since CNFE has a better formatted class name\n            // and may also include classloader info, we prefer CNFE's over NCDFE's message.\n            if (e.getCause() instanceof ClassNotFoundException) {\n                return getNameOfMissingClassLoaderDependency(e.getCause());\n            }\n            if (e.getMessage() != null) {\n                return e.getMessage().replace('/', '.');\n            }\n        }\n        if (e instanceof ClassNotFoundException) {\n            if (e.getMessage() != null) {\n                return e.getMessage();\n            }\n        }\n        if (e.getCause() != null) {\n            return getNameOfMissingClassLoaderDependency(e.getCause());\n        } else {\n            return \"[unknown]\";\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "function(obj) {\n    if (obj instanceof Cell) {\n      return {\n        inside: obj.inside\n      };\n    } else {\n      return {\n        back : serialize(obj.back),\n        front : serialize(obj.front),\n        plane: obj.plane,\n        shp: obj.shp,\n        complemented: obj.complemented,\n      };\n    }\n  }", "comment": ""}
{"lang": "cpp", "code": "function () {\n        var option = clone(this.option);\n\n        each(option, function (opts, mainType) {\n            if (ComponentModel.hasClass(mainType)) {\n                var opts = modelUtil.normalizeToArray(opts);\n                for (var i = opts.length - 1; i >= 0; i--) {\n                    // Remove options with inner id.\n                    if (modelUtil.isIdInner(opts[i])) {\n                        opts.splice(i, 1);\n                    }\n                }\n                option[mainType] = opts;\n            }\n        });\n\n        delete option[OPTION_INNER_KEY];\n\n        return option;\n    }", "comment": ""}
{"lang": "cpp", "code": "func CreateNonce() ([]byte, error) {\n\tnonce, err := crypto.GetRandomNonce()\n\treturn nonce, errors.WithMessage(err, \"error generating random nonce\")\n}", "comment": ""}
{"lang": "cpp", "code": "public function process(array $coveredIds) : void\n    {\n        $this->setCoveredPatternIds($coveredIds);\n\n        $finder = new Finder();\n        $finder->files();\n        $finder->name('*.json');\n        $finder->ignoreDotFiles(true);\n        $finder->ignoreVCS(true);\n        $finder->sortByName();\n        $finder->ignoreUnreadableDirs();\n        $finder->in($this->resourceDir);\n\n        foreach ($finder as $file) {\n            /* @var \\Symfony\\Component\\Finder\\SplFileInfo $file */\n\n            /** @var string $patternFileName */\n            $patternFileName = mb_substr($file->getPathname(), (int) mb_strpos($file->getPathname(), 'resources/'));\n\n            if (!isset($this->coveredIds[$patternFileName])) {\n                $this->coveredIds[$patternFileName] = [];\n            }\n\n            $this->coverage[$patternFileName] = $this->processFile(\n                $patternFileName,\n                $file->getContents(),\n                $this->coveredIds[$patternFileName]\n            );\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def get_rdns_name(rdns):\n    \n    name = ''\n    for rdn in rdns:\n        for attr in rdn._attributes:\n            if len(name) > 0:\n                name = name + ','\n            if attr.oid in OID_NAMES:\n                name = name + OID_NAMES[attr.oid]\n            else:\n                name = name + attr.oid._name\n            name = name + '=' + attr.value\n    return name", "comment": ""}
{"lang": "cpp", "code": "func MountHealthController(service *goa.Service, ctrl HealthController) {\n\tinitService(service)\n\tvar h goa.Handler\n\tservice.Mux.Handle(\"OPTIONS\", \"/cellar/_ah/health\", ctrl.MuxHandler(\"preflight\", handleHealthOrigin(cors.HandlePreflight()), nil))\n\n\th = func(ctx context.Context, rw http.ResponseWriter, req *http.Request) error {\n\t\t// Check if there was an error loading the request\n\t\tif err := goa.ContextError(ctx); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Build the context\n\t\trctx, err := NewHealthHealthContext(ctx, req, service)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn ctrl.Health(rctx)\n\t}\n\th = handleHealthOrigin(h)\n\tservice.Mux.Handle(\"GET\", \"/cellar/_ah/health\", ctrl.MuxHandler(\"health\", h, nil))\n\tservice.LogInfo(\"mount\", \"ctrl\", \"Health\", \"action\", \"Health\", \"route\", \"GET /cellar/_ah/health\")\n}", "comment": ""}
{"lang": "cpp", "code": "func (bot TgBot) SendAudioWithKeyboardHide(cid int, audio string, duration *int, performer *string, title *string, rmi *int, rm ReplyKeyboardHide) ResultWithMessage {\n\tvar rkm ReplyMarkupInt = rm\n\treturn bot.SendAudio(cid, audio, duration, performer, title, rmi, &rkm)\n}", "comment": ""}
{"lang": "cpp", "code": "public void setData(String key, String value) {\n        QName qn = new QName(\"data-\" + key);\n        this.getOtherAttributes().put(qn, value);\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function unserializeEmbeddedCollection(MapperInterface $mapper, array $data)\n    {\n        $collection = array();\n        foreach ($data as $document) {\n            $collection[] = $mapper->unserialize($document);\n        }\n\n        return $collection;\n    }", "comment": ""}
{"lang": "cpp", "code": "def stop(cls, name):\n        \n        cls.timer_end[name] = time.time()\n        if cls.debug:\n            print(\"Timer\", name, \"stopped ...\")", "comment": ""}
{"lang": "cpp", "code": "public static <T> T objectFromClause(Class<T> type, String clause, Object... args)\n    {\n        return SqlClosure.sqlExecute(c -> OrmElf.objectFromClause(c, type, clause, args));\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getSqlPaginateParams($pickedPage = false) {\r\n        $p = new SqlPaginateParams();\r\n        if ($pickedPage) {\r\n            $this->pickedPage = $pickedPage;\r\n        }\r\n        if ($this->pages == 0) {\r\n            $p->setOffset(0);\r\n            $p->setLimit(20);\r\n            return $p;\r\n        }\r\n        if ($this->pickedPage > $this->pages) {\r\n            $this->pickedPage = $this->pages;\r\n        }\r\n        if ($this->pickedPage < 1) {\r\n            $this->pickedPage = 1;\r\n        }\r\n        $p->setOffset($this->pickedPage * $this->elementsPerPage - $this->elementsPerPage);\r\n        $p->setLimit($this->elementsPerPage);\r\n\r\n        return $p;\r\n    }", "comment": ""}
{"lang": "cpp", "code": "def query_intersections(self, x_terms=None, y_terms=None, symmetric=False):\n        \n        if x_terms is None:\n            x_terms = []\n        if y_terms is None:\n            y_terms = []\n        xset = set(x_terms)\n        yset = set(y_terms)\n        zset = xset.union(yset)\n\n        # first built map of gene->termClosure.\n        # this could be calculated ahead of time for all g,\n        # but this may be space-expensive. TODO: benchmark\n        gmap={}\n        for z in zset:\n            gmap[z] = []\n        for subj in self.subjects:\n            ancs = self.inferred_types(subj)\n            for a in ancs.intersection(zset):\n                gmap[a].append(subj)\n        for z in zset:\n            gmap[z] = set(gmap[z])\n        ilist = []\n        for x in x_terms:\n            for y in y_terms:\n                if not symmetric or x<y:\n                    shared = gmap[x].intersection(gmap[y])\n                    union = gmap[x].union(gmap[y])\n                    j = 0\n                    if len(union)>0:\n                        j = len(shared) / len(union)\n                    ilist.append({'x':x,'y':y,'shared':shared, 'c':len(shared), 'j':j})\n        return ilist", "comment": ""}
{"lang": "cpp", "code": "function readFile(path, fileName) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(`${path}/${fileName}`, 'utf8', (err, content) => {\n      if (err) {\n        return reject(err)\n      }\n\n      return resolve(content)\n    })\n  })\n}", "comment": ""}
{"lang": "cpp", "code": "func (in *GitBuildSource) DeepCopy() *GitBuildSource {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(GitBuildSource)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "comment": ""}
{"lang": "cpp", "code": "def start\n      if(@sockets.size < 0)\n        raise 'No sockets available for listening'\n      elsif(!@runner.nil? && @runner.alive?)\n        raise AlreadyRunning.new\n      else\n        @stop = false\n        @runner = Thread.new{watch}\n      end\n    end", "comment": ""}
{"lang": "cpp", "code": "public function register_action_map($map)\n    {\n        if (is_array($map)) {\n            foreach ($map as $idx => $val) {\n                $this->action_map[$idx] = $val;\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def create_permission_request(self, customer, pos_id, pos_tid, scope,\n                                  ledger=None, text=None, callback_uri=None,\n                                  expires_in=None):\n        \n        arguments = {'customer': customer,\n                     'pos_id': pos_id,\n                     'pos_tid': pos_tid,\n                     'scope': scope,\n                     'ledger': ledger,\n                     'text': text,\n                     'callback_uri': callback_uri,\n                     'expires_in': expires_in}\n        return self.do_req('POST',\n                           self.merchant_api_base_url + '/permission_request/',\n                           arguments).json()", "comment": ""}
{"lang": "cpp", "code": "func (p *parser) readv(t token) ([]token, error) {\n\tvar tokens []token\n\tfor {\n\t\tread, err := p.readt(t.typ)\n\t\ttokens = append(tokens, read...)\n\t\tif err != nil {\n\t\t\treturn tokens, err\n\t\t}\n\t\tif len(read) > 0 && read[len(read)-1].val == t.val {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn tokens, nil\n}", "comment": ""}
{"lang": "cpp", "code": "public function getPattern(PackageInterface $package)\n    {\n        if (isset($this->packages[$package->getName()])) {\n            return $this->packages[$package->getName()];\n        } elseif (isset($this->packages[$package->getPrettyName()])) {\n            return $this->packages[$package->getPrettyName()];\n        } elseif (isset($this->types[$package->getType()])) {\n            return $this->types[$package->getType()];\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public void layoutCalendar(Date timeTarget)\n    {\n        calendar.setTime(timeTarget);\n        \n        int hour = calendar.get(Calendar.HOUR_OF_DAY);\n        int minute = calendar.get(Calendar.MINUTE);\n                \n        String[] array = new String[24 * 2];\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        int selectedIndex = -1;\n        for (int i = 0; i < array.length; i++)\n        {\n            if (hour == calendar.get(Calendar.HOUR_OF_DAY))\n                if (minute == calendar.get(Calendar.MINUTE))\n                    selectedIndex = i;\n            Date time = calendar.getTime();\n            String strTime = timeFormat.format(time);\n            array[i] = strTime;\n            calendar.add(Calendar.MINUTE, 30);\n        }\n        DefaultComboBoxModel model = new DefaultComboBoxModel(array);\n        this.setVisibleRowCount(10);\n        this.setModel(model);\n        if (selectedIndex != -1)\n            this.setSelectedIndex(selectedIndex);\n    }", "comment": ""}
{"lang": "cpp", "code": "function parse_lpstr(blob, type, pad) {\n\tvar start = blob.l;\n\tvar str = blob.read_shift(0, 'lpstr-cp');\n\tif(pad) while((blob.l - start) & 3) ++blob.l;\n\treturn str;\n}", "comment": ""}
{"lang": "cpp", "code": "def validate(self):\n    \"\"\"\"\"\"\n    # PASS if all our validators return True, otherwise FAIL.\n    try:\n      if all(v(self.measured_value.value) for v in self.validators):\n        self.outcome = Outcome.PASS\n      else:\n        self.outcome = Outcome.FAIL\n      return self\n    except Exception as e:  # pylint: disable=bare-except\n      _LOG.error('Validation for measurement %s raised an exception %s.',\n                 self.name, e)\n      self.outcome = Outcome.FAIL\n      raise\n    finally:\n      if self._cached:\n        self._cached['outcome'] = self.outcome.name", "comment": ""}
{"lang": "cpp", "code": "public static CollectionReflectionUtilImpl getInstance() {\n\n    if (instance == null) {\n      synchronized (CollectionReflectionUtilImpl.class) {\n        if (instance == null) {\n          CollectionReflectionUtilImpl util = new CollectionReflectionUtilImpl();\n          util.initialize();\n          instance = util;\n        }\n      }\n    }\n    return instance;\n  }", "comment": ""}
{"lang": "cpp", "code": "private void addPreflightOptionsRequestSupport(RestExpress server, CorsOptionsController corsOptionsController)\n    {\n\t    RouteBuilder rb;\n\n\t    for (String pattern : methodsByPattern.keySet())\n\t    {\n\t    \trb = server.uri(pattern, corsOptionsController)\n\t\t    \t.action(\"options\", HttpMethod.OPTIONS)\n\t\t    \t.noSerialization()\n\t\t    \t// Disable both authentication and authorization which are usually use header such as X-Authorization.\n\t\t    \t// When browser does CORS preflight with OPTIONS request, such headers are not included.\n\t\t    \t.flag(Flags.Auth.PUBLIC_ROUTE)\n\t\t    \t.flag(Flags.Auth.NO_AUTHORIZATION);\n\n\t    \tfor (String flag : flags)\n\t    \t{\n\t    \t\trb.flag(flag);\n\t    \t}\n\n\t    \tfor (Entry<String, Object> entry : parameters.entrySet())\n\t    \t{\n\t    \t\trb.parameter(entry.getKey(), entry.getValue());\n\t    \t}\n\n\t    \trouteBuilders.add(rb);\n\t    }\n    }", "comment": ""}
{"lang": "cpp", "code": "void buildCSSTypesDictionary()\n  {\n    String description;\n    String value;\n    TextSearchDictionaryEntry de;\n\n\n    //search eval() expression\n    description = \"text/css\";\n    value = \"text/css\";\n    de = new TextSearchDictionaryEntry(description, value, MessageId.CSS_009);\n    v.add(de);\n\n\n  }", "comment": ""}
{"lang": "cpp", "code": "func (s *Schema) refToSchema(str string, rootSchema Schema, loadExternal bool) (*Schema, error) {\n\tparentURL, err := url.Parse(s.parentId)\n\tif err == nil && parentURL.IsAbs() {\n\t\tsURL, err := url.Parse(str)\n\t\tif err == nil && !sURL.IsAbs() && !strings.HasPrefix(str, \"#\") {\n\t\t\tstr = parentURL.ResolveReference(sURL).String()\n\t\t}\n\t}\n\n\tvar split []string\n\turl, err := url.Parse(str)\n\tcacheKey, cacheKeyErr := resolveCacheKey(str)\n\tif err == nil && cacheKeyErr == nil {\n\t\tcachedSchema, ok := rootSchema.Cache[cacheKey]\n\t\tif ok {\n\t\t\trootSchema = *cachedSchema\n\t\t} else {\n\t\t\t// Handle external URIs.\n\t\t\tif !loadExternal {\n\t\t\t\treturn new(Schema), errors.New(\"external schemas are disabled\")\n\t\t\t}\n\t\t\tresp, err := http.Get(str)\n\t\t\tif err != nil {\n\t\t\t\treturn new(Schema), errors.New(\"bad external url\")\n\t\t\t}\n\t\t\tdefer resp.Body.Close()\n\t\t\ts, err := ParseWithCache(resp.Body, loadExternal, &rootSchema.Cache)\n\t\t\tif err != nil {\n\t\t\t\treturn new(Schema), errors.New(\"error parsing external doc\")\n\t\t\t}\n\t\t\trootSchema.Cache[cacheKey] = s\n\t\t\trootSchema = *s\n\t\t}\n\t\tstr = url.Fragment\n\t}\n\n\t// Remove the prefix from internal URIs.\n\tstr = strings.TrimPrefix(str, \"#\")\n\tstr = strings.TrimPrefix(str, \"/\")\n\n\tsplit = strings.Split(str, \"/\")\n\t// Make replacements.\n\tfor i, v := range split {\n\t\tr := strings.NewReplacer(\"~0\", \"~\", \"~1\", \"/\", \"%25\", \"%\")\n\t\tsplit[i] = r.Replace(v)\n\t}\n\t// Resolve the local part of the URI.\n\treturn resolveLocalPath(split, rootSchema, str)\n}", "comment": ""}
{"lang": "cpp", "code": "func (s *AtomicSequence) Load(data []byte) error {\n\tif s.initialized {\n\t\treturn errors.New(\"cannot load into an initialized sequence\")\n\t}\n\n\tvals := make(map[string]uint64)\n\tif err := json.Unmarshal(data, &vals); err != nil {\n\t\treturn err\n\t}\n\n\tif val, ok := vals[\"current\"]; !ok {\n\t\treturn errors.New(\"improperly formatted data or sequence version\")\n\t} else {\n\t\tatomic.SwapUint64(&s.current, val)\n\t}\n\n\tif val, ok := vals[\"increment\"]; !ok {\n\t\treturn errors.New(\"improperly formatted data or sequence version\")\n\t} else {\n\t\tatomic.SwapUint64(&s.increment, val)\n\t}\n\n\tif val, ok := vals[\"minvalue\"]; !ok {\n\t\treturn errors.New(\"improperly formatted data or sequence version\")\n\t} else {\n\t\tatomic.SwapUint64(&s.minvalue, val)\n\t}\n\n\tif val, ok := vals[\"maxvalue\"]; !ok {\n\t\treturn errors.New(\"improperly formatted data or sequence version\")\n\t} else {\n\t\tatomic.SwapUint64(&s.maxvalue, val)\n\t}\n\n\ts.initialized = true\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "public static function export_customfield_data(data_controller $data, array $subcontext) {\n        $context = $data->get_context();\n\n        $exportdata = $data->to_record();\n        $exportdata->fieldtype = $data->get_field()->get('type');\n        $exportdata->fieldshortname = $data->get_field()->get('shortname');\n        $exportdata->fieldname = $data->get_field()->get_formatted_name();\n        $exportdata->timecreated = \\core_privacy\\local\\request\\transform::datetime($exportdata->timecreated);\n        $exportdata->timemodified = \\core_privacy\\local\\request\\transform::datetime($exportdata->timemodified);\n        unset($exportdata->contextid);\n        // Use the \"export_value\" by default for the 'value' attribute, however the plugins may override it in their callback.\n        $exportdata->value = $data->export_value();\n\n        $classname = manager::get_provider_classname_for_component('customfield_' . $data->get_field()->get('type'));\n        if (class_exists($classname) && is_subclass_of($classname, customfield_provider::class)) {\n            component_class_callback($classname, 'export_customfield_data', [$data, $exportdata, $subcontext]);\n        } else {\n            // Custom field plugin does not implement customfield_provider, just export default value.\n            writer::with_context($context)->export_data($subcontext, $exportdata);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def unlock_account(account):\n        \n        return Web3Provider.get_web3().personal.unlockAccount(account.address, account.password)", "comment": ""}
{"lang": "cpp", "code": "public function link($page, $args = array())\n    {\n        $this->setElement('a');\n        $this->setAttr('href', $this->app->url($page, $args));\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (c *command) connect() error {\n\tif c.connected {\n\t\treturn transport.ErrAlreadyConnected\n\t}\n\n\tif c.auth == nil {\n\t\tif err := c.setAuthFromEndpoint(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tvar err error\n\tconfig, err := c.auth.ClientConfig()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\toverrideConfig(c.config, config)\n\n\tc.client, err = dial(\"tcp\", c.getHostWithPort(), config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tc.Session, err = c.client.NewSession()\n\tif err != nil {\n\t\t_ = c.client.Close()\n\t\treturn err\n\t}\n\n\tc.connected = true\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "private Observable<DocumentFragment<Lookup>> getCountIn(final String id, final LookupSpec spec,\n        final long timeout, final TimeUnit timeUnit) {\n        return Observable.defer(new Func0<Observable<DocumentFragment<Lookup>>>() {\n            @Override\n            public Observable<DocumentFragment<Lookup>> call() {\n                final SubGetCountRequest request = new SubGetCountRequest(id, spec.path(), bucketName);\n                request.xattr(spec.xattr());\n                request.accessDeleted(accessDeleted);\n                addRequestSpan(environment, request, \"subdoc_count\");\n                return applyTimeout(deferAndWatch(new Func1<Subscriber, Observable<SimpleSubdocResponse>>() {\n                    @Override\n                    public Observable<SimpleSubdocResponse> call(Subscriber s) {\n                        request.subscriber(s);\n                        return core.send(request);\n                    }\n                }).map(new Func1<SimpleSubdocResponse, DocumentFragment<Lookup>>() {\n                    @Override\n                    public DocumentFragment<Lookup> call(SimpleSubdocResponse response) {\n                        try {\n                            if (response.status().isSuccess()) {\n                                try {\n                                    long count = subdocumentTranscoder.decode(response.content(), Long.class);\n                                    SubdocOperationResult<Lookup> single = SubdocOperationResult\n                                        .createResult(spec.path(), Lookup.GET_COUNT, response.status(), count);\n                                    return new DocumentFragment<Lookup>(id, response.cas(), response.mutationToken(),\n                                        Collections.singletonList(single));\n                                } finally {\n                                    if (response.content() != null) {\n                                        response.content().release();\n                                    }\n                                }\n                            } else {\n                                if (response.content() != null && response.content().refCnt() > 0) {\n                                    response.content().release();\n                                }\n\n                                if (response.status() == ResponseStatus.SUBDOC_PATH_NOT_FOUND) {\n                                    SubdocOperationResult<Lookup> single = SubdocOperationResult\n                                        .createResult(spec.path(), Lookup.GET_COUNT, response.status(), null);\n                                    return new DocumentFragment<Lookup>(id, response.cas(), response.mutationToken(), Collections.singletonList(single));\n                                } else {\n                                    throw SubdocHelper.commonSubdocErrors(response.status(), id, spec.path());\n                                }\n                            }\n                        } finally {\n                            if (environment.operationTracingEnabled()) {\n                                environment.tracer().scopeManager()\n                                    .activate(response.request().span(), true)\n                                    .close();\n                            }\n                        }\n                    }\n                }), request, environment, timeout, timeUnit);\n            }\n        });\n    }", "comment": ""}
{"lang": "cpp", "code": "def observe_meta_signal_changes(self, changed_model, prop_name, info):\n        \"\n        self.logger.info(NotificationOverview(info))", "comment": ""}
{"lang": "cpp", "code": "protected function clearIDList()\n    {\n        $arCacheTags = $this->getCacheTagList();\n        $sCacheKey = $this->getCacheKey();\n\n        CCache::clear($arCacheTags, $sCacheKey);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getSiteRole($nb_site_role)\n    {\n        if (is_numeric($nb_role_id = nb_getMixedValue($nb_site_role, NABU_ROLE_FIELD_ID))) {\n            $retval = $this->getSiteRoles()->getItem($nb_role_id);\n        } else {\n            $retval = false;\n        }\n\n        return $retval;\n    }", "comment": ""}
{"lang": "cpp", "code": "def move_partition_replica(self, under_loaded_rg, eligible_partition):\n        \"\"\"\"\"\"\n        # Evaluate possible source and destination-broker\n        source_broker, dest_broker = self._get_eligible_broker_pair(\n            under_loaded_rg,\n            eligible_partition,\n        )\n        if source_broker and dest_broker:\n            self.log.debug(\n                'Moving partition {p_name} from broker {source_broker} to '\n                'replication-group:broker {rg_dest}:{dest_broker}'.format(\n                    p_name=eligible_partition.name,\n                    source_broker=source_broker.id,\n                    dest_broker=dest_broker.id,\n                    rg_dest=under_loaded_rg.id,\n                ),\n            )\n            # Move partition if eligible brokers found\n            source_broker.move_partition(eligible_partition, dest_broker)", "comment": ""}
{"lang": "cpp", "code": "public function setHash(string $value) : User\n    {\n\n        if ($this->data['hash'] !== $value) {\n            $this->data['hash'] = $value;\n            $this->setModified('hash');\n        }\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (cs *ConsensusState) createProposalBlock() (block *types.Block, blockParts *types.PartSet) {\n\tvar commit *types.Commit\n\tif cs.Height == 1 {\n\t\t// We're creating a proposal for the first block.\n\t\t// The commit is empty, but not nil.\n\t\tcommit = types.NewCommit(types.BlockID{}, nil)\n\t} else if cs.LastCommit.HasTwoThirdsMajority() {\n\t\t// Make the commit from LastCommit\n\t\tcommit = cs.LastCommit.MakeCommit()\n\t} else {\n\t\t// This shouldn't happen.\n\t\tcs.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block.\")\n\t\treturn\n\t}\n\n\tproposerAddr := cs.privValidator.GetPubKey().Address()\n\treturn cs.blockExec.CreateProposalBlock(cs.Height, cs.state, commit, proposerAddr)\n}", "comment": ""}
{"lang": "cpp", "code": "public function put($key, $value, $minutes)\n    {\n        $this->forever($key, $value);\n        $this->redis->expire($key, $minutes * 60);\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function createComponent($name): ?IComponent\n    {\n        $method = 'createComponent'.ucfirst($name);\n        if (method_exists($this, $method)) {\n            $this->checkRequirements(self::getReflection()->getMethod($method));\n        }\n\n        return parent::createComponent($name);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function schemaAction(Request $request)\n    {\n        $api = $this->decideApiAndEndpoint($request->getUri());\n        $this->registerProxySources($api['apiName']);\n        $this->apiLoader->addOptions($api);\n\n        $schema = $this->apiLoader->getEndpointSchema(urldecode($api['endpoint']));\n        $schema = $this->transformationHandler->transformSchema(\n            $api['apiName'],\n            $api['endpoint'],\n            $schema,\n            clone $schema\n        );\n        $response = new Response(json_encode($schema), 200);\n        $response->headers->set('Content-Type', 'application/json');\n\n        return $this->templating->renderResponse(\n            'GravitonCoreBundle:Main:index.json.twig',\n            array ('response' => $response->getContent()),\n            $response\n        );\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *Scheduler) RunAllwithDelay(d int) {\n\tfor i := 0; i < s.size; i++ {\n\t\ts.jobs[i].run()\n\t\ttime.Sleep(time.Duration(d))\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "final public String getFullName(final String parent) {\n    if (isEmptyLocalName()) {\n      return parent;\n    }\n    \n    StringBuilder fullName = new StringBuilder(parent);\n    if (!parent.endsWith(Path.SEPARATOR)) {\n      fullName.append(Path.SEPARATOR);\n    }\n    fullName.append(getLocalName());\n    return fullName.toString();\n  }", "comment": ""}
{"lang": "cpp", "code": "private function getTranslationGroups($lang = 'en'): void\n    {\n        $dir = resource_path('lang/'. $lang . '/');\n        $files = array_diff(scandir($dir), array('..', '.'));\n\n        foreach($files as $index => $filename){\n            $groupname = str_replace(\".php\", \"\", $filename);\n            $this->updateTranslationGroups($groupname);\n        }\n\n    }", "comment": ""}
{"lang": "cpp", "code": "function isLocalized($name,$lang=NULL) {\n\t\tif (!isset($lang))\n\t\t\t$lang=$this->current;\n\t\treturn !$this->isGlobal($name) && array_key_exists($name,$this->_aliases) &&\n\t\t\t\t(!isset($this->rules[$lang][$name]) || $this->rules[$lang][$name]!==FALSE);\n\t}", "comment": ""}
{"lang": "cpp", "code": "def match_files(self, matched, unmatched):\n        \"\"\"\"\"\"\n        for pattern in self.iter():\n            pattern.match_files(matched, unmatched)\n            if not unmatched:\n                # Optimization: If we have matched all files already\n                # simply return at this point - nothing else to do\n                break", "comment": ""}
{"lang": "cpp", "code": "func NewTOTP(key []byte, start uint64, step uint64, digits int, algo crypto.Hash) *TOTP {\n\th := hashFromAlgo(algo)\n\tif h == nil {\n\t\treturn nil\n\t}\n\n\treturn &TOTP{\n\t\tOATH: &OATH{\n\t\t\tkey:     key,\n\t\t\tcounter: start,\n\t\t\tsize:    digits,\n\t\t\thash:    h,\n\t\t\talgo:    algo,\n\t\t},\n\t\tstep: step,\n\t}\n\n}", "comment": ""}
{"lang": "cpp", "code": "public static String getTerminRoot(Long channelId, Long pipelineId) {\n        // \u6839\u636echannelId , pipelineId\u6784\u9020path\n        return MessageFormat.format(ArbitrateConstants.NODE_TERMIN_ROOT,\n            String.valueOf(channelId),\n            String.valueOf(pipelineId));\n    }", "comment": ""}
{"lang": "cpp", "code": "public void parse() {\n        Map<String, Disgenet> disgenetMap = new HashMap<>();\n\n        BufferedReader reader;\n        try {\n            // Disgenet file is usually downloaded as a .tar.gz file\n            if (disgenetFilePath.toFile().getName().endsWith(\"tar.gz\")) {\n                TarArchiveInputStream tarInput = new TarArchiveInputStream(\n                        new GzipCompressorInputStream(new FileInputStream(disgenetFilePath.toFile())));\n//                TarArchiveEntry currentEntry = tarInput.getNextTarEntry();\n//                BufferedReader br = null;\n                reader = new BufferedReader(new InputStreamReader(tarInput)); // Read directly from tarInput\n            } else {\n                reader = FileUtils.newBufferedReader(disgenetFilePath);\n            }\n//            if (disgenetFilePath.toFile().getName().endsWith(\"txt.gz\")) {\n//                reader = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(disgenetFilePath.toFile()))));\n//            } else {\n//                reader = Files.newBufferedReader(disgenetFilePath, Charset.defaultCharset());\n//            }\n\n            logger.info(\"Parsing Disgenet file \" + disgenetFilePath + \" ...\");\n            // first line is the header -> ignore it\n            reader.readLine();\n            long processedDisgenetLines = fillDisgenetMap(disgenetMap, reader);\n\n            logger.info(\"Serializing parsed variants ...\");\n            Collection<Disgenet> allDisgenetRecords = disgenetMap.values();\n            for (Disgenet disGeNetRecord : allDisgenetRecords) {\n                serializer.serialize(disGeNetRecord);\n            }\n            logger.info(\"Done\");\n            this.printSummary(processedDisgenetLines, allDisgenetRecords.size());\n\n        } catch (FileNotFoundException e) {\n            logger.error(\"Disgenet file \" + disgenetFilePath + \" not found\");\n        } catch (IOException e) {\n            logger.error(\"Error reading Disgenet file \" + disgenetFilePath + \": \" + e.getMessage());\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function addCommentFormAction($postId, $form = false)\n    {\n        $action = $this->container->get(CreateCommentFormAction::class);\n\n        return $action($postId, $form);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (nm *NodeMonitor) State() *models.MonitorStatus {\n\tnm.Mutex.RLock()\n\tstate := nm.state\n\tnm.Mutex.RUnlock()\n\treturn state\n}", "comment": ""}
{"lang": "cpp", "code": "public double[] solve(double[] b) {\n    if(b.length != L.length) {\n      throw new IllegalArgumentException(ERR_MATRIX_DIMENSIONS);\n    }\n    if(!isspd) {\n      throw new ArithmeticException(ERR_MATRIX_NOT_SPD);\n    }\n    // Work on a copy!\n    return solveLtransposed(solveLInplace(copy(b)));\n  }", "comment": ""}
{"lang": "cpp", "code": "@Override\n  public List<ExecutableFlow> getRunningFlows() {\n    final ArrayList<ExecutableFlow> flows = new ArrayList<>();\n    try {\n      getFlowsHelper(flows, this.executorLoader.fetchUnfinishedFlows().values());\n    } catch (final ExecutorManagerException e) {\n      logger.error(\"Failed to get running flows.\", e);\n    }\n    return flows;\n  }", "comment": ""}
{"lang": "cpp", "code": "public static function has_ongoing_request($userid, $type) {\n        global $DB;\n\n        // Check if the user already has an incomplete data request of the same type.\n        $nonpendingstatuses = [\n            self::DATAREQUEST_STATUS_COMPLETE,\n            self::DATAREQUEST_STATUS_CANCELLED,\n            self::DATAREQUEST_STATUS_REJECTED,\n            self::DATAREQUEST_STATUS_DOWNLOAD_READY,\n            self::DATAREQUEST_STATUS_EXPIRED,\n            self::DATAREQUEST_STATUS_DELETED,\n        ];\n        list($insql, $inparams) = $DB->get_in_or_equal($nonpendingstatuses, SQL_PARAMS_NAMED, 'st', false);\n        $select = \"type = :type AND userid = :userid AND status {$insql}\";\n        $params = array_merge([\n            'type' => $type,\n            'userid' => $userid\n        ], $inparams);\n\n        return data_request::record_exists_select($select, $params);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (wp WeightedPages) Prev(cur Page) Page {\n\tfor x, c := range wp {\n\t\tif c.Page == cur {\n\t\t\tif x == 0 {\n\t\t\t\treturn wp[len(wp)-1].Page\n\t\t\t}\n\t\t\treturn wp[x-1].Page\n\t\t}\n\t}\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "public static function getLocales($domain = null)\n    {\n        // Optionally filter by domain\n        $domainObj = Domain::getByDomain($domain);\n        if ($domainObj) {\n            return $domainObj->getLocales();\n        }\n\n        return Locale::getCached();\n    }", "comment": ""}
{"lang": "cpp", "code": "def to_file(self, filename=None, write_style=True):\n        \n        out = zipwrap.Zippier(filename, \"w\")\n        out.write(\"mimetype\", self.mime_type)\n        for p in self._pictures:\n            out.write(\"Pictures/%s\" % p.internal_name, p.get_data())\n        out.write(\"content.xml\", self.to_xml())\n        if write_style:\n            out.write(\"styles.xml\", self.styles_xml())\n        out.write(\"meta.xml\", self.meta_xml())\n        out.write(\"settings.xml\", self.settings_xml())\n        out.write(\"META-INF/manifest.xml\", self.manifest_xml(out))\n        return out", "comment": ""}
{"lang": "cpp", "code": "public function save($config)\n    {\n        if (!file_put_contents($this->filename, Yaml::dump($config))) {\n            return false;\n        }\n        return true;\n    }", "comment": ""}
{"lang": "cpp", "code": "def unique_bits(flags_class):\n    \n    flags_class = unique(flags_class)\n    other_bits = 0\n    for name, member in flags_class.__members_without_aliases__.items():\n        bits = int(member)\n        if other_bits & bits:\n            for other_name, other_member in flags_class.__members_without_aliases__.items():\n                if int(other_member) & bits:\n                    raise ValueError(\"%r: '%s' and '%s' have overlapping bits\" % (flags_class, other_name, name))\n        else:\n            other_bits |= bits", "comment": ""}
{"lang": "cpp", "code": "def get_labels(self, plt, label_fontsize=10):\n        \n\n        # center of vacuum and bulk region\n        if len(self.slab_regions) > 1:\n            label_in_vac = (self.slab_regions[0][1] + self.slab_regions[1][0])/2\n            if abs(self.slab_regions[0][0]-self.slab_regions[0][1]) > \\\n                    abs(self.slab_regions[1][0]-self.slab_regions[1][1]):\n                label_in_bulk = self.slab_regions[0][1]/2\n            else:\n                label_in_bulk = (self.slab_regions[1][1] + self.slab_regions[1][0]) / 2\n        else:\n            label_in_bulk = (self.slab_regions[0][0] + self.slab_regions[0][1])/2\n            if self.slab_regions[0][0] > 1-self.slab_regions[0][1]:\n                label_in_vac = self.slab_regions[0][0] / 2\n            else:\n                label_in_vac = (1 + self.slab_regions[0][1]) / 2\n\n        plt.plot([0, 1], [self.vacuum_locpot]*2, 'b--', zorder=-5, linewidth=1)\n        xy = [label_in_bulk, self.vacuum_locpot+self.ave_locpot*0.05]\n        plt.annotate(r\"$V_{vac}=%.2f$\" %(self.vacuum_locpot), xy=xy,\n                     xytext=xy, color='b', fontsize=label_fontsize)\n\n        # label the fermi energy\n        plt.plot([0, 1], [self.efermi]*2, 'g--',\n                 zorder=-5, linewidth=3)\n        xy = [label_in_bulk, self.efermi+self.ave_locpot*0.05]\n        plt.annotate(r\"$E_F=%.2f$\" %(self.efermi), xytext=xy,\n                     xy=xy, fontsize=label_fontsize, color='g')\n\n        # label the bulk-like locpot\n        plt.plot([0, 1], [self.ave_bulk_p]*2, 'r--', linewidth=1., zorder=-1)\n        xy = [label_in_vac, self.ave_bulk_p + self.ave_locpot * 0.05]\n        plt.annotate(r\"$V^{interior}_{slab}=%.2f$\" % (self.ave_bulk_p),\n                     xy=xy, xytext=xy, color='r', fontsize=label_fontsize)\n\n        # label the work function as a barrier\n        plt.plot([label_in_vac]*2, [self.efermi, self.vacuum_locpot],\n                 'k--', zorder=-5, linewidth=2)\n        xy = [label_in_vac, self.efermi + self.ave_locpot * 0.05]\n        plt.annotate(r\"$\\Phi=%.2f$\" %(self.work_function),\n                     xy=xy, xytext=xy, fontsize=label_fontsize)\n\n        return plt", "comment": ""}
{"lang": "cpp", "code": "public static function isHostKnownAliasHost($urlHost, $idSite)\n    {\n        $websiteData = Cache::getCacheWebsiteAttributes($idSite);\n\n        if (isset($websiteData['hosts'])) {\n            $canonicalHosts = array();\n            foreach ($websiteData['hosts'] as $host) {\n                $canonicalHosts[] = self::toCanonicalHost($host);\n            }\n\n            $canonicalHost = self::toCanonicalHost($urlHost);\n            if (in_array($canonicalHost, $canonicalHosts)) {\n                return true;\n            }\n        }\n\n        return false;\n    }", "comment": ""}
{"lang": "cpp", "code": "function list(scriptModule, agent, msg, cb) {\n    const servers = [];\n    const scripts = [];\n    const idMap = agent.idMap;\n\n    for (const sid in idMap) {\n        if (idMap.hasOwnProperty(sid)) {\n            servers.push(sid);\n        }\n    }\n\n    fs.readdir(scriptModule.root, (err, filenames) => {\n        if (err) {\n            filenames = [];\n        }\n        for (let i = 0, l = filenames.length; i < l; i++) {\n            scripts.push(filenames[i]);\n        }\n\n        cb(null, {\n            servers: servers,\n            scripts: scripts\n        });\n    });\n}", "comment": ""}
{"lang": "cpp", "code": "public static com.liferay.commerce.wish.list.model.CommerceWishListItem updateCommerceWishListItem(\n\t\tcom.liferay.commerce.wish.list.model.CommerceWishListItem commerceWishListItem) {\n\t\treturn getService().updateCommerceWishListItem(commerceWishListItem);\n\t}", "comment": ""}
{"lang": "cpp", "code": "public void clearKSMap() {\n        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())\n            Tr.debug(tc, \"Clearing keystore maps\");\n        synchronized (keyStoreMap) {\n            keyStoreMap.clear();\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (c *SpaceController) List(ctx *app.ListSpaceContext) error {\n\t_, err := login.ContextIdentity(ctx)\n\tif err != nil {\n\t\treturn jsonapi.JSONErrorResponse(ctx, goa.ErrUnauthorized(err.Error()))\n\t}\n\toffset, limit := computePagingLimits(ctx.PageOffset, ctx.PageLimit)\n\n\tvar response app.SpaceList\n\ttxnErr := application.Transactional(c.db, func(appl application.Application) error {\n\t\tspaces, cnt, err := appl.Spaces().List(ctx.Context, &offset, &limit)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tentityErr := ctx.ConditionalEntities(spaces, c.config.GetCacheControlSpaces, func() error {\n\t\t\tcount := int(cnt)\n\t\t\tspaceData, err := ConvertSpacesFromModel(ctx.Request, spaces, IncludeBacklogTotalCount(ctx.Context, c.db))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tresponse = app.SpaceList{\n\t\t\t\tLinks: &app.PagingLinks{},\n\t\t\t\tMeta:  &app.SpaceListMeta{TotalCount: count},\n\t\t\t\tData:  spaceData,\n\t\t\t}\n\t\t\tsetPagingLinks(response.Links, buildAbsoluteURL(ctx.Request), len(spaces), offset, limit, count)\n\t\t\treturn nil\n\t\t})\n\t\tif entityErr != nil {\n\t\t\treturn entityErr\n\t\t}\n\n\t\treturn nil\n\t})\n\tif txnErr != nil {\n\t\treturn jsonapi.JSONErrorResponse(ctx, txnErr)\n\t}\n\treturn ctx.OK(&response)\n}", "comment": ""}
{"lang": "cpp", "code": "func (c *replicationLagCache) add(r replicationLagRecord) {\n\tif !r.Up {\n\t\t// Tablet is down. Do no longer track it.\n\t\tdelete(c.entries, r.Key)\n\t\tdelete(c.ignoredSlowReplicasInARow, r.Key)\n\t\treturn\n\t}\n\n\tentry, ok := c.entries[r.Key]\n\tif !ok {\n\t\tentry = newReplicationLagHistory(c.historyCapacityPerReplica)\n\t\tc.entries[r.Key] = entry\n\t}\n\n\tentry.add(r)\n}", "comment": ""}
{"lang": "cpp", "code": "public function git($commandString)\n    {\n        // clean commands that begin with \"git \"\n        $commandString = preg_replace('/^git\\s/', '', $commandString);\n\n        $commandString = $this->options['git_executable'].' '.$commandString;\n\n        $command = new $this->options['command_class']($this->dir, $commandString, $this->debug);\n\n        return $command->run();\n    }", "comment": ""}
{"lang": "cpp", "code": "@SuppressWarnings(\"unchecked\")\n\tpublic <T> void sort(Arr arr, Comparator<T> c) {\n\t\tint l = arr.getLength();\n\t\tObject[] objs = new Object[l];\n\t\tfor (int i=0; i<l; i++) {\n\t\t\tobjs[i] = arr.get(i);\n\t\t}\n\t\tArrays.sort((T[])objs, c);\n\t\tfor (int i=0; i<l; i++) {\n\t\t\tarr.put(i, objs[i]);\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "private function _createNewCell($pCoordinate)\n\t{\n\t\t$cell = $this->_cellCollection->addCacheData(\n\t\t\t$pCoordinate,\n\t\t\tnew PHPExcel_Cell(\n\t\t\t\tNULL, \n\t\t\t\tPHPExcel_Cell_DataType::TYPE_NULL, \n\t\t\t\t$this\n\t\t\t)\n\t\t);\n        $this->_cellCollectionIsSorted = false;\n\n        // Coordinates\n        $aCoordinates = PHPExcel_Cell::coordinateFromString($pCoordinate);\n        if (PHPExcel_Cell::columnIndexFromString($this->_cachedHighestColumn) < PHPExcel_Cell::columnIndexFromString($aCoordinates[0]))\n            $this->_cachedHighestColumn = $aCoordinates[0];\n        $this->_cachedHighestRow = max($this->_cachedHighestRow, $aCoordinates[1]);\n\n        // Cell needs appropriate xfIndex from dimensions records\n\t\t//    but don't create dimension records if they don't already exist\n        $rowDimension    = $this->getRowDimension($aCoordinates[1], FALSE);\n        $columnDimension = $this->getColumnDimension($aCoordinates[0], FALSE);\n\n        if ($rowDimension !== NULL && $rowDimension->getXfIndex() > 0) {\n            // then there is a row dimension with explicit style, assign it to the cell\n            $cell->setXfIndex($rowDimension->getXfIndex());\n        } elseif ($columnDimension !== NULL && $columnDimension->getXfIndex() > 0) {\n            // then there is a column dimension, assign it to the cell\n            $cell->setXfIndex($columnDimension->getXfIndex());\n        }\n\n        return $cell;\n\t}", "comment": ""}
{"lang": "cpp", "code": "protected function checkBrowserCustom()\n    {\n        foreach ($this->_customBrowserDetection as $browserName => $customBrowser) {\n            $uaNameToLookFor = $customBrowser['uaNameToLookFor'];\n            $isMobile = $customBrowser['isMobile'];\n            $isRobot = $customBrowser['isRobot'];\n            $separator = $customBrowser['separator'];\n            $uaNameFindWords = $customBrowser['uaNameFindWords'];\n            if ($this->checkSimpleBrowserUA($uaNameToLookFor, $this->_agent, $browserName, $isMobile, $isRobot, $separator, $uaNameFindWords)) {\n                return true;\n            }\n        }\n        return false;\n    }", "comment": ""}
{"lang": "cpp", "code": "def convert(attribute=\"id\")\n        klass = persistence_class\n        object = klass.where(attribute.to_sym => self.send(attribute)).first\n\n        object ||= persistence_class.new\n\n        attributes = self.attributes.select{ |key, value| self.class.serialized_attributes.include?(key.to_s) }\n\n        attributes.delete(:id)\n\n        object.attributes = attributes\n\n        object.save\n\n        self.id = object.id\n\n        object\n      end", "comment": ""}
{"lang": "cpp", "code": "def depart_heading(self, _):\n        \n        assert isinstance(self.current_node, nodes.title)\n        # The title node has a tree of text nodes, use the whole thing to\n        # determine the section id and names\n        text = self.current_node.astext()\n        if self.translate_section_name:\n            text = self.translate_section_name(text)\n        name = nodes.fully_normalize_name(text)\n        section = self.current_node.parent\n        section['names'].append(name)\n        self.document.note_implicit_target(section, section)\n        self.current_node = section", "comment": ""}
{"lang": "cpp", "code": "public function verifyPhone(): bool\n    {\n        $phone = new UserMetaPhone($this->notification_phone);\n        $phone->verifyPhone();\n        $this->notification_phone = $phone;\n        return $this->updateModel();\n    }", "comment": ""}
{"lang": "cpp", "code": "public void run(Context context) throws IOException, InterruptedException {\n    setup(context);\n    while (context.nextKeyValue()) {\n      map(context.getCurrentKey(), context.getCurrentValue(), context);\n    }\n    cleanup(context);\n  }", "comment": ""}
{"lang": "cpp", "code": "public function addResponse($key, array $response)\n    {\n        $originalRequest = isset($this->request[$key]) ? $this->request[$key] : null;\n        $responseBody = isset($response['body']) ? $response['body'] : null;\n        $responseError = isset($response['error']) ? $response['error'] : null;\n        $responseMethod = isset($response['method']) ? $response['method'] : null;\n\n        $this->responses[$key] = new Response($originalRequest, $responseBody, $responseError, $responseMethod);\n    }", "comment": ""}
{"lang": "cpp", "code": "private function updateStorage($with = [])\n    {\n        $data = array_merge($this->data, $with);\n        $this->fs->create($this->fsPath, json_encode($data));\n    }", "comment": ""}
{"lang": "cpp", "code": "func drawCondFmtCellIs(p int, ct string, format *formatConditional) *xlsxCfRule {\n\tc := &xlsxCfRule{\n\t\tPriority: p + 1,\n\t\tType:     validType[format.Type],\n\t\tOperator: ct,\n\t\tDxfID:    &format.Format,\n\t}\n\t// \"between\" and \"not between\" criteria require 2 values.\n\t_, ok := map[string]bool{\"between\": true, \"notBetween\": true}[ct]\n\tif ok {\n\t\tc.Formula = append(c.Formula, format.Minimum)\n\t\tc.Formula = append(c.Formula, format.Maximum)\n\t}\n\t_, ok = map[string]bool{\"equal\": true, \"notEqual\": true, \"greaterThan\": true, \"lessThan\": true}[ct]\n\tif ok {\n\t\tc.Formula = append(c.Formula, format.Value)\n\t}\n\treturn c\n}", "comment": ""}
{"lang": "cpp", "code": "public static String[] trimAll(final String[] strings) {\n        if (null == strings) {\n            return null;\n        }\n\n        return Arrays.stream(strings).map(StringUtils::trim).toArray(size -> new String[size]);\n    }", "comment": ""}
{"lang": "cpp", "code": "@Override\n    public ImageSource apply(ImageSource input) {\n        int w = input.getWidth();\n        int h = input.getHeight();\n\n        MatrixSource output = new MatrixSource(input);\n\n        Vector3 n = new Vector3(0, 0, 1);\n\n        for (int y = 0; y < h; y++) {\n            for (int x = 0; x < w; x++) {\n\n                if (x < border || x == w - border || y < border || y == h - border) {\n                    output.setRGB(x, y, VectorHelper.Z_NORMAL);\n                    continue;\n                }\n\n                float s0 = input.getR(x - 1, y + 1);\n                float s1 = input.getR(x, y + 1);\n                float s2 = input.getR(x + 1, y + 1);\n                float s3 = input.getR(x - 1, y);\n                float s5 = input.getR(x + 1, y);\n                float s6 = input.getR(x - 1, y - 1);\n                float s7 = input.getR(x, y - 1);\n                float s8 = input.getR(x + 1, y - 1);\n\n                float nx = -(s2 - s0 + 2 * (s5 - s3) + s8 - s6);\n                float ny = -(s6 - s0 + 2 * (s7 - s1) + s8 - s2);\n\n                n.set(nx, ny, scale);\n                n.nor();\n\n                int rgb = VectorHelper.vectorToColor(n);\n                output.setRGB(x, y, rgb);\n            }\n        }\n\n        return new MatrixSource(output);\n    }", "comment": ""}
{"lang": "cpp", "code": "def _change_soi(self, body):\n        \n\n        if body == self.central:\n            self.bodies = [self.central]\n            self.step = self.central_step\n            self.active = self.central.name\n            self.frame = self.central.name\n        else:\n            soi = self.SOI[body.name]\n            self.bodies = [body]\n            self.step = self.alt_step\n            self.active = body.name\n            self.frame = soi.frame", "comment": ""}
{"lang": "cpp", "code": "protected function generateLicense()\n    {\n        $command = $this->prepareSignCommand() . ' 2>&1';\n\n        $this->log('Creating license at ' . $this->outputFile);\n\n        $this->log('Running: ' . $command, Project::MSG_VERBOSE);\n        $tmp = exec($command, $output, $return_var);\n\n        // Check for exit value 1. Zendenc_sign command for some reason\n        // returns 0 in case of failure and 1 in case of success...\n        if ($return_var !== 1) {\n            throw new BuildException(\"Creating license failed. \\n\\nZendenc_sign msg:\\n\" . implode(\n                \"\\n\",\n                $output\n            ) . \"\\n\\n\");\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public boolean isCompensationHandler() {\n    Boolean isForCompensation = (Boolean) getProperty(BpmnParse.PROPERTYNAME_IS_FOR_COMPENSATION);\n    return Boolean.TRUE.equals(isForCompensation);\n  }", "comment": ""}
{"lang": "cpp", "code": "public function setElements(array $elements)\n    {\n        $this->elements = [];\n        foreach ($elements as $name => $element) {\n            $this->setElement($name, $element);\n        }\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function setPartial($partial)\n    {\n        if (null === $partial || is_string($partial) || is_array($partial)) {\n            $this->partial = $partial;\n        }\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "def add_migrations(self, migrations):\n        \n        if self.__closed:\n            raise MigrationSessionError(\"Can't change applied session\")\n        self._to_apply.extend(migrations)", "comment": ""}
{"lang": "cpp", "code": "public function getBaseBasketPriceForPaymentCostCalc($oBasket)\n    {\n        $dBasketPrice = 0;\n        $iRules = $this->oxpayments__oxaddsumrules->value;\n\n        // products brutto price\n        if (!$iRules || ($iRules & self::PAYMENT_ADDSUMRULE_ALLGOODS)) {\n            $dBasketPrice += $oBasket->getProductsPrice()->getSum($oBasket->isCalculationModeNetto());\n        }\n\n        // discounts\n        if ((!$iRules || ($iRules & self::PAYMENT_ADDSUMRULE_DISCOUNTS)) &&\n            ($oCosts = $oBasket->getTotalDiscount())\n        ) {\n            $dBasketPrice -= $oCosts->getPrice();\n        }\n\n        // vouchers\n        if (!$iRules || ($iRules & self::PAYMENT_ADDSUMRULE_VOUCHERS)) {\n            $dBasketPrice -= $oBasket->getVoucherDiscValue();\n        }\n\n        // delivery\n        if ((!$iRules || ($iRules & self::PAYMENT_ADDSUMRULE_SHIPCOSTS)) &&\n            ($oCosts = $oBasket->getCosts('oxdelivery'))\n        ) {\n            if ($oBasket->isCalculationModeNetto()) {\n                $dBasketPrice += $oCosts->getNettoPrice();\n            } else {\n                $dBasketPrice += $oCosts->getBruttoPrice();\n            }\n        }\n\n        // wrapping\n        if (($iRules & self::PAYMENT_ADDSUMRULE_GIFTS) &&\n            ($oCosts = $oBasket->getCosts('oxwrapping'))\n        ) {\n            if ($oBasket->isCalculationModeNetto()) {\n                $dBasketPrice += $oCosts->getNettoPrice();\n            } else {\n                $dBasketPrice += $oCosts->getBruttoPrice();\n            }\n        }\n\n        // gift card\n        if (($iRules & self::PAYMENT_ADDSUMRULE_GIFTS) &&\n            ($oCosts = $oBasket->getCosts('oxgiftcard'))\n        ) {\n            if ($oBasket->isCalculationModeNetto()) {\n                $dBasketPrice += $oCosts->getNettoPrice();\n            } else {\n                $dBasketPrice += $oCosts->getBruttoPrice();\n            }\n        }\n\n        return $dBasketPrice;\n    }", "comment": ""}
{"lang": "cpp", "code": "@Override\n\tpublic boolean removeArc(int x, int y, ICause cause) throws ContradictionException {\n\t\tassert cause != null;\n\t\tif (LB.arcExists(x, y)) {\n\t\t\tthis.contradiction(cause, \"remove mandatory arc \" + x + \"->\" + y);\n\t\t\treturn false;\n\t\t}\n\t\tif (UB.removeArc(x, y)) {\n\t\t\tif (reactOnModification) {\n\t\t\t\tdelta.add(x, GraphDelta.AR_TAIL, cause);\n\t\t\t\tdelta.add(y, GraphDelta.AR_HEAD, cause);\n\t\t\t}\n\t\t\tGraphEventType e = GraphEventType.REMOVE_ARC;\n\t\t\tnotifyPropagators(e, cause);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (cli *Client) GetAvatarURL() (url string, err error) {\n\turlPath := cli.BuildURL(\"profile\", cli.UserID, \"avatar_url\")\n\ts := struct {\n\t\tAvatarURL string `json:\"avatar_url\"`\n\t}{}\n\n\t_, err = cli.MakeRequest(\"GET\", urlPath, nil, &s)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn s.AvatarURL, nil\n}", "comment": ""}
{"lang": "cpp", "code": "func ParseToRawMap(fileName string) (cfg RawMap, err error) {\n\tvar file *os.File\n\n\tcfg = make(RawMap, 0)\n\tfile, err = os.Open(fileName)\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer file.Close()\n\tscanner := bufio.NewScanner(file)\n\n\tvar currentSection string\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\tif commentLine.MatchString(line) {\n\t\t\tcontinue\n\t\t} else if blankLine.MatchString(line) {\n\t\t\tcontinue\n\t\t} else if configSection.MatchString(line) {\n\t\t\tsection := configSection.ReplaceAllString(line, \"$1\")\n\t\t\tif !cfg.SectionInConfig(section) {\n\t\t\t\tcfg[section] = make(map[string]string, 0)\n\t\t\t}\n\t\t\tcurrentSection = section\n\t\t} else if configLine.MatchString(line) {\n\t\t\tregex := configLine\n\t\t\tif quotedConfigLine.MatchString(line) {\n\t\t\t\tregex = quotedConfigLine\n\t\t\t}\n\t\t\tif currentSection == \"\" {\n\t\t\t\tcurrentSection = defaultSection\n\t\t\t\tif !cfg.SectionInConfig(currentSection) {\n\t\t\t\t\tcfg[currentSection] = make(map[string]string, 0)\n\t\t\t\t}\n\t\t\t}\n\t\t\tkey := regex.ReplaceAllString(line, \"$1\")\n\t\t\tval := regex.ReplaceAllString(line, \"$2\")\n\t\t\tcfg[currentSection][key] = val\n\t\t} else {\n\t\t\terr = fmt.Errorf(\"invalid config file\")\n\t\t\tbreak\n\t\t}\n\t}\n\treturn\n}", "comment": ""}
{"lang": "cpp", "code": "protected function flush($maxBufferLevel = null)\n    {\n        if (null === $maxBufferLevel) {\n            $maxBufferLevel = ob_get_level();\n        }\n\n        while (ob_get_level() > $maxBufferLevel) {\n            ob_end_flush();\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public void scalarMultiply(double c)\r\n    {\r\n        int m = rows;\r\n        int n = cols;\r\n        for (int i = 0; i < m; i++)\r\n        {\r\n            for (int j = 0; j < n; j++)\r\n            {\r\n                consumer.set(i, j, c * supplier.get(i, j));\r\n            }\r\n        }\r\n    }", "comment": ""}
{"lang": "cpp", "code": "private void freeAllocatedSpace(java.util.Collection sortedFreeSpaceList)\n    {\n        if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())\n            trace.entry(this,\n                        cclass,\n                        \"freeAllocatedSpace\",\n                        new Object[] { new Integer(sortedFreeSpaceList.size()), new Long(freeSpaceByLength.size()) });\n\n        // Remove from the head of the sorted set until we find the first non-negative\n        // address - indicating that the storage was allocated\n        java.util.Iterator listIterator = sortedFreeSpaceList.iterator();\n        Directory.StoreArea currentArea = null;\n        while (listIterator.hasNext()) {\n            currentArea = (Directory.StoreArea) listIterator.next();\n            if (currentArea.byteAddress > 0)\n                break;\n        }\n\n        // Did we find at least one to merge?\n        if (currentArea != null) {\n\n            // We now have a pointer to the first store area in the sorted list\n            // that needs to be merged into the free space map.\n            // We iterate through the free space map (which is also in order)\n            // merging the entries in, and moving our pointer forwards.\n            FreeSpace spaceEntry = freeSpaceByAddressHead;\n            FreeSpace previousEntry = null;\n            do {\n                // If spaceEntry is null then we have reached the end of the list.\n                // We handle this case first, because we can avoid null-checks in\n                // other branches.\n                // The same logic is used to handle the case where we have moved\n                // past the point in the address-sorted free space list where this\n                // entry would be merged, and did not find any existing entries\n                // to merge it with. Merging would have been performed in branches\n                // below on an earlier pass round the loop if it was possible (as\n                // we would have looked at the entry that is now spaceEntry as        \n                // spaceEntry.next in the below branches).\n                if (spaceEntry == null || // Tail of list reached\n                    spaceEntry.address > currentArea.byteAddress // Moved past insertion point without merge\n                ) {\n                    // Create a new entry, unless this is a zero-sized entry\n                    if (currentArea.length > 0) {\n                        FreeSpace newSpaceEntry =\n                                        new FreeSpace(currentArea.byteAddress, currentArea.length);\n\n                        // Link it in behind the current entry\n                        newSpaceEntry.next = spaceEntry;\n                        if (previousEntry != null) {\n                            previousEntry.next = newSpaceEntry;\n                        }\n                        else {\n                            // We are the new head\n                            freeSpaceByAddressHead = newSpaceEntry;\n                        }\n                        newSpaceEntry.prev = previousEntry;\n                        if (spaceEntry != null) {\n                            spaceEntry.prev = newSpaceEntry;\n                        }\n\n                        // Add our extended entry into the length-sorted list\n                        freeSpaceByLength.add(newSpaceEntry);\n\n                        // Debug freespace list\n                        // if (Tracing.isAnyTracingEnabled() && trace.isDebugEnabled()) trace.debug(this, cclass, methodName, \"ADD to freespace list\");\n\n                        // Keep track of the maximum free space count as a statistic\n                        if (gatherStatistics && freeSpaceByLength.size() > maxFreeSpaceCount)\n                            maxFreeSpaceCount = freeSpaceByLength.size();\n\n                        // As we've added a new entry before the current on, we should use it next time round\n                        spaceEntry = newSpaceEntry;\n                        // Previous entry stayed the same - as we've inserted without moving forwards\n                    }\n                    // Regardless of whether we added an entry, move onto the next store area and\n                    // go back round the loop.\n                    if (listIterator.hasNext()) {\n                        currentArea = (Directory.StoreArea) listIterator.next();\n                    }\n                    else\n                        currentArea = null; // We've run out of entries to merge\n                }\n                // Can our current store entry be merged with the current free space entry.\n                else if (spaceEntry.address + spaceEntry.length == currentArea.byteAddress) {\n                    // We can merge this entry with the one before it.\n                    // Remove from the length-sorted list and change the size\n                    freeSpaceByLength.remove(spaceEntry);\n                    spaceEntry.length += currentArea.length;\n\n                    // Can we also merge it with the one after it?\n                    FreeSpace nextSpaceEntry = spaceEntry.next;\n                    if (nextSpaceEntry != null &&\n                        currentArea.byteAddress + currentArea.length == nextSpaceEntry.address) {\n                        // Remove the eliminated space entry from the length-sorted list\n                        freeSpaceByLength.remove(nextSpaceEntry);\n\n                        // Debug freespace list\n                        // if (Tracing.isAnyTracingEnabled() && trace.isDebugEnabled()) trace.debug(this, cclass, methodName, \"REMOVE from freespace list\");\n\n                        // Make the previous one larger\n                        spaceEntry.length += nextSpaceEntry.length;\n                        // Remove the next one\n                        spaceEntry.next = nextSpaceEntry.next;\n                        if (nextSpaceEntry.next != null) {\n                            nextSpaceEntry.next.prev = spaceEntry;\n                        }\n                    }\n\n                    // Add our extended entry into the length-sorted list\n                    freeSpaceByLength.add(spaceEntry);\n\n                    // We've merged this store entry now, so move onto the next one\n                    // in the sorted list.\n                    if (listIterator.hasNext()) {\n                        currentArea = (Directory.StoreArea) listIterator.next();\n                    }\n                    else\n                        currentArea = null; // We've run out of entries to merge\n                    // Note we do not advance our position in the free space, as the\n                    // current entry could also be of interest to the next store item.\n                }\n                // Can our current store entry be merged with the next free space entry\n                // (note that the case where it merges with both is already handled).\n                else if (spaceEntry.next != null &&\n                         currentArea.byteAddress + currentArea.length == spaceEntry.next.address) {\n                    // Remove from the length-sorted list and change the size\n                    FreeSpace nextSpaceEntry = spaceEntry.next;\n                    freeSpaceByLength.remove(nextSpaceEntry);\n                    nextSpaceEntry.address = currentArea.byteAddress;\n                    nextSpaceEntry.length += currentArea.length;\n\n                    // Add back into the length-sorted list\n                    freeSpaceByLength.add(nextSpaceEntry);\n\n                    // We've merged this store entry now, so move onto the next one\n                    // in the sorted list.\n                    if (listIterator.hasNext()) {\n                        currentArea = (Directory.StoreArea) listIterator.next();\n                    }\n                    else\n                        currentArea = null; // We've run out of entries to merge\n                    // Note we do not advance our position in the free space, as the\n                    // current entry could also be of interest to the next store item.\n                }\n                // Otherwise this space entry is not interesting to us, and we\n                // can simply move onto the next one.\n                else {\n                    previousEntry = spaceEntry;\n                    spaceEntry = spaceEntry.next;\n                }\n                // Although looping through the free space map, our condition for\n                // breaking the loop is when we've run out of entries to merge.\n            } while (currentArea != null);\n        }\n\n        if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())\n            trace.exit(this,\n                       cclass,\n                       \"freeAllocatedSpace\",\n                       new Object[] { new Long(freeSpaceByLength.size()) });\n    }", "comment": ""}
{"lang": "cpp", "code": "private AFPChain alignRight(Atom[] ca1, Atom[] ca2, CECPParameters cpparams)\n\t\t\tthrows StructureException {\n\t\tlong startTime = System.currentTimeMillis();\n\n\t\tAtom[] ca2m = StructureTools.duplicateCA2(ca2);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Duplicating ca2 took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\t// Do alignment\n\t\tAFPChain afpChain = super.align(ca1, ca2m,params);\n\n\t\t// since the process of creating ca2m strips the name info away, set it explicitely\n\t\ttry {\n\t\t\tafpChain.setName2(ca2[0].getGroup().getChain().getStructure().getName());\n\t\t} catch( Exception e) {}\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Running %dx2*%d alignment took %s ms\\n\",ca1.length,ca2.length,System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\t\tafpChain = postProcessAlignment(afpChain, ca1, ca2m, calculator, cpparams);\n\n\t\tif(debug) {\n\t\t\tSystem.out.format(\"Finding CP point took %s ms\\n\",System.currentTimeMillis()-startTime);\n\t\t\tstartTime = System.currentTimeMillis();\n\t\t}\n\n\t\treturn afpChain;\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function skipDiscounts()\n    {\n        // already loaded skip discounts config\n        if ($this->_blSkipDiscounts !== null) {\n            return $this->_blSkipDiscounts;\n        }\n\n        if ($this->oxarticles__oxskipdiscounts->value) {\n            return true;\n        }\n\n\n        $this->_blSkipDiscounts = false;\n        if (\\OxidEsales\\Eshop\\Core\\Registry::get(\\OxidEsales\\Eshop\\Application\\Model\\DiscountList::class)->hasSkipDiscountCategories()) {\n            $oDb = \\OxidEsales\\Eshop\\Core\\DatabaseProvider::getDb();\n            $sO2CView = getViewName('oxobject2category', $this->getLanguage());\n            $sViewName = getViewName('oxcategories', $this->getLanguage());\n            $sSelect = \"select 1 from $sO2CView as $sO2CView left join {$sViewName} on {$sViewName}.oxid = $sO2CView.oxcatnid\n                         where $sO2CView.oxobjectid=\" . $oDb->quote($this->getId()) . \" and {$sViewName}.oxactive = 1 and {$sViewName}.oxskipdiscounts = '1' \";\n            $this->_blSkipDiscounts = ($oDb->getOne($sSelect) == 1);\n        }\n\n        return $this->_blSkipDiscounts;\n    }", "comment": ""}
{"lang": "cpp", "code": "def prod(self, **kwargs):\n        \n        if self._is_transposed:\n            kwargs[\"axis\"] = kwargs.get(\"axis\", 0) ^ 1\n            return self.transpose().prod(**kwargs)\n        return self._process_sum_prod(\n            self._build_mapreduce_func(pandas.DataFrame.prod, **kwargs), **kwargs\n        )", "comment": ""}
{"lang": "cpp", "code": "public void setRoundedCorners(final boolean ROUNDED) {\n        if (null == roundedCorners) {\n            _roundedCorners = ROUNDED;\n            fireTileEvent(REDRAW_EVENT);\n        } else {\n            roundedCorners.set(ROUNDED);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getControl()\n\t{\n\t\t$control = parent::getControl();\n\t\t$control->type = $this->htmlType;\n\t\t$control->addClass($this->htmlType);\n\n\t\tlist($min, $max) = $this->extractRangeRule($this->getRules());\n\t\tif ($min instanceof DateTimeInterface) {\n\t\t\t$control->min = $min->format($this->htmlFormat);\n\t\t}\n\t\tif ($max instanceof DateTimeInterface) {\n\t\t\t$control->max = $max->format($this->htmlFormat);\n\t\t}\n\t\t$value = $this->getValue();\n\t\tif ($value instanceof DateTimeInterface) {\n\t\t\t$control->value = $value->format($this->htmlFormat);\n\t\t}\n\n\t\treturn $control;\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (s *StartBuildInput) SetTimeoutInMinutesOverride(v int64) *StartBuildInput {\n\ts.TimeoutInMinutesOverride = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public void marshall(MethodSnapshot methodSnapshot, ProtocolMarshaller protocolMarshaller) {\n\n        if (methodSnapshot == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(methodSnapshot.getAuthorizationType(), AUTHORIZATIONTYPE_BINDING);\n            protocolMarshaller.marshall(methodSnapshot.getApiKeyRequired(), APIKEYREQUIRED_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def _GetMetric(self, metric_name):\n    \"\"\"\"\"\"\n    if metric_name in self._counter_metrics:\n      return self._counter_metrics[metric_name]\n    elif metric_name in self._event_metrics:\n      return self._event_metrics[metric_name]\n    elif metric_name in self._gauge_metrics:\n      return self._gauge_metrics[metric_name]\n    else:\n      raise ValueError(\"Metric %s is not registered.\" % metric_name)", "comment": ""}
{"lang": "cpp", "code": "public function downloadFeedItem(models\\Download\\Feed\\DownloadFeedItem $DownloadFeedItem)\n    {\n        $service = sprintf(self::API_DOWNLOAD_FEEDS_ITEMS_ITEM_DOWNLOAD, $DownloadFeedItem->getFeedId(), $DownloadFeedItem->getId());\n        $rest    = $this->callService('POST', $service, $DownloadFeedItem);\n\n        return $rest->getSuccess();\n    }", "comment": ""}
{"lang": "cpp", "code": "def end(self, close_fileobj=True):\n        \"\"\"\"\"\"\n        log.debug(\"in TftpContext.end - closing socket\")\n        self.sock.close()\n        if close_fileobj and self.fileobj is not None and not self.fileobj.closed:\n            log.debug(\"self.fileobj is open - closing\")\n            self.fileobj.close()", "comment": ""}
{"lang": "cpp", "code": "def find_module(modpath):\n    \"\"\"\"\"\"\n    module_path = modpath.replace('.', '/') + '.py'\n    init_path = modpath.replace('.', '/') + '/__init__.py'\n    for root_path in sys.path:\n        path = os.path.join(root_path, module_path)\n        if os.path.isfile(path):\n            return path\n        path = os.path.join(root_path, init_path)\n        if os.path.isfile(path):\n            return path", "comment": ""}
{"lang": "cpp", "code": "public function submit($controller)\n    {\n        set_time_limit(0);\n\n        // Download method calls exit() so clean session here\n        $this->session->delete('file_manager_selected');\n\n        $destination = $this->file->getTempFile();\n        $files = $controller->getSubmitted('files');\n\n        /* @var $file \\SplFileInfo */\n        $file = reset($files);\n\n        $path = $file->getRealPath();\n        $filename = $file->getBasename();\n\n        if ($file->isFile()) {\n            $result = $this->zip->file($path, $destination);\n        } else if ($file->isDir()) {\n            $result = $this->zip->directory($path, $destination, $filename);\n        }\n\n        if (!empty($result)) {\n            $controller->download($destination, \"$filename.zip\");\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def get_bounds(self):\n        \n\n        size = self.get_size()\n        top_left = self.get_position([0, 0])\n\n        # t, r, b, l\n        bounds = [top_left[1], top_left[0] + size[0], top_left[1] + size[1], top_left[0]]\n        return bounds", "comment": ""}
{"lang": "cpp", "code": "private Predicate<HelpPage> query(final Predicate<HelpPage> predicate) {\n    Predicate<HelpPage> query = predicate;\n\n    if (includeAll == null || !includeAll) {\n      if (includeAliases != null && !includeAliases) {\n        query = query.and(TypePredicate.of(AliasHelpPage.class).negate());\n      }\n      if (includeMeta != null && !includeMeta) {\n        query = query.and(TypePredicate.of(MetaHelpPage.class).negate());\n      }\n      if (includeCommands != null && !includeCommands) {\n        query = query.and(TypePredicate.of(CommandHelpPage.class).negate());\n      }\n      if (includeGroups != null && !includeGroups) {\n        query = query.and(TypePredicate.of(GroupHelpPage.class).negate());\n      }\n    }\n\n    return query;\n  }", "comment": ""}
{"lang": "cpp", "code": "public INDArray scoreExamples(DataSetIterator iter, boolean addRegularizationTerms) {\n        List<INDArray> out = new ArrayList<>();\n\n        while (iter.hasNext()) {\n            out.add(scoreExamples(iter.next(), addRegularizationTerms));\n        }\n        return Nd4j.toFlattened('f', out);\n    }", "comment": ""}
{"lang": "cpp", "code": "@Restricted(NoExternalUse.class)\n    public static @Nonnull JenkinsLocationConfiguration getOrDie(){\n        JenkinsLocationConfiguration config = JenkinsLocationConfiguration.get();\n        if (config == null) {\n            throw new IllegalStateException(\"JenkinsLocationConfiguration instance is missing. Probably the Jenkins instance is not fully loaded at this time.\");\n        }\n        return config;\n    }", "comment": ""}
{"lang": "cpp", "code": "func New(id manifold.ID) (string, string) {\n\tidBytes := id[2:]\n\n\toffset := 0\n\tadj, offset := fetchWord(idBytes, data.Adjectives, offset, aShare)\n\tcolor, offset := fetchWord(idBytes, data.Colors, offset, cShare)\n\tshape, _ := fetchWord(idBytes, data.Shapes, offset, sShare)\n\n\tname := strings.Title(adj + \" \" + color + \" \" + shape)\n\tlabel := strings.Replace(strings.ToLower(name), \" \", \"-\", -1)\n\treturn name, label\n}", "comment": ""}
{"lang": "cpp", "code": "@Override\n    public void addDataObserver(Observer<DataProvider<M>, M> observer) {\n        dataObserver.addObserver(observer);\n    }", "comment": ""}
{"lang": "cpp", "code": "public double costOfPointToCenter(Point centre){\n\t\tif(this.weight == 0.0){\n\t\t\treturn 0.0;\n\t\t}\n\n\t\t//stores the distance between p and centre\n\t\tdouble distance = 0.0;\n\n\t\t//loop counter\n\t\tfor(int l=0; l<this.dimension; l++){\n\t\t\t//Centroid coordinate of the point\n\t\t\tdouble centroidCoordinatePoint;\n\t\t\tif(this.weight != 0.0){\n\t\t\t\tcentroidCoordinatePoint = this.coordinates[l] / this.weight;\n\t\t\t} else {\n\t\t\t\tcentroidCoordinatePoint = this.coordinates[l];\n\t\t\t}\n\t\t\t//Centroid coordinate of the centre\n\t\t\tdouble centroidCoordinateCentre;\n\t\t\tif(centre.weight != 0.0){\n\t\t\t\tcentroidCoordinateCentre = centre.coordinates[l] / centre.weight;\n\t\t\t} else {\n\t\t\t\tcentroidCoordinateCentre = centre.coordinates[l];\n\t\t\t}\n\t\t\tdistance += (centroidCoordinatePoint-centroidCoordinateCentre) * \n\t\t\t\t\t(centroidCoordinatePoint-centroidCoordinateCentre) ;\n\t\t\t\t\t\n\t\t}\n\t\treturn distance * this.weight;\n\t}", "comment": ""}
{"lang": "cpp", "code": "public static void setTrace(boolean trace) {\n        FallbackLoggerConfiguration.trace.set(trace);\n        if (trace) {\n            debug.set(true);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function forceSave(array $rules = array(),\n        array $customMessages = array(),\n        array $options = array(),\n        Closure $beforeSave = null,\n        Closure $afterSave = null\n    ) {\n        return $this->internalSave($rules, $customMessages, $options, $beforeSave, $afterSave, true);\n    }", "comment": ""}
{"lang": "cpp", "code": "public DataType resolveProperty(DataType sourceType, String identifier, boolean mustResolve) {\n        DataType currentType = sourceType;\n        while (currentType != null) {\n            if (currentType instanceof ClassType) {\n                ClassType classType = (ClassType)currentType;\n                for (ClassTypeElement e : classType.getElements()) {\n                    if (e.getName().equals(identifier)) {\n                        if (e.isProhibited()) {\n                            throw new IllegalArgumentException(String.format(\"Element %s cannot be referenced because it is marked prohibited in type %s.\", e.getName(), ((ClassType) currentType).getName()));\n                        }\n\n                        return e.getType();\n                    }\n                }\n            }\n            else if (currentType instanceof TupleType) {\n                TupleType tupleType = (TupleType)currentType;\n                for (TupleTypeElement e : tupleType.getElements()) {\n                    if (e.getName().equals(identifier)) {\n                        return e.getType();\n                    }\n                }\n            }\n            else if (currentType instanceof IntervalType) {\n                IntervalType intervalType = (IntervalType)currentType;\n                switch (identifier) {\n                    case \"low\":\n                    case \"high\":\n                        return intervalType.getPointType();\n                    case \"lowClosed\":\n                    case \"highClosed\":\n                        return resolveTypeName(\"System\", \"Boolean\");\n                    default:\n                        // ERROR:\n                        throw new IllegalArgumentException(String.format(\"Invalid interval property name %s.\", identifier));\n                }\n            }\n            else if (currentType instanceof ChoiceType) {\n                ChoiceType choiceType = (ChoiceType)currentType;\n                // TODO: Issue a warning if the property does not resolve against every type in the choice\n\n                // Resolve the property against each type in the choice\n                Set<DataType> resultTypes = new HashSet<>();\n                for (DataType choice : choiceType.getTypes()) {\n                    DataType resultType = resolveProperty(choice, identifier, false);\n                    if (resultType != null) {\n                        resultTypes.add(resultType);\n                    }\n                }\n\n                // The result type is a choice of all the resolved types\n                if (resultTypes.size() > 1) {\n                    return new ChoiceType(resultTypes);\n                }\n\n                if (resultTypes.size() == 1) {\n                    for (DataType resultType : resultTypes) {\n                        return resultType;\n                    }\n                }\n            }\n            else if (currentType instanceof ListType && listTraversal) {\n                // NOTE: FHIRPath path traversal support\n                // Resolve property as a list of items of property of the element type\n                ListType listType = (ListType)currentType;\n                DataType resultType = resolveProperty(listType.getElementType(), identifier);\n                return new ListType(resultType);\n\n            }\n\n            if (currentType.getBaseType() != null) {\n                currentType = currentType.getBaseType();\n            }\n            else {\n                break;\n            }\n        }\n\n        if (mustResolve) {\n            // ERROR:\n            throw new IllegalArgumentException(String.format(\"Member %s not found for type %s.\", identifier, sourceType != null ? sourceType.toLabel() : null));\n        }\n\n        return null;\n    }", "comment": ""}
{"lang": "cpp", "code": "def plot_images(images, ax, ims_per_row=5, padding=5, digit_dimensions=(28, 28),\n                cmap=matplotlib.cm.binary, vmin=None, vmax=None):\n    \"\"\"\"\"\"\n    N_images = images.shape[0]\n    N_rows = (N_images - 1) // ims_per_row + 1\n    pad_value = np.min(images.ravel())\n    concat_images = np.full(((digit_dimensions[0] + padding) * N_rows + padding,\n                             (digit_dimensions[1] + padding) * ims_per_row + padding), pad_value)\n    for i in range(N_images):\n        cur_image = np.reshape(images[i, :], digit_dimensions)\n        row_ix = i // ims_per_row\n        col_ix = i % ims_per_row\n        row_start = padding + (padding + digit_dimensions[0]) * row_ix\n        col_start = padding + (padding + digit_dimensions[1]) * col_ix\n        concat_images[row_start: row_start + digit_dimensions[0],\n                      col_start: col_start + digit_dimensions[1]] = cur_image\n    cax = ax.matshow(concat_images, cmap=cmap, vmin=vmin, vmax=vmax)\n    plt.xticks(np.array([]))\n    plt.yticks(np.array([]))\n    return cax", "comment": ""}
{"lang": "cpp", "code": "public static void checkSvdMatrixSize(DMatrixRMaj U, boolean tranU, DMatrixRMaj W, DMatrixRMaj V, boolean tranV ) {\n        int numSingular = Math.min(W.numRows,W.numCols);\n        boolean compact = W.numRows == W.numCols;\n\n        if( compact ) {\n            if( U != null ) {\n                if( tranU && U.numRows != numSingular )\n                    throw new IllegalArgumentException(\"Unexpected size of matrix U\");\n                else if( !tranU && U.numCols != numSingular )\n                    throw new IllegalArgumentException(\"Unexpected size of matrix U\");\n            }\n\n            if( V != null ) {\n            if( tranV && V.numRows != numSingular )\n                throw new IllegalArgumentException(\"Unexpected size of matrix V\");\n            else if( !tranV && V.numCols != numSingular )\n                throw new IllegalArgumentException(\"Unexpected size of matrix V\");\n            }\n        } else {\n            if( U != null && U.numRows != U.numCols )\n                throw new IllegalArgumentException(\"Unexpected size of matrix U\");\n            if( V != null && V.numRows != V.numCols )\n                throw new IllegalArgumentException(\"Unexpected size of matrix V\");\n            if( U != null && U.numRows != W.numRows )\n                throw new IllegalArgumentException(\"Unexpected size of W\");\n            if( V != null && V.numRows != W.numCols )\n                throw new IllegalArgumentException(\"Unexpected size of W\");\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (dec *ProtoDecoder) Reset(r io.Reader) {\n\tdec.pBuf.Reset()\n\tdec.bBuf.Reset()\n\tdec.r = r\n}", "comment": ""}
{"lang": "cpp", "code": "func (s *Server) isAuditedAtProxy() bool {\n\t// always be safe, better to double record than not record at all\n\tclusterConfig, err := s.GetAccessPoint().GetClusterConfig()\n\tif err != nil {\n\t\treturn false\n\t}\n\n\tisRecordAtProxy := clusterConfig.GetSessionRecording() == services.RecordAtProxy\n\tisTeleportNode := s.Component() == teleport.ComponentNode\n\n\tif isRecordAtProxy && isTeleportNode {\n\t\treturn true\n\t}\n\treturn false\n}", "comment": ""}
{"lang": "cpp", "code": "def _sync_table(self, columns):\n        \"\"\"\"\"\"\n        if self._table is None:\n            # Load an existing table from the database.\n            self._reflect_table()\n        if self._table is None:\n            # Create the table with an initial set of columns.\n            if not self._auto_create:\n                raise DatasetException(\"Table does not exist: %s\" % self.name)\n            # Keep the lock scope small because this is run very often.\n            with self.db.lock:\n                self._threading_warn()\n                self._table = SQLATable(self.name,\n                                        self.db.metadata,\n                                        schema=self.db.schema)\n                if self._primary_id is not False:\n                    # This can go wrong on DBMS like MySQL and SQLite where\n                    # tables cannot have no columns.\n                    primary_id = self._primary_id or self.PRIMARY_DEFAULT\n                    primary_type = self._primary_type or Types.integer\n                    increment = primary_type in [Types.integer, Types.bigint]\n                    column = Column(primary_id, primary_type,\n                                    primary_key=True,\n                                    autoincrement=increment)\n                    self._table.append_column(column)\n                for column in columns:\n                    if not column.name == self._primary_id:\n                        self._table.append_column(column)\n                self._table.create(self.db.executable, checkfirst=True)\n        elif len(columns):\n            with self.db.lock:\n                self._reflect_table()\n                self._threading_warn()\n                for column in columns:\n                    if not self.has_column(column.name):\n                        self.db.op.add_column(self.name, column, self.db.schema)\n                self._reflect_table()", "comment": ""}
{"lang": "cpp", "code": "func NewCiliumHealthAPI(spec *loads.Document) *CiliumHealthAPI {\n\treturn &CiliumHealthAPI{\n\t\thandlers:            make(map[string]map[string]http.Handler),\n\t\tformats:             strfmt.Default,\n\t\tdefaultConsumes:     \"application/json\",\n\t\tdefaultProduces:     \"application/json\",\n\t\tcustomConsumers:     make(map[string]runtime.Consumer),\n\t\tcustomProducers:     make(map[string]runtime.Producer),\n\t\tServerShutdown:      func() {},\n\t\tspec:                spec,\n\t\tServeError:          errors.ServeError,\n\t\tBasicAuthenticator:  security.BasicAuth,\n\t\tAPIKeyAuthenticator: security.APIKeyAuth,\n\t\tBearerAuthenticator: security.BearerAuth,\n\t\tJSONConsumer:        runtime.JSONConsumer(),\n\t\tJSONProducer:        runtime.JSONProducer(),\n\t\tGetHealthzHandler: GetHealthzHandlerFunc(func(params GetHealthzParams) middleware.Responder {\n\t\t\treturn middleware.NotImplemented(\"operation GetHealthz has not yet been implemented\")\n\t\t}),\n\t\tGetHelloHandler: GetHelloHandlerFunc(func(params GetHelloParams) middleware.Responder {\n\t\t\treturn middleware.NotImplemented(\"operation GetHello has not yet been implemented\")\n\t\t}),\n\t\tConnectivityGetStatusHandler: connectivity.GetStatusHandlerFunc(func(params connectivity.GetStatusParams) middleware.Responder {\n\t\t\treturn middleware.NotImplemented(\"operation ConnectivityGetStatus has not yet been implemented\")\n\t\t}),\n\t\tConnectivityPutStatusProbeHandler: connectivity.PutStatusProbeHandlerFunc(func(params connectivity.PutStatusProbeParams) middleware.Responder {\n\t\t\treturn middleware.NotImplemented(\"operation ConnectivityPutStatusProbe has not yet been implemented\")\n\t\t}),\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "public function changePassword()\n    {\n        if ($this->validate()) {\n            if (!($user = $this->getUser())) {\n                return false;\n            }\n            if (!$user->applyForNewPassword()) {\n                return false;\n            }\n            return $user->resetPassword($this->new_password, $user->getPasswordResetToken());\n        }\n        return false;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (tl *TeeLogger) Errorf2(err error, format string, v ...interface{}) {\n\ttl.ErrorDepth(1, fmt.Sprintf(format+\": %+v\", append(v, err)))\n}", "comment": ""}
{"lang": "cpp", "code": "public static function parseClassProperty($fullClassName, $propertyName)\n    {\n        $class      = self::parseClass($fullClassName);\n        $classNodes = $class->stmts;\n\n        foreach ($classNodes as $classLevelNode) {\n            if ($classLevelNode instanceof Property) {\n                foreach ($classLevelNode->props as $classProperty) {\n                    if ($classProperty->name->toString() == $propertyName) {\n                        return [$classLevelNode, $classProperty];\n                    }\n                }\n            }\n        }\n\n        throw new \\InvalidArgumentException(\"Property $propertyName was not found in the $fullClassName\");\n    }", "comment": ""}
{"lang": "cpp", "code": "func NewStaticIterator(ctx Context, nodes []*structs.Node) *StaticIterator {\n\titer := &StaticIterator{\n\t\tctx:   ctx,\n\t\tnodes: nodes,\n\t}\n\treturn iter\n}", "comment": ""}
{"lang": "cpp", "code": "public Client build() {\n    validate();\n    Client client = new Client(database, credentials, host, scheme);\n    return client;\n  }", "comment": ""}
{"lang": "cpp", "code": "func Trace(path string, h interface{}, m ...interface{}) {\n\tDefault.Trace(path, h, m...)\n}", "comment": ""}
{"lang": "cpp", "code": "@Override\n    protected void doCommonFilter(PortletRequest request, PortletResponse response,\n            javax.portlet.filter.FilterChain chain) throws IOException, PortletException {\n\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"Checking secure context token: \" + SecurityContextHolder.getContext().getAuthentication());\n        }\n\n        if (requiresAuthentication((PortletRequest) request)) {\n            doAuthenticate((PortletRequest) request, (PortletResponse) response);\n        }\n\n        PortletFilterUtils.doFilter(request, response, chain);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (api *MobileGatewayAPI) GetTrafficMonitoringConfig(id int64) (*sacloud.TrafficMonitoringConfig, error) {\n\tvar (\n\t\tmethod = \"GET\"\n\t\turi    = fmt.Sprintf(\"%s/%d/mobilegateway/traffic_monitoring\", api.getResourceURL(), id)\n\t)\n\n\tres := &trafficMonitoringBody{}\n\terr := api.baseAPI.request(method, uri, nil, res)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn res.TrafficMonitoring, nil\n}", "comment": ""}
{"lang": "cpp", "code": "protected function afterSave($changed)\n    {\n        if ($changed) {\n            $this->accesslog->logChange($this->request, null, $this->formData);\n\n            // Reload the current user data\n            $user       = $this->currentUser;\n            $currentOrg = $user->getCurrentOrganizationId();\n\n            $this->loader->getUserLoader()->unsetCurrentUser();\n            $user = $this->loader->getUser($user->getLoginName(), $user->getBaseOrganizationId())->setAsCurrentUser();\n            $user->setCurrentOrganization($currentOrg);\n\n            // In case locale has changed, set it in a cookie\n            \\Gems_Cookies::setLocale($this->formData['gsf_iso_lang'], $this->basepath);\n\n            $this->addMessage($this->_('Saved your setup data', $this->formData['gsf_iso_lang']));\n        } else {\n            $this->addMessage($this->_('No changes to save!'));\n        }\n\n        if ($this->cacheTags && ($this->cache instanceof \\Zend_Cache_Core)) {\n            $this->cache->clean(\\Zend_Cache::CLEANING_MODE_MATCHING_ANY_TAG, (array) $this->cacheTags);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (cm *CIDRMap) InsertCIDR(cidr net.IPNet) error {\n\tkey := cm.cidrKeyInit(cidr)\n\tentry := [LPM_MAP_VALUE_SIZE]byte{}\n\tif err := cm.checkPrefixlen(&key, \"update\"); err != nil {\n\t\treturn err\n\t}\n\tlog.WithField(logfields.Path, cm.path).Debugf(\"Inserting CIDR entry %s\", cidr.String())\n\treturn bpf.UpdateElement(cm.Fd, unsafe.Pointer(&key), unsafe.Pointer(&entry), 0)\n}", "comment": ""}
{"lang": "cpp", "code": "public function hasPermissionForId($id)\n    {\n        try {\n            $em = $this->entityManager->getDoctrineEntityManager();\n            $permission = $em->getRepository('\\\\Zepi\\\\Core\\\\AccessControl\\\\Entity\\\\Permission')->find($id);\n            \n            if ($permission !== null) {\n                return true;\n            }\n            \n            return false;\n        } catch (\\Exception $e) {\n            throw new Exception('Cannot check if there is a permission for the given id \"' . $id . '\".', 0, $e);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (tx *Transaction) EncodeJSON() (string, error) {\n\tdata, err := json.Marshal(tx.tx)\n\treturn string(data), err\n}", "comment": ""}
{"lang": "cpp", "code": "func hasKeyPath(crumb string, iv interface{}, key string, basket *map[string]bool) {\n\tswitch iv.(type) {\n\tcase map[string]interface{}:\n\t\tvv := iv.(map[string]interface{})\n\t\tif _, ok := vv[key]; ok {\n\t\t\tif crumb == \"\" {\n\t\t\t\tcrumb = key\n\t\t\t} else {\n\t\t\t\tcrumb += \".\" + key\n\t\t\t}\n\t\t\t// *basket = append(*basket, crumb)\n\t\t\t(*basket)[crumb] = true\n\t\t}\n\t\t// walk on down the path, key could occur again at deeper node\n\t\tfor k, v := range vv {\n\t\t\t// create a new breadcrumb, add the one we're at to the crumb-trail\n\t\t\tvar nbc string\n\t\t\tif crumb == \"\" {\n\t\t\t\tnbc = k\n\t\t\t} else {\n\t\t\t\tnbc = crumb + \".\" + k\n\t\t\t}\n\t\t\thasKeyPath(nbc, v, key, basket)\n\t\t}\n\tcase []interface{}:\n\t\t// crumb-trail doesn't change, pass it on\n\t\tfor _, v := range iv.([]interface{}) {\n\t\t\thasKeyPath(crumb, v, key, basket)\n\t\t}\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "public function alert($string, $event)\n    {\n        $this->comment(str_repeat('*', strlen($string) + 12), $event);\n        $this->comment('*     ' . $string . '     *', $event);\n        $this->comment(str_repeat('*', strlen($string) + 12), $event);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *SizeConstraintSet) SetSizeConstraints(v []*SizeConstraint) *SizeConstraintSet {\n\ts.SizeConstraints = v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "protected void addMetadataFiltersToMetadataResolver(final AbstractMetadataResolver metadataProvider, final MetadataFilter... metadataFilterList) {\n        addMetadataFiltersToMetadataResolver(metadataProvider, Arrays.stream(metadataFilterList).collect(Collectors.toList()));\n    }", "comment": ""}
{"lang": "cpp", "code": "def access_storage_list(**kwargs):\n    \n    ctx = Context(**kwargs)\n    ctx.execute_action('access:storage:list', **{\n        'storage': ctx.repo.create_secure_service('storage'),\n    })", "comment": ""}
{"lang": "cpp", "code": "protected String escapeQuotes(Object o) {\n        if (o != null) {\n            return o.toString().replace(\"'\", \"''\");\n        }\n        return null;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (g *Generator) ImageWxH(ts int64, width, height int) (image.Image, error) {\n\tframeNum := C.av_rescale(\n\t\tC.int64_t(ts),\n\t\tC.int64_t(g.streams[g.vStreamIndex].time_base.den),\n\t\tC.int64_t(g.streams[g.vStreamIndex].time_base.num),\n\t) / 1000\n\tif C.avformat_seek_file(\n\t\tg.avfContext,\n\t\tC.int(g.vStreamIndex),\n\t\t0,\n\t\tframeNum,\n\t\tframeNum,\n\t\tC.AVSEEK_FLAG_FRAME,\n\t) < 0 {\n\t\tif C.avformat_seek_file(\n\t\t\tg.avfContext,\n\t\t\tC.int(g.vStreamIndex),\n\t\t\t0,\n\t\t\tframeNum,\n\t\t\tframeNum,\n\t\t\tC.AVSEEK_FLAG_ANY,\n\t\t) < 0 {\n\t\t\treturn nil, errors.New(\"can't seek to timestamp\")\n\t\t}\n\t}\n\timg := image.NewRGBA(image.Rect(0, 0, width, height))\n\tframe := C.av_frame_alloc()\n\tdefer C.av_frame_free(&frame)\n\tC.avcodec_flush_buffers(g.avcContext)\n\tpkt := C.av_packet_alloc()\n\tfor C.av_read_frame(g.avfContext, pkt) == 0 {\n\t\tif int(pkt.stream_index) != g.vStreamIndex {\n\t\t\tC.av_packet_unref(pkt)\n\t\t\tcontinue\n\t\t}\n\t\tif C.avcodec_send_packet(g.avcContext, pkt) != 0 {\n\t\t\tC.av_packet_unref(pkt)\n\t\t\treturn nil, errors.New(\"avcodec_send_packet failed\")\n\t\t}\n\t\tdts := pkt.dts\n\t\tC.av_packet_unref(pkt)\n\t\tif ret := C.avcodec_receive_frame(g.avcContext, frame); ret != 0 {\n\t\t\tif ret != C.AVERROR_EAGAIN {\n\t\t\t\treturn nil, errors.New(\"avcodec_receive_frame failed\")\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !g.Fast && dts < frameNum {\n\t\t\tcontinue\n\t\t}\n\t\tctx := C.sws_getContext(\n\t\t\tC.int(g.width),\n\t\t\tC.int(g.height),\n\t\t\tg.avcContext.pix_fmt,\n\t\t\tC.int(width),\n\t\t\tC.int(height),\n\t\t\tC.AV_PIX_FMT_RGBA,\n\t\t\tC.SWS_BICUBIC,\n\t\t\tnil,\n\t\t\tnil,\n\t\t\tnil,\n\t\t)\n\t\tif ctx == nil {\n\t\t\treturn nil, errors.New(\"can't allocate scaling context\")\n\t\t}\n\t\tsrcSlice := (**C.uint8_t)(&frame.data[0])\n\t\tsrcStride := (*C.int)(&frame.linesize[0])\n\t\thdr := (*reflect.SliceHeader)(unsafe.Pointer(&img.Pix))\n\t\tdst := (*C.uint8_t)(unsafe.Pointer(hdr.Data))\n\t\tdstStride := (*C.int)(unsafe.Pointer(&[1]int{img.Stride}))\n\t\tC.sws_scale_wrapper(\n\t\t\tctx,\n\t\t\tsrcSlice,\n\t\t\tsrcStride,\n\t\t\t0,\n\t\t\tg.avcContext.height,\n\t\t\tdst,\n\t\t\tdstStride,\n\t\t)\n\t\tC.sws_freeContext(ctx)\n\t\tbreak\n\t}\n\treturn img, nil\n}", "comment": ""}
{"lang": "cpp", "code": "public function __isset($property)\n    {\n        if ($propertyReflector = $this->liberatorPropertyReflector($property)) {\n            return null !== $propertyReflector->getValue($this->popsValue());\n        }\n\n        return parent::__isset($property);\n    }", "comment": ""}
{"lang": "cpp", "code": "public static function isNotEmpty() {\n        $args = func_get_args();\n\n        foreach ($args as $item) {\n\n            if (is_array($item) && empty($item)) {\n                return false;\n            }\n            else {\n                $item = trim($item);\n                if (empty($item) && $item !== \"0\") //0 as string is allowed, a field can be zero as string\n                    return false;\n            }\n        }\n\n        return true;\n    }", "comment": ""}
{"lang": "cpp", "code": "def tablespace_create(name, location, options=None, owner=None, user=None,\n                      host=None, port=None, maintenance_db=None, password=None,\n                      runas=None):\n    '''\n    \n    '''\n    owner_query = ''\n    options_query = ''\n    if owner:\n        owner_query = 'OWNER \"{0}\"'.format(owner)\n        # should come out looking like: 'OWNER postgres'\n    if options:\n        optionstext = ['{0} = {1}'.format(k, v) for k, v in six.iteritems(options)]\n        options_query = 'WITH ( {0} )'.format(', '.join(optionstext))\n        # should come out looking like: 'WITH ( opt1 = 1.0, opt2 = 4.0 )'\n    query = 'CREATE TABLESPACE \"{0}\" {1} LOCATION \\'{2}\\' {3}'.format(name,\n                                                                owner_query,\n                                                                location,\n                                                                options_query)\n\n    # Execute the command\n    ret = _psql_prepare_and_run(['-c', query],\n                                user=user, host=host, port=port,\n                                maintenance_db=maintenance_db,\n                                password=password, runas=runas)\n    return ret['retcode'] == 0", "comment": ""}
{"lang": "cpp", "code": "def get_surrounding_blocks(self):\n        \n\n        next = self.next_blocks()\n        prev = self.previous_blocks()\n\n        surrounding_blocks = list(chain(prev, [self], next))\n        return surrounding_blocks", "comment": ""}
{"lang": "cpp", "code": "func Generate(pidfile string, chDel <-chan struct{}) error {\n\tf, err := os.OpenFile(pidfile, os.O_CREATE|os.O_EXCL|os.O_WRONLY, 0644)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer f.Close()\n\tfmt.Fprintln(f, os.Getpid())\n\tif chDel != nil {\n\t\tgo func() {\n\t\t\tselect {\n\t\t\tcase <-chDel:\n\t\t\t\tos.Remove(pidfile)\n\t\t\t}\n\t\t}()\n\t}\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "public function removeEventListener($type, $plugin) {\n\t\t$type = strtolower($type);\n\t\tif (isset($this->eventsListeners[$type]) && in_array($plugin, $this->eventsListeners[$type])) {\n\t\t\t$index = array_search($plugin, $this->eventsListeners[$type]);\n\t\t\tarray_splice($this->eventsListeners[$type], $index, 1);\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function decrement($id, $offset = 1)\n\t{\n\t\t$success = FALSE;\n\t\t$value = wincache_ucache_dec($id, $offset, $success);\n\n\t\treturn ($success === TRUE) ? $value : FALSE;\n\t}", "comment": ""}
{"lang": "cpp", "code": "def _evalDateStd(self, datetimeString, sourceTime):\n        \n        s = datetimeString.strip()\n        sourceTime = self._evalDT(datetimeString, sourceTime)\n\n        # Given string is in the format 07/21/2006\n        return self.parseDate(s, sourceTime)", "comment": ""}
{"lang": "cpp", "code": "public static function of(int $value) : Month\n    {\n        Field\\MonthOfYear::check($value);\n\n        return Month::get($value);\n    }", "comment": ""}
{"lang": "cpp", "code": "def build(self, root, schema):\n        \n        if schema.get(\"subcommands\") and schema[\"subcommands\"]:\n            for subcmd, childSchema in schema[\"subcommands\"].items():\n                child = CommandTree(node=subcmd)\n                child = self.build(child, childSchema)\n                root.children.append(child)\n        # {args: {}, options: {}, help: \"\"}\n        root.help = schema.get(\"help\")\n        for name, desc in schema.get(\"options\").items():\n            if root.node == \"kubectl\":  # register global flags\n                self.globalFlags.append(Option(name, desc[\"help\"]))\n            root.localFlags.append(Option(name, desc[\"help\"]))\n        for arg in schema.get(\"args\"):\n            node = CommandTree(node=arg)\n            root.children.append(node)\n        return root", "comment": ""}
{"lang": "cpp", "code": "protected function convertSlice(array $values, $name)\n    {\n        $type = $this->projection->getFieldType($name);\n        $converter = $this->hydration_plan->getConverterForField($name);\n\n        return array_map(\n            function ($val) use ($converter, $type) {\n                return $converter->fromPg($val, $type, $this->session);\n            },\n            $values\n        );\n    }", "comment": ""}
{"lang": "cpp", "code": "public static void checkFieldSignature(final String signature) {\n        int pos = checkFieldTypeSignature(signature, 0);\n        if (pos != signature.length()) {\n            throw new IllegalArgumentException(signature + \": error at index \"\n                    + pos);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def save(self, filename):\n        \n\n        with open(filename, 'wb') as savefile:\n            pickle.dump(self.__dict__,\n                        savefile,\n                        protocol=pickle.HIGHEST_PROTOCOL)", "comment": ""}
{"lang": "cpp", "code": "public static final int parseInt(CharSequence cs)\r\n    {\r\n        if (CharSequences.startsWith(cs, \"0b\"))\r\n        {\r\n            return parseInt(cs, 2, 2, cs.length());\r\n        }\r\n        if (CharSequences.startsWith(cs, \"0x\"))\r\n        {\r\n            return parseInt(cs, 16, 2, cs.length());\r\n        }\r\n        return parseInt(cs, 10);\r\n    }", "comment": ""}
{"lang": "cpp", "code": "func (sc *SpaceComponent) SetCenter(p engo.Point) {\n\txDelta := sc.Width / 2\n\tyDelta := sc.Height / 2\n\t// update position according to point being used as our center\n\tif sc.Rotation == 0 {\n\t\tsc.Position.X = p.X - xDelta\n\t\tsc.Position.Y = p.Y - yDelta\n\t\treturn\n\t}\n\tsin, cos := math.Sincos(sc.Rotation * math.Pi / 180)\n\txDelta = (sc.Width*cos - sc.Height*sin) / 2\n\tyDelta = (sc.Height*cos + sc.Width*sin) / 2\n\tsc.Position.X = p.X - xDelta\n\tsc.Position.Y = p.Y - yDelta\n}", "comment": ""}
{"lang": "cpp", "code": "def _leu8(ins):\n    \n    output = _8bit_oper(ins.quad[2], ins.quad[3], reversed_=True)\n    output.append('sub h')  # Carry if H > A\n    output.append('ccf')  # Negates => Carry if H <= A\n    output.append('sbc a, a')\n    output.append('push af')\n\n    return output", "comment": ""}
{"lang": "cpp", "code": "func (s *GeoRestriction) SetQuantity(v int64) *GeoRestriction {\n\ts.Quantity = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "def run_checks(collector):\n    \"\"\"\"\"\"\n    artifact = collector.configuration[\"dashmat\"].artifact\n    chosen = artifact\n    if chosen in (None, \"\", NotSpecified):\n        chosen = None\n\n    dashmat = collector.configuration[\"dashmat\"]\n    modules = collector.configuration[\"__active_modules__\"]\n    config_root = collector.configuration[\"config_root\"]\n    module_options = collector.configuration[\"modules\"]\n\n    datastore = JsonDataStore(os.path.join(config_root, \"data.json\"))\n    if dashmat.redis_host:\n        datastore = RedisDataStore(redis.Redis(dashmat.redis_host))\n\n    scheduler = Scheduler(datastore)\n\n    for name, module in modules.items():\n        if chosen is None or name == chosen:\n            server = module.make_server(module_options[name].server_options)\n            scheduler.register(module, server, name)\n\n    scheduler.twitch(force=True)", "comment": ""}
{"lang": "cpp", "code": "protected void unsigned8(final int size, int value) throws IOException {\n        requireValidSizeUnsigned8(size);\n        final int required = size - available;\n        if (required > 0) {\n            unsigned8(available, value >> required);\n            unsigned8(required, value);\n            return;\n        }\n        octet <<= size;\n        octet |= (value & ((1 << size) - 1));\n        available -= size;\n        if (available == 0) {\n            write(octet);\n            count++;\n            octet = 0x00;\n            available = Byte.SIZE;\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "TypeElement superClassFor(TypeElement element) {\n        TypeMirror superclass = element.getSuperclass();\n        if (superclass.getKind() == TypeKind.NONE) {\n            return null;\n        }\n        DeclaredType kind = (DeclaredType) superclass;\n        return (TypeElement) kind.asElement();\n    }", "comment": ""}
{"lang": "cpp", "code": "def scope_within(locator)\n      if locator\n        # Use the selector_for method if it's defined. This may be provided\n        # by features/support/selectors.rb, generated by cucumber-rails.\n        if defined? selector_for\n          kelp_within(*selector_for(locator)) { yield }\n        # Otherwise, fall back on the Capybara locator syntax (CSS or XPath)\n        else\n          if locator =~ /\\.?\\//\n            kelp_within(:xpath, locator) { yield }\n          else\n            kelp_within(:css, locator) { yield }\n          end\n        end\n      else\n        yield\n      end\n    end", "comment": ""}
{"lang": "cpp", "code": "def segment_pofiles(configuration, locale):\n    \n    files_written = set()\n    for filename, segments in configuration.segment.items():\n        filename = configuration.get_messages_dir(locale) / filename\n        files_written.update(segment_pofile(filename, segments))\n    return files_written", "comment": ""}
{"lang": "cpp", "code": "public static function checkCsrf($type = 1)\n    {\n        if ($type !== 0 && isset($_SERVER['HTTP_REFERER']) && !strpos($_SERVER['HTTP_REFERER'], $_SERVER['HTTP_HOST'])) {\n            if ($type == 1) {\n                if (!empty($_POST)) {\n                    Response::sendHttpStatus(403);\n                    throw new \\UnexpectedValueException(Lang::get('_ILLEGAL_REQUEST_'));\n                }\n            } else {\n                Response::sendHttpStatus(403);\n                throw new \\UnexpectedValueException(Lang::get('_ILLEGAL_REQUEST_'));\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def max_pairs(shape):\n    \"\"\"\"\"\"\n\n    if not isinstance(shape, (tuple, list)):\n        x = get_length(shape)\n        n = int(x * (x - 1) / 2)\n\n    elif (isinstance(shape, (tuple, list)) and len(shape) == 1):\n        x = get_length(shape[0])\n        n = int(x * (x - 1) / 2)\n\n    else:\n        n = numpy.prod([get_length(xi) for xi in shape])\n\n    return n", "comment": ""}
{"lang": "cpp", "code": "public int ENgetlinkindex( String id ) throws EpanetException {\n        int[] index = new int[1];\n        int error = epanet.ENgetlinkindex(id, index);\n        checkError(error);\n        return index[0];\n    }", "comment": ""}
{"lang": "cpp", "code": "def clustal_align_protein(recs, work_dir, outfmt=\"fasta\"):\n    \n    fasta_file = op.join(work_dir, \"prot-start.fasta\")\n    align_file = op.join(work_dir, \"prot.aln\")\n    SeqIO.write(recs, file(fasta_file, \"w\"), \"fasta\")\n\n    clustal_cl = ClustalwCommandline(cmd=CLUSTALW_BIN(\"clustalw2\"),\n            infile=fasta_file, outfile=align_file, outorder=\"INPUT\",\n            type=\"PROTEIN\")\n    stdout, stderr = clustal_cl()\n\n    aln_file = file(clustal_cl.outfile)\n    alignment = AlignIO.read(aln_file, \"clustal\")\n    print(\"\\tDoing clustalw alignment: %s\" % clustal_cl, file=sys.stderr)\n    if outfmt == \"fasta\":\n        return alignment.format(\"fasta\")\n    if outfmt == \"clustal\":\n        return alignment", "comment": ""}
{"lang": "cpp", "code": "func (bk *Bucket) NewRangeScanner(min, max []byte) *RangeScanner {\n\treturn &RangeScanner{bk.db, bk.Name, min, max}\n}", "comment": ""}
{"lang": "cpp", "code": "public function dispatch(Route $route, Request $request = null)\n    {\n        $context = $this->context;\n\n        if (empty($this->context) && !empty($request)) {\n            // If we have no context, but do have a request, prepare a context to store path variables in.\n            // Otherwise routing path variables would be lost for no good reason.\n            $context = new Context();\n            $context->registerInstance($request);\n        }\n\n        if (!empty($context)) {\n            // If we have a context, ensure that the route is made available in it.\n            $context->registerInstance($route);\n\n            if (!empty($request)) {\n                // If we have a request, map the path variables and pass them to the context as primitive types by name.\n                // This will allow us to inject info from a route e.g. \"/view/$userId\" to a $userId variable.\n                $pathVariables = VariableUrl::extractUrlVariables($request->getRequestUri(), $route->getPattern());\n\n                foreach ($pathVariables as $name => $value) {\n                    $context->registerVariable($name, $value);\n                }\n            }\n        }\n\n        return $route->action($context);\n    }", "comment": ""}
{"lang": "cpp", "code": "func WithMaxConcurrentDownloads(max int) RemoteOpt {\n\treturn func(client *Client, c *RemoteContext) error {\n\t\tc.MaxConcurrentDownloads = max\n\t\treturn nil\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "public function verifySignature()\n    {\n        if ( isset($this->data['CreditCardTransactionResults']['ResponseCode']) && (\n            '1' == $this->data['CreditCardTransactionResults']['ResponseCode'] ||\n            '2' == $this->data['CreditCardTransactionResults']['ResponseCode']) )\n        {\n            $signature  = $this->request->getMerchantPassword();\n            $signature .= $this->request->getMerchantId();\n            $signature .= $this->request->getAcquirerId();\n            $signature .= $this->request->getTransactionId();\n\n            $signature  = base64_encode( sha1($signature, true) );\n\n            if ( $signature !== $this->data['Signature'] ) {\n                throw new InvalidResponseException('Signature verification failed');\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public static KeyManager[] getKeyManagers(String keyStoreFile, String pass)\n\t\t\tthrows InitializationException {\n\t\treturn getKeyManagers(getFileAsInputStream(keyStoreFile), pass);\n\t}", "comment": ""}
{"lang": "cpp", "code": "def cget(self, key):\n        \n        if key is \"link\":\n            return self._link\n        elif key is \"hover_color\":\n            return self._hover_color\n        elif key is \"normal_color\":\n            return self._normal_color\n        elif key is \"clicked_color\":\n            return self._clicked_color\n        else:\n            return ttk.Label.cget(self, key)", "comment": ""}
{"lang": "cpp", "code": "func (u *volumeUtil) IsDir(fullPath string) (bool, error) {\n\tdir, err := os.Open(fullPath)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tdefer dir.Close()\n\n\tstat, err := dir.Stat()\n\tif err != nil {\n\t\treturn false, err\n\t}\n\n\treturn stat.IsDir(), nil\n}", "comment": ""}
{"lang": "cpp", "code": "def to_local_name(acs, attr):\n    \n    for aconv in acs:\n        lattr = aconv.from_format(attr)\n        if lattr:\n            return lattr\n\n    return attr.friendly_name", "comment": ""}
{"lang": "cpp", "code": "public function removeAttachmentJoins()\n    {\n        $joinProto = $this->modelFactory()->get(Join::class);\n\n        $loader = $this->collectionLoader();\n        $loader\n            ->setModel($joinProto)\n            ->addFilter('object_type', $this->objType())\n            ->addFilter('object_id', $this->id());\n\n        $collection = $loader->load();\n\n        foreach ($collection as $obj) {\n            $obj->delete();\n        }\n\n        return true;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (h *HTTPExtender) Filter(\n\tpod *v1.Pod,\n\tnodes []*v1.Node, nodeNameToInfo map[string]*schedulernodeinfo.NodeInfo,\n) ([]*v1.Node, schedulerapi.FailedNodesMap, error) {\n\tvar (\n\t\tresult     schedulerapi.ExtenderFilterResult\n\t\tnodeList   *v1.NodeList\n\t\tnodeNames  *[]string\n\t\tnodeResult []*v1.Node\n\t\targs       *schedulerapi.ExtenderArgs\n\t)\n\n\tif h.filterVerb == \"\" {\n\t\treturn nodes, schedulerapi.FailedNodesMap{}, nil\n\t}\n\n\tif h.nodeCacheCapable {\n\t\tnodeNameSlice := make([]string, 0, len(nodes))\n\t\tfor _, node := range nodes {\n\t\t\tnodeNameSlice = append(nodeNameSlice, node.Name)\n\t\t}\n\t\tnodeNames = &nodeNameSlice\n\t} else {\n\t\tnodeList = &v1.NodeList{}\n\t\tfor _, node := range nodes {\n\t\t\tnodeList.Items = append(nodeList.Items, *node)\n\t\t}\n\t}\n\n\targs = &schedulerapi.ExtenderArgs{\n\t\tPod:       pod,\n\t\tNodes:     nodeList,\n\t\tNodeNames: nodeNames,\n\t}\n\n\tif err := h.send(h.filterVerb, args, &result); err != nil {\n\t\treturn nil, nil, err\n\t}\n\tif result.Error != \"\" {\n\t\treturn nil, nil, fmt.Errorf(result.Error)\n\t}\n\n\tif h.nodeCacheCapable && result.NodeNames != nil {\n\t\tnodeResult = make([]*v1.Node, 0, len(*result.NodeNames))\n\t\tfor i := range *result.NodeNames {\n\t\t\tnodeResult = append(nodeResult, nodeNameToInfo[(*result.NodeNames)[i]].Node())\n\t\t}\n\t} else if result.Nodes != nil {\n\t\tnodeResult = make([]*v1.Node, 0, len(result.Nodes.Items))\n\t\tfor i := range result.Nodes.Items {\n\t\t\tnodeResult = append(nodeResult, &result.Nodes.Items[i])\n\t\t}\n\t}\n\n\treturn nodeResult, result.FailedNodes, nil\n}", "comment": ""}
{"lang": "cpp", "code": "private XML addClass(Class<?> aClass){\r\n\t\txmlJmapper.classes.add(Converter.toXmlClass(aClass));\r\n\t\treturn this;\r\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function joinTwoPDFs($firstPDFPath, $secondPDFPath, $outputDestination = null)\n    {\n        $firstPDF = new \\PDFDoc($firstPDFPath);\n        $firstPDF->InitSecurityHandler();\n\n        $secondPDF = new \\PDFDoc($secondPDFPath);\n        $firstPDF->InsertPages(1, $secondPDF, 1, $secondPDF->GetPageCount(), \\PDFDoc::e_none);\n        $secondPDF->Close();\n\n        if (!empty($outputDestination)) {\n            $firstPDF->Save($outputDestination, \\SDFDoc::e_remove_unused);\n        } else {\n            $firstPDF->Save($firstPDFPath, \\SDFDoc::e_remove_unused);\n        }\n\n    }", "comment": ""}
{"lang": "cpp", "code": "public static void main(String[] args) {\n    System.err.println(toString(new int[] { Integer.parseInt(args[0]) }));\n  }", "comment": ""}
{"lang": "cpp", "code": "public function create(array $data)\n    {\n        if (! array_key_exists('name', $data)) {\n            $data['name'] = Str::slug($data['display_name']);\n        }\n\n        return parent::create($data);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getPK($require = true)\n    {\n        foreach ($this->fields as $field) {\n            if ($field->pk()) {\n                return $field;\n            }\n        }\n\n        if ($require) {\n            throw new NoPKException();\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function crop($width, $height, $startX=null, $startY=null)\n    {\n        $sizeSrc = $this->getImageSize($this->imgSrc);\n        if ( $startX === null ) {\n            $startX = ($sizeSrc[0] - $width)/2;\n        }\n        if ( $startY === null ) {\n            $startY = ($sizeSrc[1] - $height)/2;\n        }\n        $this->imgDst = imagecrop($this->imgDst,\n            ['x' => $startX, 'y' => $startY, 'width' => $width, 'height' => $height]);\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function renderButton($dropdown) {\n    $dropdownId = $dropdown->getId();\n    \n    $label = $this->label;\n    if ($this->encodeLabel) {\n      $label = Html::encode($label);\n    }\n    if ($this->split) {\n      $this->tagName = 'a';\n      Html::addCssClass($this->options, 'button');\n      Html::addCssClass($this->options, 'split');\n      $options = $this->options;\n      $label .= Html::tag('span', '', ['data-dropdown' => $dropdownId]);\n    } else {\n      Html::addCssClass($this->options, 'dropdown');\n      $options = $this->options;\n      \n      $options['data-dropdown'] = $dropdownId;\n    }\n\n    return Button::widget([\n            'tagName' => $this->tagName,\n            'label' => $label,\n            'options' => $options,\n            'url' => $this->url,\n            'encodeLabel' => false,\n        ]) . \"<br />\\n\";\n  }", "comment": ""}
{"lang": "cpp", "code": "func (b *BitSet) IsStrictSuperSet(other *BitSet) bool {\n\treturn b.Count() > other.Count() && b.IsSuperSet(other)\n}", "comment": ""}
{"lang": "cpp", "code": "def require_setting(self, name: str, feature: str = \"this feature\") -> None:\n        \"\"\"\"\"\"\n        if not self.application.settings.get(name):\n            raise Exception(\n                \"You must define the '%s' setting in your \"\n                \"application to use %s\" % (name, feature)\n            )", "comment": ""}
{"lang": "cpp", "code": "def retry(self):\n        \n\n        if self.connector is None:\n            raise ValueError(\"No connector to retry\")\n        if self.service is None:\n            return\n        self.connector.connect()", "comment": ""}
{"lang": "cpp", "code": "public function find($criteria = array())\n    {\n        if (!is_array($criteria)) {\n            $criteria = array(\n                '$id' => $criteria,\n            );\n        }\n\n        // wrap criteria as NObject instance to make sure it can be override by hooks\n        $criteria = new NObject($criteria);\n\n        $this->applyHook('searching', $criteria);\n        $cursor = $this->connection->query($this, $criteria->toArray());\n        $this->applyHook('searched', $cursor);\n\n        return $cursor;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function setGender(\\Innova\\LexiconBundle\\Entity\\Gender $gender = null)\n    {\n        $this->gender = $gender;\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *HistoricalMetricData) SetValue(v float64) *HistoricalMetricData {\n\ts.Value = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "func (s *BuildConfiguration) SetCodeBuildServiceRole(v string) *BuildConfiguration {\n\ts.CodeBuildServiceRole = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public function head()\n    {\n        global $event, $theme;\n\n        if ($event != 'rah_backup') {\n            return;\n        }\n\n        gTxtScript(array(\n            'rah_backup_confirm_backup',\n        ));\n\n        $msg = array(\n            'backup' => escape_js($theme->announce_async(gTxt('rah_backup_taking'))),\n            'error' => escape_js($theme->announce_async(gTxt('rah_backup_task_error'))),\n        );\n\n        $js = <<<EOF\n            $(function ()\n            {\n                $('.rah_backup_take').on('click', function (e)\n                {\n                    e.preventDefault();\n                    var obj = $(this), href, spinner;\n\n                    if (obj.hasClass('disabled') || !verify(textpattern.gTxt('rah_backup_confirm_backup'))) {\n                        return false;\n                    }\n\n                    $.globalEval('{$msg['backup']}');\n\n                    spinner = $('<span> <span class=\"spinner\"></span> </span>');\n                    href = obj.attr('href');\n                    obj.addClass('disabled').attr('href', '#').after(spinner);\n\n                    $.ajax('index.php', {\n                        data: href.substr(1) + '&app_mode=async',\n                        dataType: 'script',\n                        timeout: 1800000\n                    }).fail(function ()\n                    {\n                        $.globalEval('{$msg['error']}');\n                    }).always(function ()\n                    {\n                        obj.removeClass('disabled').attr('href', href);\n                        spinner.remove();\n                    });\n                });\n            });\nEOF;\n\n        echo script_js($js);\n    }", "comment": ""}
{"lang": "cpp", "code": "public String asJSON() {\n    Gson gson = new Gson();\n\n    clearExpired();\n\n    Cache jsonCache = new Cache();\n    for (ExpiringService svc : cache.values()) {\n      jsonCache.cache.add(svc.getService());\n    }\n\n    String json = gson.toJson(jsonCache);\n\n    return json;\n  }", "comment": ""}
{"lang": "cpp", "code": "function (legend) {\n\n            var options = this.options,\n              markerOptions = options.marker,\n              radius,\n              legendOptions = legend.options,\n              legendSymbol,\n              symbolWidth = legend.symbolWidth,\n              renderer = this.chart.renderer,\n              legendItemGroup = this.legendGroup,\n              verticalCenter = legend.baseline - mathRound(renderer.fontMetrics(legendOptions.itemStyle.fontSize, this.legendItem).b * 0.3),\n              attr;\n\n            // Draw the line\n            if (options.lineWidth) {\n                attr = {\n                    'stroke-width': options.lineWidth\n                };\n                if (options.dashStyle) {\n                    attr.dashstyle = options.dashStyle;\n                }\n                this.legendLine = renderer.path([\n                      M,\n                      0,\n                      verticalCenter,\n                      L,\n                      symbolWidth,\n                      verticalCenter\n                  ])\n                  .attr(attr)\n                  .add(legendItemGroup);\n            }\n\n            // Draw the marker\n            if (markerOptions && markerOptions.enabled !== false) {\n                radius = markerOptions.radius;\n                this.legendSymbol = legendSymbol = renderer.symbol(\n                  this.symbol,\n                    (symbolWidth / 2) - radius,\n                    verticalCenter - radius,\n                    2 * radius,\n                    2 * radius\n                  )\n                  .add(legendItemGroup);\n                legendSymbol.isMarker = true;\n            }\n        }", "comment": ""}
{"lang": "cpp", "code": "public StorageDescriptor withParameters(java.util.Map<String, String> parameters) {\n        setParameters(parameters);\n        return this;\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function hasOptionsDef($commandDef) {\n        return count($commandDef) > 1 || (count($commandDef) > 0 && !isset($commandDef[Cli::META]));\n    }", "comment": ""}
{"lang": "cpp", "code": "function link(node, href) {\n  var self = this\n  var value = 'children' in node ? self.all(node).join('') : node.alt\n  var url = escape(typeof href === 'string' ? href : node.url || '')\n  var head\n\n  if (url && url.slice(0, mailto.length) === mailto) {\n    url = url.slice(mailto.length)\n  }\n\n  head = url.charAt(0) === '#' && self.headings[url.slice(1)]\n\n  if (head) {\n    url = '(' + escape(toString(head)) + ')'\n  } else {\n    if (value && escape(url) === value) {\n      value = ''\n    }\n\n    if (url) {\n      url = '\\\\(la' + escape(url) + '\\\\(ra'\n    }\n  }\n\n  if (value) {\n    value = bold.call(self, value)\n\n    if (url) {\n      value += ' '\n    }\n  }\n\n  return value + (url ? italic.call(self, url) : '')\n}", "comment": ""}
{"lang": "cpp", "code": "func Reverse(a []byte) []byte {\n\tfor left, right := 0, len(a)-1; left < right; left, right = left+1, right-1 {\n\t\ta[left], a[right] = a[right], a[left]\n\t}\n\n\treturn a\n}", "comment": ""}
{"lang": "cpp", "code": "@Override\n  public final boolean isValid(final Object pvalue, final ConstraintValidatorContext pcontext) {\n    final String valueAsString = StringUtils.strip(Objects.toString(pvalue, null), stripcharacters);\n\n    return StringUtils.isNotEmpty(valueAsString);\n  }", "comment": ""}
{"lang": "cpp", "code": "def load_remote_system(url, format=None):\n    '''\n    '''\n    filename, headers = urlretrieve(url)\n    return load_system(filename, format=format)", "comment": ""}
{"lang": "cpp", "code": "protected function leadMKA()\r\n\t{\r\n\t\t$lead = $this->ffprobeFormat(\"matroska\", \"webm\");\r\n\r\n\t\tif ($lead === true)\r\n\t\t{\r\n\t\t\tif ($this->ffprobeHasAudio() !== false)\r\n\t\t\t{\r\n\t\t\t\treturn $this->closeCase(\"mka\", \"audio/x-matroska\", $this->metadata);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function init()\n    {\n        $host =getenv('PDO_HOST');\n        if($host) {\n            $this->setHost(trim($host));\n        }\n\n        $database = getenv('PDO_DATABASE');\n        if($database) {\n            $this->setDatabase(trim($database));\n        }\n        $user = getenv('PDO_USER');\n        if($user) {\n            $this->setUser($user);\n        }\n\n        $password = getenv('PDO_PASSWORD');\n        if($password) {\n            $this->setPassword($password);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "private void populateStep4() {\n        this.insertRoadmapItem(3, true, I18nLabelsLoader.REPORT_STEP_THANKS, 4);\n\n        int y = 6;\n\n        // thanks\n        this.insertFixedTextBold(this, DEFAULT_PosX, y, DEFAULT_WIDTH_LARGE, STEP_THANKS, I18nLabelsLoader.REPORT_STEP_THANKS);\n        y += 12; // plus one line\n\n        // thanks msg\n        this.insertMultilineFixedText(this, DEFAULT_PosX, y, DEFAULT_WIDTH_LARGE, 8*5, STEP_THANKS, I18nLabelsLoader.ADDON_THANKS_MESSAGE);\n        y += 8*5 + 12; // plus 15 lines\n\n        // status\n        this.insertFixedText(this, DEFAULT_PosX, y, DEFAULT_WIDTH_LARGE, STEP_THANKS, I18nLabelsLoader.ADDON_THANKS_STATUS);\n        this.thanksStatusLabel = this.insertHiddenFixedStatusText(this, DEFAULT_PosX + 40, y, DEFAULT_WIDTH_LARGE, STEP_THANKS, I18nLabelsLoader.ADDON_THANKS_STATUS, false);\n        y += 12;\n        \n        // link\n        this.thanksReportLink = this.insertFixedHyperlink(this, DEFAULT_PosX, y, DEFAULT_WIDTH_LARGE, STEP_THANKS, I18nLabelsLoader.ADDON_THANKS_LINK, Resources.getProperty(\"COMMUNITY_ROOT\") + \"/reports\");\n\n        this.thanksProgressBar = this.insertProgressBar(DEFAULT_PosX, DEFAULT_DIALOG_HEIGHT - 26 - 8, DEFAULT_WIDTH_LARGE, STEP_THANKS, 100);\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function gatherOptions()\n    {\n        return new ListenerOptions(\n            $this->option('env'), $this->option('delay'),\n            $this->option('memory'), $this->option('timeout'),\n            $this->option('sleep'), $this->option('tries'),\n            $this->option('force')\n        );\n    }", "comment": ""}
{"lang": "cpp", "code": "func acquireChan(tokenCh <-chan struct{}) func(context.Context, bool) bool {\n\tif tokenCh == nil {\n\t\t// always false: acquire never succeeds; panic if told to block (to avoid deadlock)\n\t\treturn func(ctx context.Context, block bool) bool {\n\t\t\tif block {\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\tdefault:\n\t\t\t\t\tpanic(\"deadlock detected: block should never be true when the token chan is nil\")\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t}\n\treturn func(ctx context.Context, block bool) bool {\n\t\tif block {\n\t\t\tselect {\n\t\t\tcase <-tokenCh:\n\t\t\t\t// tie breaker prefers Done\n\t\t\t\tselect {\n\t\t\t\tcase <-ctx.Done():\n\t\t\t\tdefault:\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\tcase <-ctx.Done():\n\t\t\t}\n\t\t\treturn false\n\t\t}\n\t\tselect {\n\t\tcase <-tokenCh:\n\t\t\treturn true\n\t\tdefault:\n\t\t\treturn false\n\t\t}\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "public function collectAction()\n    {\n        // @todo json\n        $service = $this->getGarbageCollector();\n        if ($service->collect()) {\n            return $this->redirect()->toRoute('sc-admin/content-manager');\n        }\n        return $this->redirect()\n            ->toRoute(\n                'sc-admin/file/delete',\n                ['random' => Stdlib::randomKey(6)]\n            )\n            ->setStatusCode(303);\n    }", "comment": ""}
{"lang": "cpp", "code": "func Str2JSType(s string) JSType {\n\tvar (\n\t\toutput JSType\n\t)\n\ts = strings.TrimSpace(s) // santize the given string\n\tswitch {\n\tcase isBool(s):\n\t\toutput = Bool\n\tcase isFloat(s):\n\t\toutput = Float\n\tcase isInt(s):\n\t\toutput = Int\n\tcase isNull(s):\n\t\toutput = Null\n\tdefault:\n\t\toutput = String // if all alternatives have been eliminated, the input is a string\n\t}\n\treturn output\n}", "comment": ""}
{"lang": "cpp", "code": "public function after_path($path) {\n        $toprocess = false;\n        // If the path being closed matches (same or parent) the first path in the stack\n        // we process pending startend notifications until one matching end is found\n        if ($element = reset($this->startendinfo)) {\n            $elepath = $element['path'];\n            $eleaction = $element['action'];\n            if (strpos($elepath, $path) === 0) {\n                $toprocess = true;\n            }\n\n        // Also, if the stack of startend notifications is empty, we can process current end\n        // path safely\n        } else {\n            $toprocess = true;\n        }\n        if ($this->path_is_selected($path)) {\n            $this->startendinfo[] = array('path' => $path, 'action' => 'end');\n        }\n        // Send all the pending startend notifications if decided to do so\n        if ($toprocess) {\n            $this->process_pending_startend_notifications($path, 'end');\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (a *AIP1640Driver) sendCommand(cmd byte) {\n\ta.pinData.Off()\n\ta.send(cmd)\n\ta.pinData.On()\n}", "comment": ""}
{"lang": "cpp", "code": "func prepareCopyURLsTypeD(sourceURLs []string, targetURL string, isRecursive bool, encKeyDB map[string][]prefixSSEPair) <-chan URLs {\n\tcopyURLsCh := make(chan URLs)\n\tgo func(sourceURLs []string, targetURL string, copyURLsCh chan URLs) {\n\t\tdefer close(copyURLsCh)\n\t\tfor _, sourceURL := range sourceURLs {\n\t\t\tfor cpURLs := range prepareCopyURLsTypeC(sourceURL, targetURL, isRecursive, encKeyDB) {\n\t\t\t\tcopyURLsCh <- cpURLs\n\t\t\t}\n\t\t}\n\t}(sourceURLs, targetURL, copyURLsCh)\n\treturn copyURLsCh\n}", "comment": ""}
{"lang": "cpp", "code": "func (in *SourceStrategyOptions) DeepCopy() *SourceStrategyOptions {\n\tif in == nil {\n\t\treturn nil\n\t}\n\tout := new(SourceStrategyOptions)\n\tin.DeepCopyInto(out)\n\treturn out\n}", "comment": ""}
{"lang": "cpp", "code": "public function selectAll($where=false, $order=false, $limit=false) {\n        $clause = false;\n        $values = array();\n        if ( is_array($where) ) {\n            $retval = self::extractWhere($where, $clause, $values);\n            if ( is_string($retval) ) throw new \\Exception($val);\n        }\n        $orderby = '';\n        if ( is_string($order) ) {\n            $orderby = self::extractOrder($order);\n            if ( $orderby === false ) throw new \\Exception('Invalid Order value');\n        }\n\n        $sql = \"SELECT KVS.id AS id, json_body, KVS.created_at, KVS.updated_at\n            FROM $this->KVS_TABLE AS KVS\n            WHERE $this->KVS_FK_NAME = :foreign_key\";\n        if ( $clause ) $sql .= ' AND '.$clause;\n        if ( $orderby ) $sql .= ' '.$orderby;\n        $values[':foreign_key'] = $this->KVS_FK;\n        $rows = $this->PDOX->allRowsDie($sql, $values);\n        return $rows;\n    }", "comment": ""}
{"lang": "cpp", "code": "public String toStringHierarchy(final TypeWriter typeWriter) {\n        final StringBuilder res = new StringBuilder(types.size() * 50);\n        writeHierarchy(root, \"\", \"\", res, typeWriter);\n        return res.toString();\n    }", "comment": ""}
{"lang": "cpp", "code": "def main(args=None):\n    \"\"\"\"\"\"\n    parser = _parser()\n\n    # Python 2 will error 'too few arguments' if no subcommand is supplied.\n    # No such error occurs in Python 3, which makes it feasible to check\n    # whether a subcommand was provided (displaying a help message if not).\n    # argparse internals vary significantly over the major versions, so it's\n    # much easier to just override the args passed to it. In this case, print\n    # the usage message if there are no args.\n    if args is None and len(sys.argv) <= 1:\n        sys.argv.append('--help')\n\n    options = parser.parse_args(args)\n\n    # pass options to subcommand\n    options.func(options)\n\n    return 0", "comment": ""}
{"lang": "cpp", "code": "def displace!(x,y,z)\n      self.x += x\n      self.y += y\n      self.z += z\n    end", "comment": ""}
{"lang": "cpp", "code": "function getMessageFromPackage(messageType, type, callback) {\n  var packageName = getPackageNameFromMessageType(messageType);\n  var messageName = getMessageNameFromMessageType(messageType);\n  packages.findPackage(packageName, function(error, directory) {\n    var filePath;\n    filePath = path.join(directory, type, messageName + '.' + type);\n    getMessageFromFile(messageType, filePath, type, callback);\n  });\n}", "comment": ""}
{"lang": "cpp", "code": "def _analyse_status_type(line):\n    '''\n    \n    '''\n    spaces = _count_spaces_startswith(line)\n\n    if spaces is None:\n        return ''\n\n    switch = {\n        0: 'RESOURCE',\n        2: {' disk:': 'LOCALDISK', ' role:': 'PEERNODE', ' connection:': 'PEERNODE'},\n        4: {' peer-disk:': 'PEERDISK'}\n    }\n\n    ret = switch.get(spaces, 'UNKNOWN')\n\n    # isinstance(ret, str) only works when run directly, calling need unicode(six)\n    if isinstance(ret, six.text_type):\n        return ret\n\n    for x in ret:\n        if x in line:\n            return ret[x]\n\n    return 'UNKNOWN'", "comment": ""}
{"lang": "cpp", "code": "public static function fromDSN($dsn)\n    {\n        $connParams = parse_url($dsn);\n        $schemeInfo = explode('+', $connParams['scheme']);\n        $modifier = null;\n        $scheme = $schemeInfo[0];\n        $dbName = isset($connParams['path']) ? substr($connParams['path'], 1) : null;\n\n        if (isset($schemeInfo[1])) {\n            $modifier = strtolower($schemeInfo[0]);\n            $scheme = $schemeInfo[1];\n        }\n\n        if ($scheme != 'influxdb') {\n            throw new ClientException($scheme . ' is not a valid scheme');\n        }\n\n        if (!in_array($modifier, ['udp'])) {\n            throw new ClientException(sprintf(\"%s modifier specified in DSN is not supported\", $modifier));\n        }\n\n        $driver = null;\n        // set the UDP driver when the DSN specifies UDP\n        if ($modifier == 'udp') {\n            $driver = new UDP($connParams['host'], $connParams['port']);\n        }\n\n        $client = new self($driver);\n        return ($dbName ? $client->selectDB($dbName) : $client);\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function execute(InputInterface $input, OutputInterface $output)\n    {\n        $this->init($input);\n        $function = $input->getArgument('function');\n        $idChart  = $input->getOption('idChart');\n\n        switch ($function) {\n            case 'maj-player':\n                if ($idChart) {\n                    $chart = $this->doctrine->getRepository('VideoGamesRecordsCoreBundle:Chart')->find($idChart);\n                    $this->updateCharts([$chart]);\n                } else {\n                    $this->majPlayer($output);\n                }\n                break;\n        }\n        $this->end($output);\n\n        return true;\n    }", "comment": ""}
{"lang": "cpp", "code": "@XmlElementDecl(namespace = \"http://www.drugbank.ca\", name = \"rs-id\", scope = SnpAdverseDrugReactionType.class)\n    public JAXBElement<String> createSnpAdverseDrugReactionTypeRsId(String value) {\n        return new JAXBElement<String>(_SnpAdverseDrugReactionTypeRsId_QNAME, String.class, SnpAdverseDrugReactionType.class, value);\n    }", "comment": ""}
{"lang": "cpp", "code": "public EClass getGCBEZ() {\n\t\tif (gcbezEClass == null) {\n\t\t\tgcbezEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(488);\n\t\t}\n\t\treturn gcbezEClass;\n\t}", "comment": ""}
{"lang": "cpp", "code": "def get_firmware_image(self, image_id):\n        \n        api = self._get_api(update_service.DefaultApi)\n        return FirmwareImage(api.firmware_image_retrieve(image_id))", "comment": ""}
{"lang": "cpp", "code": "public void deleteLocalSubscriptionControlByID(String id) \n  throws SIMPInvalidRuntimeIDException, SIMPControllableNotFoundException, SIMPException, \n         SIDurableSubscriptionNotFoundException, SIDestinationLockedException, SIResourceException, SIIncorrectCallException\n  {\n    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())\n      SibTr.entry(tc, \"deleteLocalSubscriptionControlByID\", id);\n    \n    assertMessageHandlerNotCorrupt();\n\n    ControllableSubscription sub = getSubscription(id);\n\n    if (!sub.isDurable())\n    {\n      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())\n        SibTr.exit(\n          tc,\n          \"deleteLocalSubscriptionControlByID\",\n          \"SIMPIncorrectCallException\");\n          \n      throw new SIMPIncorrectCallException(\n        nls.getFormattedMessage(\n          \"SUBSCRIPTION_DELETE_ERROR_CWSIP0272\",\n          new Object[]{id},\n          null));  \n    }\n    \n    HashMap durableSubs = destinationManager.getDurableSubscriptionsTable();    \n\n    synchronized (durableSubs)\n    {\n      // Look up the consumer dispatcher for this subId in the system durable subs list\n      ConsumerDispatcher cd = \n        (ConsumerDispatcher) durableSubs.get(sub.getConsumerDispatcherState().getSubscriberID());\n      \n      // Does the subscription exist, if it doesn't, throw a \n      // SIDestinationNotFoundException\n      if (cd == null)\n      {\n        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) \n          SibTr.exit(tc, \"deleteSubscription\", \"SIMPControllableNotFoundException\");\n          \n        throw new SIMPControllableNotFoundException(          \n          nls.getFormattedMessage(\n            \"SUBSCRIPTION_DOESNT_EXIST_ERROR_CWSIP0146\",\n            new Object[] { sub.getConsumerDispatcherState().getSubscriberID(),\n                           messageProcessor.getMessagingEngineName() },\n          null));\n      }        \n\n      // Obtain the destination from the queueing points\n      DestinationHandler destination = cd.getDestination();\n\n      // Call the deleteDurableSubscription method on the destination\n      // NOTE: this assumes the durable subscription is always local\n      destination.deleteDurableSubscription(sub.getConsumerDispatcherState().getSubscriberID(), \n                                            messageProcessor.getMessagingEngineName());\n    }\n\n    \n    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())\n      SibTr.exit(tc, \"deleteLocalSubscriptionControlByID\");\n  }", "comment": ""}
{"lang": "cpp", "code": "public function login($username, $password)\n\t{\n\t\t$response = $this->http->get($this->getUrl('oauth2/access_token'), array(\n\t\t\t'grant_type'\t=>\t'password ',\n\t\t\t'username'\t\t=>\t$username,\n\t\t\t'password'\t\t=>\t$password,\n\t\t\t'client_id'\t\t=>\t$this->appid,\n\t\t\t'client_secret'\t=>\t$this->appSecret,\n\t\t));\n\t\t$this->result = $response->json(true);\n\t\tif(!isset($this->result['error_code']))\n\t\t{\n\t\t\treturn $this->accessToken = $this->result['access_token'];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthrow new ApiException(isset($this->result['error']) ? $this->result['error'] : '', $this->result['error_code']);\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function run(Request $request) {\n\t\t$id = $this->getParam('id');\n\t\t$sport = SportQuery::create()\n\t\t\t->leftJoinGroup()\n\t\t\t->leftJoinSkill()\n\t\t\t->findOneById($id);\n\n\t\t$pictures = PictureQuery::create()\n\t\t\t->useSkillQuery()\n\t\t\t\t->filterBySportId($id)\n\t\t\t->endUse()\n\t\t\t->count();\n\n\t\t$videos = VideoQuery::create()\n\t\t\t->useSkillQuery()\n\t\t\t\t->filterBySportId($id)\n\t\t\t->endUse()\n\t\t\t->count();\n\n\t\t$references = ReferenceQuery::create()\n\t\t\t->useSkillReferenceQuery()\n\t\t\t\t->useSkillQuery()\n\t\t\t\t\t->filterBySportId($id)\n\t\t\t\t->endUse()\n\t\t\t->endUse()\n\t\t\t->count();\n\n\t\t$statistics = [\n\t\t\t'skills' => $sport->countSkills(),\n\t\t\t'groups' => $sport->countGroups(),\n\t\t\t'pictures' => $pictures,\n\t\t\t'videos' => $videos,\n\t\t\t'references' => $references\n\t\t];\n\n\t\treturn $this->responder->run($request, new Blank($statistics));\n\t}", "comment": ""}
{"lang": "cpp", "code": "private static function pushResourceToRequestContext(IPoolResource $resource)\n    {\n        $poolResources = RequestContext::get('poolResources', []);\n        $instance = $resource->getInstance();\n        $poolResources[spl_object_hash($instance)] = $resource;\n        RequestContext::set('poolResources', $poolResources);\n    }", "comment": ""}
{"lang": "cpp", "code": "@Override\n    public void transform(Context<MutableTimeSeriesCollectionPair> ctx) {\n        DateTime now = ctx.getTSData().getCurrentCollection().getTimestamp();\n\n        ctx.getTSData().getCurrentCollection().addMetrics(MONITOR_GROUP, get_metrics_(now, ctx));\n\n        ctx.getAlertManager().accept(new Alert(now, MONITOR_DOWN_ALERT, () -> \"builtin rule\", Optional.of(false), Duration.ZERO, \"builtin rule: monitor is not running for some time\", EMPTY_MAP));\n    }", "comment": ""}
{"lang": "cpp", "code": "public function select($table = '', $column = [], $arrayWhere = [], $other = '')\n    {\n        // handle column array data\n        if (!is_array($column)) {\n            $column = [];\n        }\n        // get field if pass otherwise use *\n        $sField = count($column) > 0 ? implode(', ', $column) : '*';\n        // check if table name not empty\n        if (!empty($table)) {\n            // if more then 0 array found in where array\n            if (count($arrayWhere) > 0 && is_array($arrayWhere)) {\n                // set class where array\n                $this->data = $arrayWhere;\n                // parse where array and get in temp var with key name and val\n                if (strstr(key($arrayWhere), ' ')) {\n                    $tmp = $this->customWhere($this->data);\n                    // get where syntax with namespace\n                    $where = $tmp['where'];\n                } else {\n                    $tmp = [];\n                    foreach ($arrayWhere as $k => $v) {\n                        $tmp[] = \"$k = :s_$k\";\n                    }\n                    // join temp array with AND condition\n                    $where = implode(' AND ', $tmp);\n                }\n                // unset temp var\n                unset($tmp);\n                // set class sql property\n                $this->sql = \"SELECT $sField FROM `$table` WHERE $where $other;\";\n            } else {\n                $this->sql = \"SELECT $sField FROM `$table` $other;\";  // if no where condition pass by user\n            }\n\n            // pdo prepare statement with sql query\n            $this->STH = $this->prepare($this->sql);\n            // if where condition has valid array number\n\n            if (count($arrayWhere) > 0 && is_array($arrayWhere)) {\n                $this->_bindPdoNameSpace($arrayWhere); // bind pdo param\n            }\n\n            // use try catch block to get pdo error\n            try {\n                // check if pdo execute\n                if ($this->STH->execute()) {\n                    // set class property with affected rows\n                    $this->affectedRows = $this->STH->rowCount();\n                    // set class property with sql result\n                    $this->results = $this->STH->fetchAll();\n                    // close pdo\n                    $this->STH->closeCursor();\n                    // return self object\n                    return $this;\n                } else {\n                    self::error($this->STH->errorInfo());  // catch pdo error\n                }\n            } catch (\\PDOException $e) {\n                // get pdo error and pass on error method\n                self::error($e->getMessage() . ': ' . __LINE__);\n            } // end try catch block to get pdo error\n        } else { // if table name empty\n            self::error('Table name not found..');\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function isControlInvalid($snippet = NULL)\n\t{\n\t\tif ($snippet === NULL) {\n\t\t\tif (count($this->invalidSnippets) > 0) {\n\t\t\t\treturn TRUE;\n\n\t\t\t} else {\n\t\t\t\t$queue = [$this];\n\t\t\t\tdo {\n\t\t\t\t\tforeach (array_shift($queue)->getComponents() as $component) {\n\t\t\t\t\t\tif ($component instanceof IRenderable) {\n\t\t\t\t\t\t\tif ($component->isControlInvalid()) {\n\t\t\t\t\t\t\t\t// $this->invalidSnippets['__child'] = TRUE; // as cache\n\t\t\t\t\t\t\t\treturn TRUE;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} elseif ($component instanceof Nette\\ComponentModel\\IContainer) {\n\t\t\t\t\t\t\t$queue[] = $component;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while ($queue);\n\n\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t} elseif (isset($this->invalidSnippets[$snippet])) {\n\t\t\treturn $this->invalidSnippets[$snippet];\n\t\t} else {\n\t\t\treturn isset($this->invalidSnippets[\"\\0\"]);\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "private void resetOptionbar() {\n\n        if (m_elementOptionBar != null) {\n            if (getWidgetIndex(m_elementOptionBar) >= 0) {\n                m_elementOptionBar.removeFromParent();\n            }\n            updateOptionBarPosition();\n            insert(m_elementOptionBar, 0);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (c Client) GetBucketNotification(bucketName string) (bucketNotification BucketNotification, err error) {\n\t// Input validation.\n\tif err := s3utils.CheckValidBucketName(bucketName); err != nil {\n\t\treturn BucketNotification{}, err\n\t}\n\tnotification, err := c.getBucketNotification(bucketName)\n\tif err != nil {\n\t\treturn BucketNotification{}, err\n\t}\n\treturn notification, nil\n}", "comment": ""}
{"lang": "cpp", "code": "protected function getDocName()\n    {\n        $name = $this->option('name') ?: $this->name;\n\n        if (! $name) {\n            $this->comment('A name for the documentation was not supplied. Use the --name option or set a default in the configuration.');\n\n            exit;\n        }\n\n        return $name;\n    }", "comment": ""}
{"lang": "cpp", "code": "def run(self):\n        '''  '''\n        plays = []\n        matched_tags_all = set()\n        unmatched_tags_all = set()\n\n        # loop through all patterns and run them\n        self.callbacks.on_start()\n        for (play_ds, play_basedir) in zip(self.playbook, self.play_basedirs):\n            play = Play(self, play_ds, play_basedir)\n            matched_tags, unmatched_tags = play.compare_tags(self.only_tags)\n            matched_tags_all = matched_tags_all | matched_tags\n            unmatched_tags_all = unmatched_tags_all | unmatched_tags\n\n            # if we have matched_tags, the play must be run.\n            # if the play contains no tasks, assume we just want to gather facts\n            if (len(matched_tags) > 0 or len(play.tasks()) == 0):\n                plays.append(play)\n\n        # if the playbook is invoked with --tags that don't exist at all in the playbooks\n        # then we need to raise an error so that the user can correct the arguments.\n        unknown_tags = set(self.only_tags) - (matched_tags_all | unmatched_tags_all)\n        unknown_tags.discard('all')\n\n        if len(unknown_tags) > 0:\n            unmatched_tags_all.discard('all')\n            msg = 'tag(s) not found in playbook: %s.  possible values: %s'\n            unknown = ','.join(sorted(unknown_tags))\n            unmatched = ','.join(sorted(unmatched_tags_all))\n            raise errors.AnsibleError(msg % (unknown, unmatched))\n\n        for play in plays:\n            if not self._run_play(play):\n                break\n\n        # summarize the results\n        results = {}\n        for host in self.stats.processed.keys():\n            results[host] = self.stats.summarize(host)\n        return results", "comment": ""}
{"lang": "cpp", "code": "def call(self, jsondata):\n        \n        result = yield self.call_py(jsondata)\n        if result is None:\n            defer.returnValue(None)\n        else:\n            defer.returnValue(json.dumps(result))", "comment": ""}
{"lang": "cpp", "code": "func (st *State) RemoveAllBlocksForController() error {\n\tblocks, err := st.AllBlocksForController()\n\tif err != nil {\n\t\treturn errors.Trace(err)\n\t}\n\n\tops := []txn.Op{}\n\tfor _, blk := range blocks {\n\t\tops = append(ops, txn.Op{\n\t\t\tC:      blocksC,\n\t\t\tId:     blk.Id(),\n\t\t\tRemove: true,\n\t\t})\n\t}\n\n\t// Use runRawTransaction as we might be removing docs across\n\t// multiple models.\n\treturn st.runRawTransaction(ops)\n}", "comment": ""}
{"lang": "cpp", "code": "protected void decodeOptionalBody(ISUPParameterFactory parameterFactory, byte[] parameterBody, byte parameterCode)\n            throws ParameterException {\n\n        switch (parameterCode & 0xFF) {\n            case CauseIndicators._PARAMETER_CODE:\n                CauseIndicators cpn = parameterFactory.createCauseIndicators();\n                ((AbstractISUPParameter) cpn).decode(parameterBody);\n                this.setCauseIndicators(cpn);\n                break;\n            default:\n                throw new ParameterException(\"Unrecognized parameter index for optional part: \" + parameterCode);\n        }\n\n    }", "comment": ""}
{"lang": "cpp", "code": "def cmd_layout(self, args):\n        ''''''\n        from MAVProxy.modules.lib import win_layout\n        if len(args) < 1:\n            print(\"usage: layout <save|load>\")\n            return\n        if args[0] == \"load\":\n            win_layout.load_layout(self.mpstate.settings.vehicle_name)\n        elif args[0] == \"save\":\n            win_layout.save_layout(self.mpstate.settings.vehicle_name)", "comment": ""}
{"lang": "cpp", "code": "public function getInfo($name)\n    {\n        $keys = explode('.', $name);\n        if (is_array($keys)) {\n            $file = array_shift($keys);\n            $key = implode('.', $keys);\n        } else {\n            $file = $name;\n            $key = null;\n        }\n\n        return ['file' => $file, 'key' => $key];\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *IndexFieldStatus) SetOptions(v *IndexField) *IndexFieldStatus {\n\ts.Options = v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "def is_muted(what):\n    \n\n    state = False\n\n    for item in solo:\n        if item not in what:\n            state = True\n        else:\n            state = False\n            break\n\n    for item in mute:\n        if item in what:\n            state = True\n            break\n\n    return state", "comment": ""}
{"lang": "cpp", "code": "func (s *JobOperation) Validate() error {\n\tinvalidParams := request.ErrInvalidParams{Context: \"JobOperation\"}\n\tif s.LambdaInvoke != nil {\n\t\tif err := s.LambdaInvoke.Validate(); err != nil {\n\t\t\tinvalidParams.AddNested(\"LambdaInvoke\", err.(request.ErrInvalidParams))\n\t\t}\n\t}\n\tif s.S3PutObjectAcl != nil {\n\t\tif err := s.S3PutObjectAcl.Validate(); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3PutObjectAcl\", err.(request.ErrInvalidParams))\n\t\t}\n\t}\n\tif s.S3PutObjectCopy != nil {\n\t\tif err := s.S3PutObjectCopy.Validate(); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3PutObjectCopy\", err.(request.ErrInvalidParams))\n\t\t}\n\t}\n\tif s.S3PutObjectTagging != nil {\n\t\tif err := s.S3PutObjectTagging.Validate(); err != nil {\n\t\t\tinvalidParams.AddNested(\"S3PutObjectTagging\", err.(request.ErrInvalidParams))\n\t\t}\n\t}\n\n\tif invalidParams.Len() > 0 {\n\t\treturn invalidParams\n\t}\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "def _diffsigma(self, Ep, Egamma):\n        \n        Tp = Ep - self._m_p\n\n        diffsigma = self._Amax(Tp) * self._F(Tp, Egamma)\n\n        if self.nuclear_enhancement:\n            diffsigma *= self._nuclear_factor(Tp)\n\n        return diffsigma", "comment": ""}
{"lang": "cpp", "code": "func (l *Locale) MarshalBinary() ([]byte, error) {\n\tobj := new(LocaleEncoding)\n\tobj.DefaultDomain = l.defaultDomain\n\tobj.Domains = make(map[string][]byte)\n\tfor k, v := range l.Domains {\n\t\tvar err error\n\t\tobj.Domains[k], err = v.MarshalBinary()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tobj.Lang = l.lang\n\tobj.Path = l.path\n\n\tvar buff bytes.Buffer\n\tencoder := gob.NewEncoder(&buff)\n\terr := encoder.Encode(obj)\n\n\treturn buff.Bytes(), err\n}", "comment": ""}
{"lang": "cpp", "code": "function mdlPublish(pubScope) {\n  let cacheTtl = null;\n  let src = null;\n  let dest = null;\n\n  if (pubScope === 'staging') {\n    // Set staging specific vars here.\n    cacheTtl = 0;\n    src = 'dist/*';\n    dest = bucketStaging;\n  } else if (pubScope === 'prod') {\n    // Set prod specific vars here.\n    cacheTtl = 60;\n    src = 'dist/*';\n    dest = bucketProd;\n  } else if (pubScope === 'promote') {\n    // Set promote (essentially prod) specific vars here.\n    cacheTtl = 60;\n    src = `${bucketStaging}/*`;\n    dest = bucketProd;\n  }\n\n  let infoMsg = `Publishing ${pubScope}/${pkg.version} to GCS (${dest})`;\n  if (src) {\n    infoMsg += ` from ${src}`;\n  }\n  console.log(infoMsg);\n\n  // Build gsutil commands:\n  // The gsutil -h option is used to set metadata headers.\n  // The gsutil -m option requests parallel copies.\n  // The gsutil -R option is used for recursive file copy.\n  const cacheControl = `-h \"Cache-Control:public,max-age=${cacheTtl}\"`;\n  const gsutilCacheCmd = `gsutil -m setmeta ${cacheControl} ${dest}/**`;\n  const gsutilCpCmd = `gsutil -m cp -r -z html,css,js,svg ${src} ${dest}`;\n\n  gulp.src('').pipe($.shell([gsutilCpCmd, gsutilCacheCmd]));\n}", "comment": ""}
{"lang": "cpp", "code": "def generate_wakeword_pieces(self, volume):\n        \"\"\"\"\"\"\n        while True:\n            target = 1 if random() > 0.5 else 0\n            it = self.pos_files_it if target else self.neg_files_it\n            sample_file = next(it)\n            yield self.layer_with(self.normalize_volume_to(load_audio(sample_file), volume), target)\n            yield self.layer_with(np.zeros(int(pr.sample_rate * (0.5 + 2.0 * random()))), 0)", "comment": ""}
{"lang": "cpp", "code": "void playTransition(@NonNull ViewGroup sceneRoot) {\n        mStartValuesList = new ArrayList<TransitionValues>();\n        mEndValuesList = new ArrayList<TransitionValues>();\n        matchStartAndEnd(mStartValues, mEndValues);\n\n        ArrayMap<Animator, AnimationInfo> runningAnimators = getRunningAnimators();\n        synchronized (sRunningAnimators) {\n            int numOldAnims = runningAnimators.size();\n            Object windowId = ViewUtils.getWindowId(sceneRoot);\n            for (int i = numOldAnims - 1; i >= 0; i--) {\n                Animator anim = runningAnimators.keyAt(i);\n                if (anim != null) {\n                    AnimationInfo oldInfo = runningAnimators.get(anim);\n                    if (oldInfo != null && oldInfo.view != null && oldInfo.windowId == windowId) {\n                        TransitionValues oldValues = oldInfo.values;\n                        View oldView = oldInfo.view;\n                        TransitionValues startValues = getTransitionValues(oldView, true);\n                        TransitionValues endValues = getMatchedTransitionValues(oldView, true);\n                        if (startValues == null && endValues == null) {\n                            endValues = mEndValues.viewValues.get(oldView);\n                        }\n                        boolean cancel = (startValues != null || endValues != null) &&\n                                oldInfo.transition.isTransitionRequired(oldValues, endValues);\n                        if (cancel) {\n                            if (anim.isRunning() || AnimatorUtils.isAnimatorStarted(anim)) {\n                                if (DBG) {\n                                    Log.d(LOG_TAG, \"Canceling anim \" + anim);\n                                }\n                                anim.cancel();\n                            } else {\n                                if (DBG) {\n                                    Log.d(LOG_TAG, \"removing anim from info list: \" + anim);\n                                }\n                                runningAnimators.remove(anim);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        createAnimators(sceneRoot, mStartValues, mEndValues, mStartValuesList, mEndValuesList);\n        runAnimators();\n    }", "comment": ""}
{"lang": "cpp", "code": "@SuppressWarnings(\"unchecked\")\n    public <T> T getAfterAdviceResult(String aspectId) {\n        return (aspectAdviceResult != null ? (T)aspectAdviceResult.getAfterAdviceResult(aspectId) : null);\n    }", "comment": ""}
{"lang": "cpp", "code": "@Override\r\n\tpublic <T> T toObject(String json, Class<T> clazz) {\r\n\t\treturn toObject(json, clazz, false);\r\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function add($command)\n    {\n        $tasks = $this->prepper\n                    ->load(get_class($command))\n                    ->describe();\n\n        $this->library->add(['task' => $tasks, 'class' => $command]);\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "public static void warn(Log log, String format, Object... arguments) {\r\n\t\twarn(log, null, format, arguments);\r\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function setParFormat(PHPRtfLite_ParFormat $parFormat)\n    {\n        $this->_rtf->registerParFormat($parFormat);\n        $this->_parFormat = $parFormat;\n    }", "comment": ""}
{"lang": "cpp", "code": "public final String apply(String input, Language inputLanguage) {\n    if (input != null && Config.get(this.getClass(), inputLanguage, \"apply\").asBoolean(true)) {\n      return performNormalization(input, inputLanguage);\n    }\n    return input;\n  }", "comment": ""}
{"lang": "cpp", "code": "@Override @NonNull @CheckReturnValue public Observable<Permission> requestEach(@NonNull final String... permissions) {\n    return Observable.just(TRIGGER)\n        .compose(ensureEach(permissions));\n  }", "comment": ""}
{"lang": "cpp", "code": "def get(self, zone_id):\n        \"\"\"\"\"\"\n        path = '/'.join(['zone', zone_id])\n        return self.rachio.get(path)", "comment": ""}
{"lang": "cpp", "code": "private void countPropertyReference(UsageStatistics usageStatistics,\n\t\t\tPropertyIdValue property, int count) {\n\t\taddPropertyCounters(usageStatistics, property);\n\t\tusageStatistics.propertyCountsReferences.put(property,\n\t\t\t\tusageStatistics.propertyCountsReferences.get(property) + count);\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function simplePaginate($per_page = null, $columns = ['*'], $page_name = 'page', $page = null)\n    {\n        $this->newQuery();\n\n        // Get the default per page when not set\n        $per_page = $per_page ?: config('repositories.per_page', 15);\n\n        return $this->query->simplePaginate($per_page, $columns, $page_name, $page);\n    }", "comment": ""}
{"lang": "cpp", "code": "private function getCommonType($fieldName, $nativeType)\n    {\n        static $types = [\n            // integers\n            'int' => CommonTypes::TINT,\n            'tinyint' => CommonTypes::TINT,\n            'smallint' => CommonTypes::TINT,\n            'bigint' => CommonTypes::TINT,\n            // floats\n            'float' => CommonTypes::TNUMBER,\n            'real' => CommonTypes::TNUMBER,\n            'decimal' => CommonTypes::TNUMBER,\n            'numeric' => CommonTypes::TNUMBER,\n            'money' => CommonTypes::TNUMBER,\n            'smallmoney' => CommonTypes::TNUMBER,\n            // dates\n            'date' => CommonTypes::TDATE,\n            'time' => CommonTypes::TTIME,\n            'datetime' => CommonTypes::TDATETIME,\n            'smalldatetime' => CommonTypes::TDATETIME,\n            // bool\n            'bit' => CommonTypes::TBOOL,\n            // text\n            'char' => CommonTypes::TTEXT,\n            'varchar' => CommonTypes::TTEXT,\n            'text' => CommonTypes::TTEXT,\n        ];\n        if (isset($this->overrideTypes[$fieldName])) {\n            return $this->overrideTypes[$fieldName];\n        }\n        $nativeType = strtolower($nativeType);\n        $type = CommonTypes::TTEXT;\n        if (array_key_exists($nativeType, $types)) {\n            $type = $types[$nativeType];\n        }\n        return $type;\n    }", "comment": ""}
{"lang": "cpp", "code": "def filtered_context(context):\n    \"\"\"\"\"\"\n\n    ctx = Context(context.opt)\n    for resource in context.resources():\n        if resource.child:\n            continue\n\n        if resource.filtered():\n            ctx.add(resource)\n\n    return ctx", "comment": ""}
{"lang": "cpp", "code": "public static function main($argc, array $argv = [])\n    {\n        $firstDay = new self(DayEnum::MONDAY());\n        $firstDay->tellItLikeItIs();\n        $thirdDay = new self(DayEnum::WEDNESDAY());\n        $thirdDay->tellItLikeItIs();\n        $fifthDay = new self(DayEnum::FRIDAY());\n        $fifthDay->tellItLikeItIs();\n        $sixthDay = new self(DayEnum::SATURDAY());\n        $sixthDay->tellItLikeItIs();\n        $seventhDay = new self(DayEnum::SUNDAY());\n        $seventhDay->tellItLikeItIs();\n\n        return 0;\n    }", "comment": ""}
{"lang": "cpp", "code": "private function checkLevel(int $level)\n    {\n        if ($level <= 0 || $level > self::MAX_LEVEL_DEPTH) {\n            throw new OutOfBounds(\n                sprintf('Administrative level should be an integer in [1,%d], %d given', self::MAX_LEVEL_DEPTH, $level)\n            );\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public static function compact($array, $reindex = false)\n    {\n        $out = array_filter($array, function ($item) {\n            return false !== (bool)$item;\n        });\n\n        return false !== $reindex && self::isList($out) ? array_values($out) : $out;\n    }", "comment": ""}
{"lang": "cpp", "code": "public static function add_contact(int $userid, int $contactid) {\n        global $DB;\n\n        $messagecontact = new \\stdClass();\n        $messagecontact->userid = $userid;\n        $messagecontact->contactid = $contactid;\n        $messagecontact->timecreated = time();\n        $messagecontact->id = $DB->insert_record('message_contacts', $messagecontact);\n\n        $eventparams = [\n            'objectid' => $messagecontact->id,\n            'userid' => $userid,\n            'relateduserid' => $contactid,\n            'context' => \\context_user::instance($userid)\n        ];\n        $event = \\core\\event\\message_contact_added::create($eventparams);\n        $event->add_record_snapshot('message_contacts', $messagecontact);\n        $event->trigger();\n    }", "comment": ""}
{"lang": "cpp", "code": "public void marshall(ExportSnapshotRecord exportSnapshotRecord, ProtocolMarshaller protocolMarshaller) {\n\n        if (exportSnapshotRecord == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(exportSnapshotRecord.getName(), NAME_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getArn(), ARN_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getCreatedAt(), CREATEDAT_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getLocation(), LOCATION_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getResourceType(), RESOURCETYPE_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getState(), STATE_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getSourceInfo(), SOURCEINFO_BINDING);\n            protocolMarshaller.marshall(exportSnapshotRecord.getDestinationInfo(), DESTINATIONINFO_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def is_multiple_of(ref):\n    \n    def is_multiple_of_ref(x):\n        if x % ref == 0:\n            return True\n        else:\n            raise IsNotMultipleOf(wrong_value=x, ref=ref)\n            # raise Failure('x % {ref} == 0 does not hold for x={val}'.format(ref=ref, val=x))\n\n    is_multiple_of_ref.__name__ = 'is_multiple_of_{}'.format(ref)\n    return is_multiple_of_ref", "comment": ""}
{"lang": "cpp", "code": "func (f *fieldHolder) AddFunc(fn func() (string, interface{}, error)) error {\n\tfor {\n\t\tkey, rawVal, err := fn()\n\t\tif err != nil {\n\t\t\t// fn is done giving us data\n\t\t\tbreak\n\t\t}\n\t\tf.AddField(key, rawVal)\n\t}\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "public function handleRemove(RemoveEvent $event)\n    {\n        $document = $event->getDocument();\n        $this->documentRegistry->deregisterDocument($document);\n    }", "comment": ""}
{"lang": "cpp", "code": "func CheckAddresses(uriList []string, schemes []string) (scheme string) {\n\tcount := len(uriList)\n\tif count < 1 {\n\t\tpanic(ErrURIListEmpty)\n\t}\n\tu, err := url.Parse(uriList[0])\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tscheme = u.Scheme\n\tif sort.SearchStrings(schemes, scheme) == len(schemes) {\n\t\tpanic(errors.New(\"This client desn't support \" + scheme + \" scheme.\"))\n\t}\n\tfor i := 1; i < count; i++ {\n\t\tu, err := url.Parse(uriList[i])\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\tif scheme != u.Scheme {\n\t\t\tpanic(ErrNotSupportMultpleProtocol)\n\t\t}\n\t}\n\treturn\n}", "comment": ""}
{"lang": "cpp", "code": "func (s *Budget) SetBudgetName(v string) *Budget {\n\ts.BudgetName = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "private String redisKey(ModelExt<?> m) {\n\t\tTable table = m.table();\n\t\tStringBuilder key = new StringBuilder();\n\t\tkey.append(RECORDS);\n\t\tkey.append(table.getName());\n\t\tkey.append(\":\");\n\t\t//fetch primary keys' values\n\t\tString[] primaryKeys = table.getPrimaryKey();\n\t\t//format key\n\t\tfor (int idx = 0; idx < primaryKeys.length; idx++) {\n\t\t\tObject primaryKeyVal = m.get(primaryKeys[idx]);\n\t\t\tif (null != primaryKeyVal) {\n\t\t\t\tif (idx > 0) {\n\t\t\t\t\tkey.append(\"|\");\n\t\t\t\t}\n\t\t\t\tkey.append(primaryKeyVal);\n\t\t\t}\n\t\t}\n\t\treturn key.toString();\n\t}", "comment": ""}
{"lang": "cpp", "code": "def delete(self, **params):\n        \"\"\"\"\"\"\n        d = self.request('delete', self.instance_url(), params)\n        return d.addCallback(self.refresh_from).addCallback(lambda _: self)", "comment": ""}
{"lang": "cpp", "code": "function readSpecFile(file, options) {\n    if (options.verbose > 1) {\n        file ? console.error('GET ' + file) : console.error('GET <stdin>');\n    }\n    if (!file) {\n        // standard input\n        return readFileStdinAsync();\n    } else if (file && file.startsWith('http')) {\n        // remote file\n        return fetch(file).then(res => {\n            if (res.status !== 200) {\n                throw new Error(`Received status code ${res.status}`);\n            }\n            return res.text();\n        })\n    } else {\n        // local file\n        // TODO error handlers?\n        return readFileAsync(file, 'utf8');\n    }\n}", "comment": ""}
{"lang": "cpp", "code": "protected function getRendererForFormat(string $format)\n    {\n        if (!isset($this->renderers[$format])) {\n            throw new InvalidRendererException('No renders found for the given format: '.$format);\n        }\n\n        return $this->renderers[$format];\n    }", "comment": ""}
{"lang": "cpp", "code": "def preprocess(string):\n    \n    string = unicode(string, encoding=\"utf-8\")\n    # convert diacritics to simpler forms\n    string = regex1.sub(lambda x: accents[x.group()], string)\n    # remove all rest of the unwanted characters\n    return regex2.sub('', string).encode('utf-8')", "comment": ""}
{"lang": "cpp", "code": "def build_method_summary_list(path_prefix=\"\")\n      collect_methods unless @methods\n      meths = @methods.sort\n      res = []\n      meths.each do |meth|\n\tres << {\n          \"name\" => CGI.escapeHTML(meth.name),\n          \"aref\" => \"#{path_prefix}\\##{meth.aref}\" \n        }\n      end\n      res\n    end", "comment": ""}
{"lang": "cpp", "code": "public SortedSet<T> firstSubset(SortedSet<T> set) {\n        if (this.rootNodes.isEmpty() || set == null || set.isEmpty()) {\n            return null;\n        }\n        return firstSubset(set, this.rootNodes);\n    }", "comment": ""}
{"lang": "cpp", "code": "private void processTaskEnterpriseColumns(Integer id, Task task, Var2Data taskVarData, byte[] metaData2)\n   {\n      if (metaData2 != null)\n      {\n         int bits = MPPUtility.getInt(metaData2, 29);\n         task.set(TaskField.ENTERPRISE_FLAG1, Boolean.valueOf((bits & 0x0000800) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG2, Boolean.valueOf((bits & 0x0001000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG3, Boolean.valueOf((bits & 0x0002000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG4, Boolean.valueOf((bits & 0x0004000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG5, Boolean.valueOf((bits & 0x0008000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG6, Boolean.valueOf((bits & 0x0001000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG7, Boolean.valueOf((bits & 0x0002000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG8, Boolean.valueOf((bits & 0x0004000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG9, Boolean.valueOf((bits & 0x0008000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG10, Boolean.valueOf((bits & 0x0010000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG11, Boolean.valueOf((bits & 0x0020000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG12, Boolean.valueOf((bits & 0x0040000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG13, Boolean.valueOf((bits & 0x0080000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG14, Boolean.valueOf((bits & 0x0100000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG15, Boolean.valueOf((bits & 0x0200000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG16, Boolean.valueOf((bits & 0x0400000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG17, Boolean.valueOf((bits & 0x0800000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG18, Boolean.valueOf((bits & 0x1000000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG19, Boolean.valueOf((bits & 0x2000000) != 0));\n         task.set(TaskField.ENTERPRISE_FLAG20, Boolean.valueOf((bits & 0x4000000) != 0));\n      }\n   }", "comment": ""}
{"lang": "cpp", "code": "protected function fetchService()\n\t{\n        $service = $this->getRouteParam('service');\n        $service = $this->parseCanonicalName($service, true);\n        \n        if (preg_match($this->servicePattern, $service)) {\n            return $service;\n        } else {\n            return false;\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *TypedLinkSpecifier) SetIdentityAttributeValues(v []*AttributeNameAndValue) *TypedLinkSpecifier {\n\ts.IdentityAttributeValues = v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "@Override\r\n  public void clear() {\r\n    // iterate over all keys in originalMap and set them to null in deltaMap\r\n    for (K key : originalMap.keySet()) {\r\n      deltaMap.put(key, ErasureUtils.<Collection<V>>uncheckedCast(removedValue));\r\n    }\r\n  }", "comment": ""}
{"lang": "cpp", "code": "func removeOpcode(pkscript []parsedOpcode, opcode byte) []parsedOpcode {\n\tretScript := make([]parsedOpcode, 0, len(pkscript))\n\tfor _, pop := range pkscript {\n\t\tif pop.opcode.value != opcode {\n\t\t\tretScript = append(retScript, pop)\n\t\t}\n\t}\n\treturn retScript\n}", "comment": ""}
{"lang": "cpp", "code": "public function setLanguage(\\BlackForest\\PiwikBundle\\Entity\\PiwikLanguage $language = null)\n    {\n        $this->language = $language;\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "def inspect\n      ['{config', *each.map{|key, value| \" \"+qualified_key(*key)+\" => \"+value.inspect },'}'].join(\"\\n\")\n    end", "comment": ""}
{"lang": "cpp", "code": "func (s *DeleteSubscriberInput) SetBudgetName(v string) *DeleteSubscriberInput {\n\ts.BudgetName = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public function getExtension($mimetype)\n    {\n        if (!($extension = array_search($mimetype, $this->mainMimeTypes))) {\n            $extension = array_search($mimetype, $this->mimeTypes);\n        }\n\n        return !$extension ? null : $extension;\n    }", "comment": ""}
{"lang": "cpp", "code": "function generatePath(path = \"/\", params = {}) {\n  return path === \"/\" ? path : compilePath(path)(params, { pretty: true });\n}", "comment": ""}
{"lang": "cpp", "code": "func (s *GetMaintenanceWindowOutput) SetScheduleTimezone(v string) *GetMaintenanceWindowOutput {\n\ts.ScheduleTimezone = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "public function getDimension(Image $image, $field)\n    {\n        if ($this->{$field}) {\n            return (new Dimension($image, $this->getDpr()))->get($this->{$field});\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function remove(PHPExcel_IComparable $pSource = null) {\n\t\t$hash = $pSource->getHashCode();\n\t\tif (isset($this->_items[$hash])) {\n\t\t\tunset($this->_items[$hash]);\n\n\t\t\t$deleteKey = -1;\n\t\t\tforeach ($this->_keyMap as $key => $value) {\n\t\t\t\tif ($deleteKey >= 0) {\n\t\t\t\t\t$this->_keyMap[$key - 1] = $value;\n\t\t\t\t}\n\n\t\t\t\tif ($value == $hash) {\n\t\t\t\t\t$deleteKey = $key;\n\t\t\t\t}\n\t\t\t}\n\t\t\tunset($this->_keyMap[count($this->_keyMap) - 1]);\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "def run(self):\n    \"\"\"\"\"\"\n    self.graphite.start()\n    while True:\n      log.debug('Graphite pusher is sleeping for %d seconds', self.period)\n      time.sleep(self.period)\n      log.debug('Pushing stats to Graphite')\n      try:\n        self.push()\n        log.debug('Done pushing stats to Graphite')\n      except:\n        log.exception('Exception while pushing stats to Graphite')\n        raise", "comment": ""}
{"lang": "cpp", "code": "func CheckShell(shell string) (string, error) {\n\tif _, ok := ValidShells[shell]; !ok {\n\t\treturn \"\", fmt.Errorf(\"unsupported shell: %q\", shell)\n\t}\n\tswitch shell {\n\tcase \"powershell\":\n\t\tif _, err := exec.LookPath(\"powershell\"); err == nil {\n\t\t\treturn \"powershell\", nil\n\t\t} else if _, err := exec.LookPath(\"pwsh\"); err == nil {\n\t\t\treturn \"pwsh\", nil\n\t\t} else {\n\t\t\treturn \"\", fmt.Errorf(\"powershell/pwsh not on path\")\n\t\t}\n\tcase \"modd\":\n\t\t// When testing, we're running under a special compiled test executable,\n\t\t// so we look for an instance of modd on our path.\n\t\tif shellTesting {\n\t\t\treturn exec.LookPath(\"modd\")\n\t\t}\n\t\treturn os.Executable()\n\tdefault:\n\t\treturn exec.LookPath(shell)\n\t}\n}", "comment": ""}
{"lang": "cpp", "code": "func (d *Adler32) Roll(b byte) {\n\t// This check costs 10-15% performance. If we disable it, we crash\n\t// when the window is empty. If we enable it, we are always correct\n\t// (an empty window never changes no matter how much you roll it).\n\t//if len(d.window) == 0 {\n\t//\treturn\n\t//}\n\t// extract the entering/leaving bytes and update the circular buffer.\n\tenter := uint32(b)\n\tleave := uint32(d.window[d.oldest])\n\td.window[d.oldest] = b\n\td.oldest += 1\n\tif d.oldest >= len(d.window) {\n\t\td.oldest = 0\n\t}\n\n\t// See http://stackoverflow.com/questions/40985080/why-does-my-rolling-adler32-checksum-not-work-in-go-modulo-arithmetic\n\td.a = (d.a + Mod + enter - leave) % Mod\n\td.b = (d.b + (d.n*leave/Mod+1)*Mod + d.a - (d.n * leave) - 1) % Mod\n}", "comment": ""}
{"lang": "cpp", "code": "def delete(self, id):\n        ''''''\n        if not self._item_path:\n            raise AttributeError('delete is not available for %s' % self._item_name)\n        target = self._item_path % id\n        self._redmine.delete(target)\n        return None", "comment": ""}
{"lang": "cpp", "code": "func (m *Message) SetTrackingOpens(trackingOpens bool) {\n\tm.trackingOpens = trackingOpens\n\tm.trackingOpensSet = true\n}", "comment": ""}
{"lang": "cpp", "code": "func Not(x interface{}) Matcher {\n\tif m, ok := x.(Matcher); ok {\n\t\treturn notMatcher{m}\n\t}\n\treturn notMatcher{Eq(x)}\n}", "comment": ""}
{"lang": "cpp", "code": "def prop_budget(self, budget):\n        \n\n        if self.minisat:\n            pysolvers.minisatgh_pbudget(self.minisat, budget)", "comment": ""}
{"lang": "cpp", "code": "public static function set($key, $value, $expire = 0) {\n        try {\n            self::getCache()->set($key, $value, $expire);\n            self::release();\n        } catch (\\RuntimeException $e) {\n            self::release();\n            throw $e;\n        } catch (\\Error $e) {\n            self::release();\n            throw $e;\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function output()\n    {\n        $attrs   = '';\n        $classes = 'fa-layers-text';\n        $transforms = '';\n\n        if (!empty($this->classes) && count($this->classes) > 0) {\n            $classes .= ' ' . implode(' ', $this->classes);\n        }\n\n        if (!empty($this->attributes) && count($this->attributes) > 0) {\n            foreach ($this->attributes as $attr => $val) {\n                $attrs .= ' ' . $attr . '=\"' . $val . '\"';\n            }\n        }\n\n        if (!empty($this->transforms) && count($this->transforms) > 0) {\n            $transformList = array();\n            foreach ($this->transforms as $transform) {\n                $transformList[] = implode('-', $transform);\n            }\n            $transforms = ' data-fa-transform=\"' . implode(' ', $transformList) . '\"';\n        }\n\n        return sprintf(self::TEXT_HTML, $classes, $attrs, $transforms, $this->text);\n    }", "comment": ""}
{"lang": "cpp", "code": "@SuppressWarnings(\"unused\") // called through reflection by RequestServer\n  public FramesV3 fetch(int version, FramesV3 s) {\n    FramesV3 frames = doFetch(version, s);\n\n    // Summary data is big, and not always there: null it out here.  You have to call columnSummary\n    // to force computation of the summary data.\n    for (FrameBaseV3 a_frame: frames.frames) {\n      ((FrameV3)a_frame).clearBinsField();\n    }\n\n    return frames;\n  }", "comment": ""}
{"lang": "cpp", "code": "@SuppressWarnings(\"unchecked\")\r\n    public void postValidate(Object object) throws DataValidationException {\r\n        if (_values != null || _ranges != null) {\r\n            if (_values != null) for (Object value: _values) {\r\n                if (value.equals(object)) return;\r\n            }\r\n\r\n            if (_ranges != null) for (@SuppressWarnings(\"rawtypes\") Range r: _ranges) {\r\n                @SuppressWarnings(\"rawtypes\")\r\n                Comparable o = (Comparable)object;\r\n                if (r.inclusive) {\r\n                    if ((r.min == null || r.min.compareTo(o) <= 0) && (r.max == null || o.compareTo(r.max) <= 0)) {\r\n                        return;\r\n                    }\r\n                } else {\r\n                    if ((r.min == null || r.min.compareTo(o) < 0) && (r.max == null || o.compareTo(r.max) < 0)) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n\r\n            throw new DataValidationException(\"VALUES/RANGES\", _name, object);\r\n        }\r\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function extractMediasFromContentType(ContentTypeInterface $contentType)\n    {\n        $mediaIds = array();\n        $fields = $contentType->getFields();\n\n        foreach ($fields as $field) {\n            if ($this->isMediaAttribute($field->getDefaultValue())) {\n                $mediaIds[] = $field->getDefaultValue()['id'];\n            }\n        }\n\n        return $mediaIds;\n    }", "comment": ""}
{"lang": "cpp", "code": "def splitters(self, value):\n        \n\n        if value is not None:\n            assert type(value) in (tuple, list), \"'{0}' attribute: '{1}' type is not 'tuple' or 'list'!\".format(\n                \"splitters\", value)\n            for element in value:\n                assert type(element) is unicode, \"'{0}' attribute: '{1}' type is not 'unicode'!\".format(\n                    \"splitters\", element)\n                assert len(element) == 1, \"'{0}' attribute: '{1}' has multiples characters!\".format(\n                    \"splitter\", element)\n                assert not re.search(r\"\\w\", element), \"'{0}' attribute: '{1}' is an alphanumeric character!\".format(\n                    \"splitter\", element)\n        self.__splitters = value", "comment": ""}
{"lang": "cpp", "code": "public void setSpeed(float newValue) {\n        if (newValue < 0) newValue = 0;\n        this.pitch.setValue( newValue );\n        this.speed.setValue( newValue );\n    }", "comment": ""}
{"lang": "cpp", "code": "function initialize() {\n  var flags = [];\n\n  Object.keys( levels ).forEach(function( type, level ) {\n    var method = type.toLowerCase();\n    exports[ method ] = log.bind( exports, type, level, false );\n    exports[ method ].json = log.bind( exports, type, level, true );\n    if ( new RegExp( '\\\\b' + type + '\\\\b', 'i' ).test( env ) ) {\n      flags.push( level );\n    }\n  });\n\n  loglevel = Math.min.apply( Math, flags );\n}", "comment": ""}
{"lang": "cpp", "code": "public static function createPresets($path = null, $callback = null) {\n        $moufManager = MoufManager::getMoufManager();\n        $instances = $moufManager->findInstances('Mouf\\\\Utils\\\\Graphics\\\\MoufImagine\\\\Controller\\\\ImagePresetController');\n        foreach ($instances as $instanceName) {\n            $instance = $moufManager->getInstance($instanceName);\n            if ($path && strpos($path, $instance->originalPath) !== false && $instance->createPresetsEnabled === true) {\n                $imagePath = substr($path, strlen($instance->originalPath) + 1);\n                $instance->image($imagePath);\n\n                if(is_callable($callback)) {\n                    $finalPath = ROOT_PATH . $instance->url . DIRECTORY_SEPARATOR . $imagePath;\n                    $callback($finalPath);\n                }\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public function next()\r\n\t{\r\n\t\tif ( is_null( $this->facts ) )\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t$this->yieldedFact = null;\r\n\r\n\t\t$success = $this->facts->next();\r\n\r\n\t\treturn $success;\r\n\t}", "comment": ""}
{"lang": "cpp", "code": "def compare_schemas(self, db_x, db_y, show=True):\n        \n        # TODO: Improve method\n        self._printer(\"\\tComparing database schema's {0} and {1}\".format(db_x, db_y))\n\n        # Run compare_dbs_getter to get row counts\n        x = self._schema_getter(db_x)\n        y = self._schema_getter(db_y)\n        x_count = len(x)\n        y_count = len(y)\n\n        # Check that database does not have zero tables\n        if x_count == 0:\n            self._printer('\\tThe database {0} has no tables'.format(db_x))\n            self._printer('\\tDatabase differencing was not run')\n            return None\n        elif y_count == 0:\n            self._printer('\\tThe database {0} has no tables'.format(db_y))\n            self._printer('\\tDatabase differencing was not run')\n            return None\n\n        # Print comparisons\n        if show:\n            uniques_x = diff(x, y, x_only=True)\n            if len(uniques_x) > 0:\n                self._printer('\\nUnique keys from {0} ({1} of {2}):'.format(db_x, len(uniques_x), x_count))\n                self._printer('------------------------------')\n                # print(uniques)\n                for k, v in sorted(uniques_x):\n                    self._printer('{0:25} {1}'.format(k, v))\n                self._printer('\\n')\n\n            uniques_y = diff(x, y, y_only=True)\n            if len(uniques_y) > 0:\n                self._printer('Unique keys from {0} ({1} of {2}):'.format(db_y, len(uniques_y), y_count))\n                self._printer('------------------------------')\n                for k, v in sorted(uniques_y):\n                    self._printer('{0:25} {1}'.format(k, v))\n                self._printer('\\n')\n\n            if len(uniques_y) == 0 and len(uniques_y) == 0:\n                self._printer(\"Databases's {0} and {1} are identical:\".format(db_x, db_y))\n                self._printer('------------------------------')\n\n        return diff(x, y)", "comment": ""}
{"lang": "cpp", "code": "public function index($type, Request $request)\n    {\n        try {\n            $resultColumns = [];\n            $query = $request->get('q');\n            $column = $request->get('c');\n\n            $model = app()->make(config('mentions.' . $type));\n\n            $records = $model->where($column, 'LIKE', \"%$query%\")\n                             ->get([$column]);\n\n            foreach ($records as $record) {\n                $resultColumns[] = $record->$column;\n            }\n\n            return response()->json($resultColumns);\n        } catch (\\ReflectionException $e) {\n            return response()->json('Not Found', 404);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "func NewRocR100ForStreamWithSrcLen(sourceLength uint, priceStream gotrade.DOHLCVStreamSubscriber, timePeriod int, selectData gotrade.DOHLCVDataSelectionFunc) (indicator *RocR100, err error) {\n\tind, err := NewRocR100WithSrcLen(sourceLength, timePeriod, selectData)\n\tpriceStream.AddTickSubscription(ind)\n\treturn ind, err\n}", "comment": ""}
{"lang": "cpp", "code": "public void reset()\n    {\n        try{\n            out=IO.getNullWriter();\n            super.flush();\n            out=new OutputStreamWriter(os,encoding);\n            written=false;\n        }\n        catch(UnsupportedEncodingException e)\n        {\n            log.fatal(e); System.exit(1);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def _payload_to_dict(self):\n        \n        if self.status != self.ERROR or not self.payload:\n            return self.payload\n\n        import traceback\n\n        return {\n            \"error\": self.payload.error,\n            \"args\": self.payload.args,\n            \"traceback\": traceback.format_exception(*self.payload.traceback)\n        }", "comment": ""}
{"lang": "cpp", "code": "func IsEmptyConfig(err error) bool {\n\tswitch t := err.(type) {\n\tcase errConfigurationInvalid:\n\t\treturn len(t) == 1 && t[0] == ErrEmptyConfig\n\t}\n\treturn err == ErrEmptyConfig\n}", "comment": ""}
{"lang": "cpp", "code": "public static String generatePreviousPreviousFileName() {\n\t\tStringBuffer name = new StringBuffer();\n\t\tname.append(\"Audit_Log-\").append(AuditUtil.dateToString(new Date(), \"yyyy-MM-dd\"))\n\t\t\t\t.append(CoreConstants.AUDIT_EXTENTION);\n\t\treturn name.toString();\n\t}", "comment": ""}
{"lang": "cpp", "code": "func (s *DeploymentInfo) SetDeploymentStatusMessages(v []*string) *DeploymentInfo {\n\ts.DeploymentStatusMessages = v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "protected function loadDependencies() /*: void*/\n    {\n        if (!$this->validate) {\n            $this->validate = Validate::getInstance();\n\n            if (!$this->config) {\n                // Use enviroment variable wrapper config class if exists;\n                // fall back on empty sectioned map.\n                try {\n                    if (class_exists('\\\\SimpleComplex\\\\Config\\\\EnvSectionedConfig')) {\n                        $this->config = call_user_func('\\\\SimpleComplex\\\\Config\\\\EnvSectionedConfig::getInstance');\n                    } else {\n                        $this->config = new SectionedMap();\n                    }\n                } catch (\\Throwable $ignore) {\n                    $this->config = new SectionedMap();\n                }\n            }\n            if (!$this->unicode) {\n                $this->unicode = Unicode::getInstance();\n            }\n            if (!$this->sanitize) {\n                $this->sanitize = Sanitize::getInstance();\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "private void encodeObject(StringBuffer result, Object value) {\n    if (value != null) {\n      if (value instanceof byte[]) {\n        result.append(\"[]\");\n        HexString.binToHex((byte[])value, 0, ((byte[])value).length, result);\n      } else\n        URLEncode(result, value.toString());\n    }", "comment": ""}
{"lang": "cpp", "code": "def _createunbound(kls, **info):\n    \"\"\"\"\"\"\n    \n    if issubclass(kls, Bitfield):\n        nodetype = UnboundBitfieldNode\n    elif hasattr(kls, '_fields_'):\n        nodetype = UnboundStructureNode\n    elif issubclass(kls, ctypes.Array):\n        nodetype = UnboundArrayNode\n    else:\n        nodetype = UnboundSimpleNode        \n    return nodetype(type=kls, **info)", "comment": ""}
{"lang": "cpp", "code": "public static function getInstance ()\n    {\n        // If this class is used for multiple singletons, we need to keep\n        // track of multiple singleton objects, one for each class name\n        static $instances = array();\n\n        // Get class name to use. Use late static binding here,\n        // if method is overriden by derived classes.\n        $singletonClassName = static::_getInstanceClassName();\n\n        // If already instantiated, use that\n        if (isset($instances[$singletonClassName])) {\n            return $instances[$singletonClassName];\n        }\n\n        // Otherwise create new instance\n        $instances[$singletonClassName] = new $singletonClassName (static::_getInstanceFuseValue());\n\n        return $instances[$singletonClassName];\n    }", "comment": ""}
{"lang": "cpp", "code": "function compile($expression) {\n        $options = $this->parser->parse($expression);\n        $command = $this->commandFactory->create($options);\n        return new Executable($command, $this->variables);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function display(): void\n    {\n        if (null === $this->format) {\n            $this->format = self::DEFAULT_FORMAT;\n        }\n\n        $this->render($this->buildLine());\n    }", "comment": ""}
{"lang": "cpp", "code": "private void addFieldRules( AnnotationInstance rulesContainerAnnotation, RuleInfo ruleInfo,\n                                boolean applyToAllLocales )\n    {\n        //\n        // First parse the locale from the wrapper annotation.  This will apply to all rules inside.\n        //\n        Locale locale = null;\n\n        if ( ! applyToAllLocales )\n        {\n            String language = CompilerUtils.getString( rulesContainerAnnotation, LANGUAGE_ATTR, true );\n\n            //\n            // If there's no language specified, then this rule will only apply for the default ruleset\n            // (i.e., if there are explicit rules for the requested locale, this rule will not be run).\n            //\n            if ( language != null )\n            {\n                String country = CompilerUtils.getString( rulesContainerAnnotation, COUNTRY_ATTR, true );\n                String variant = CompilerUtils.getString( rulesContainerAnnotation, VARIANT_ATTR, true );\n\n                language = language.trim();\n                if ( country != null ) country = country.trim();\n                if ( variant != null ) variant = variant.trim();\n\n                if ( country != null && variant != null ) locale = new Locale( language, country, variant );\n                else if ( country != null ) locale = new Locale( language, country );\n                else locale = new Locale( language );\n            }\n        }\n\n        Map valuesPresent = rulesContainerAnnotation.getElementValues();\n\n        for ( Iterator ii = valuesPresent.entrySet().iterator(); ii.hasNext(); )\n        {\n            Map.Entry entry = ( Map.Entry ) ii.next();\n            AnnotationValue value = ( AnnotationValue ) entry.getValue();\n            Object val = value.getValue();\n\n            if ( val instanceof AnnotationInstance )\n            {\n                addFieldRuleFromAnnotation( ruleInfo, ( AnnotationInstance ) val, locale, applyToAllLocales );\n            }\n            else if ( val instanceof List )\n            {\n                List annotations = CompilerUtils.getAnnotationArray( value );\n\n                for ( Iterator i3 = annotations.iterator(); i3.hasNext(); )\n                {\n                    AnnotationInstance i = ( AnnotationInstance ) i3.next();\n                    addFieldRuleFromAnnotation( ruleInfo, i, locale, applyToAllLocales );\n                }\n            }\n        }\n\n        setEmpty( false );  // this ValidationModel is only \"empty\" if there are no rules.\n    }", "comment": ""}
{"lang": "cpp", "code": "private function manageDeleteDocument(&$params, &$dmsLoader, &$manageCategory, &$arrMessages, &$blnShowStart, $documentId)\n  {\n    $params->loadRootCategory = true; // get complete path to root, for checking inherited access rights\n    $params->loadAccessRights = true;\n    $params->loadDocuments = false;\n    $category = $dmsLoader->loadCategory($manageCategory, $params);\n    \n    if (!$category->isDeletableForCurrentMember())\n    {\n      $arrMessages['errors'][] = $GLOBALS['TL_LANG']['DMS']['ERR']['manage_document_not_allowed'];\n      $blnShowStart = true;\n    }\n    else\n    {\n      $document = $dmsLoader->loadDocument($documentId, $params);\n      \n      if ($document != null)\n      {\n        // delete the document in the database\n        $dmsWriter = \\DmsWriter::getInstance();\n        \n        if ($dmsWriter->deleteDocument($document))\n        {\n          $arrMessages['successes'][] = $GLOBALS['TL_LANG']['DMS']['SUCCESS']['document_successfully_deleted'];\n          \n          // delete the file\n          $filePath = \\DmsConfig::getDocumentFilePath($document->getFileNameVersioned());\n          if (file_exists(TL_ROOT . '/' . $filePath))\n          {\n            unlink($filePath);\n            \\Dbafs::deleteResource($filePath);\n            \n            $arrMessages['successes'][] = $GLOBALS['TL_LANG']['DMS']['SUCCESS']['document_file_successfully_deleted'];\n          }\n          else\n          {\n            $arrMessages['infos'][] = $GLOBALS['TL_LANG']['DMS']['INFO']['document_delete_file_not_exists'];\n          }\n        }\n        else\n        {\n          $arrMessages['errors'][] = $GLOBALS['TL_LANG']['DMS']['ERR']['delete_document_failed'];\n        }\n      }\n      else\n      {\n        $arrMessages['errors'][] = $GLOBALS['TL_LANG']['DMS']['ERR']['manage_document_not_found'];\n      }\n      $this->manageSelectDocument($params, $dmsLoader, $manageCategory, $arrMessages, $blnShowStart);\n    }\n  }", "comment": ""}
{"lang": "cpp", "code": "public static String get(PropertyKey key, ConfigurationValueOptions options) {\n    return sConf.get(key, options);\n  }", "comment": ""}
{"lang": "cpp", "code": "protected function _generateVendorDir($sVendor)\n    {\n        $sVendorDir = $this->_sModuleDir . $sVendor . DIRECTORY_SEPARATOR;\n        if (!file_exists($sVendorDir)) {\n            mkdir($sVendorDir);\n\n            // Generate vendor metadata file\n            file_put_contents($sVendorDir . 'vendormetadata.php', '<?php');\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "public int readRawLittleEndian32() throws IOException\r\n    {\r\n        final byte[] buffer = this.buffer;\r\n        int offset = this.offset;\r\n\r\n        final byte b1 = buffer[offset++];\r\n        final byte b2 = buffer[offset++];\r\n        final byte b3 = buffer[offset++];\r\n        final byte b4 = buffer[offset++];\r\n\r\n        this.offset = offset;\r\n\r\n        return (((int) b1 & 0xff)) |\r\n                (((int) b2 & 0xff) << 8) |\r\n                (((int) b3 & 0xff) << 16) |\r\n                (((int) b4 & 0xff) << 24);\r\n    }", "comment": ""}
{"lang": "cpp", "code": "public function evaluate(FlowQuery $flowQuery, array $arguments)\n    {\n        $subject = $arguments[0];\n        if (!isset($subject) || empty($subject)) {\n            $flowQuery->setContext([]);\n            return;\n        }\n\n        $filteredContext = [];\n        $context = $flowQuery->getContext();\n        if (is_string($subject)) {\n            foreach ($context as $contextElement) {\n                $contextElementQuery = new FlowQuery([$contextElement]);\n                $contextElementQuery->pushOperation('children', $arguments);\n                if ($contextElementQuery->count() > 0) {\n                    $filteredContext[] = $contextElement;\n                }\n            }\n        } else {\n            if ($subject instanceof FlowQuery) {\n                $elements = $subject->get();\n            } elseif ($subject instanceof \\Traversable) {\n                $elements = iterator_to_array($subject);\n            } elseif (is_object($subject)) {\n                $elements = [$subject];\n            } elseif (is_array($subject)) {\n                $elements = $subject;\n            } else {\n                throw new FizzleException('supplied argument for has operation not supported', 1332489625);\n            }\n            foreach ($elements as $element) {\n                if ($element instanceof TraversableNodeInterface) {\n                    $parentsQuery = new FlowQuery([$element]);\n                    foreach ($parentsQuery->parents([])->get() as $parent) {\n                        /** @var TraversableNodeInterface $parent */\n                        foreach ($context as $contextElement) {\n                            /** @var TraversableNodeInterface $contextElement */\n                            if ($contextElement === $parent) {\n                                $filteredContext[] = $contextElement;\n                            }\n                        }\n                    }\n                }\n            }\n            $filteredContext = array_unique($filteredContext);\n        }\n\n        $flowQuery->setContext($filteredContext);\n    }", "comment": ""}
{"lang": "cpp", "code": "private function ensureExists($dir)\n    {\n        if (!is_dir($dir)) {\n            mkdir($dir, 0755, true);\n        }\n\n        return $this->validatePath($dir);\n    }", "comment": ""}
{"lang": "cpp", "code": "func (apigError *Error) Error() string {\n\tbytes, bytesErr := json.Marshal(apigError)\n\tif bytesErr != nil {\n\t\tbytes = []byte(http.StatusText(http.StatusInternalServerError))\n\t}\n\treturn string(bytes)\n}", "comment": ""}
{"lang": "cpp", "code": "protected function clearPairs(/*# array */ $matched)/*# : array */\n    {\n        $pairs = [];\n        foreach ($matched as $m) {\n            // source another env file\n            if (isset($m[5])) {\n                $file = trim($m[5]);\n                $pairs[$file] = $this->source_marker;\n\n            // value found\n            } elseif (isset($m[3])) {\n                $pairs[$m[1]] = $m[3];\n\n            // no value defined\n            } else {\n                $pairs[$m[1]] = '';\n            }\n        }\n        return $pairs;\n    }", "comment": ""}
{"lang": "cpp", "code": "function () {\n    this.events.on('report:run:browser', this.runBrowser.bind(this));\n    this.events.on('report:assertion', this.assertion.bind(this));\n    this.events.on('report:test:started', this.testStarted.bind(this));\n    this.events.on('report:test:finished', this.testFinished.bind(this));\n    this.events.on('report:runner:finished', this.runnerFinished.bind(this));\n    this.events.on('report:testsuite:started', this.testsuiteStarted.bind(this));\n    //this.events.on('report:testsuite:finished', this.testsuiteFinished.bind(this));\n    return this;\n  }", "comment": ""}
{"lang": "cpp", "code": "private ParseTree parseLabelledStatement() {\n    SourcePosition start = getTreeStartLocation();\n    IdentifierToken name = eatId();\n    eat(TokenType.COLON);\n    return new LabelledStatementTree(getTreeLocation(start), name, parseStatement());\n  }", "comment": ""}
{"lang": "cpp", "code": "public function listRemoteEpisodes(Keychain $keychain)\n    {\n        $episodes_url = $this->get('bprs_applink')->getApiUrlsForKey(\n            $keychain,\n            'oktolab_media_api_list_episodes'\n        );\n\n        if ($episodes_url) {\n            $client = new Client();\n            $response = $client->request(\n                'GET',\n                $episodes_url,\n                ['auth' => [$keychain->getUser(), $keychain->getApiKey()]]\n            );\n\n            if ($response->getStatusCode() == 200) {\n                $info = json_decode(\n                    html_entity_decode((string)$response->getBody()), true\n                );\n\n                return ['result' => $info, 'keychain' => $keychain];\n            }\n        }\n\n        return new Response('', Response::HTTP_BAD_REQUEST);\n    }", "comment": ""}
{"lang": "cpp", "code": "function symbolIsSpecial(NumberPatternSymbol $symbol, array $is) {\n    return !$symbol->escaped && in_array($symbol->symbol, $is, TRUE);\n  }", "comment": ""}
{"lang": "cpp", "code": "function invoke() {\n        parent::invoke();\n\n        $result = true;\n\n        // Set own core attributes\n        $this->does_generate = ACTION_NONE;\n\n        // These are always here\n        global $CFG, $XMLDB;\n\n        // Do the job, setting result as needed\n\n        // Get the dir containing the file\n        $dirpath = required_param('dir', PARAM_PATH);\n        $dirpath = $CFG->dirroot . $dirpath;\n\n        // Get the original dir and delete some elements\n        if (!empty($XMLDB->dbdirs)) {\n            if (isset($XMLDB->dbdirs[$dirpath])) {\n                $dbdir = $XMLDB->dbdirs[$dirpath];\n                if ($dbdir) {\n                    unset($dbdir->xml_file);\n                    unset($dbdir->xml_loaded);\n                    unset($dbdir->xml_changed);\n                    unset($dbdir->xml_exists);\n                    unset($dbdir->xml_writeable);\n                }\n            }\n        }\n        // Get the edited dir and delete it completely\n        if (!empty($XMLDB->editeddirs)) {\n            if (isset($XMLDB->editeddirs[$dirpath])) {\n                unset($XMLDB->editeddirs[$dirpath]);\n            }\n        }\n\n        // Launch postaction if exists (leave this here!)\n        if ($this->getPostAction() && $result) {\n            return $this->launch($this->getPostAction());\n        }\n\n        // Return ok if arrived here\n        return $result;\n    }", "comment": ""}
{"lang": "cpp", "code": "func Beep(freq float64, duration int) error {\n\tif freq == 0 {\n\t\tfreq = DefaultFreq\n\t} else if freq > 32767 {\n\t\tfreq = 32767\n\t} else if freq < 37 {\n\t\tfreq = DefaultFreq\n\t}\n\n\tif duration == 0 {\n\t\tduration = DefaultDuration\n\t}\n\n\tkernel32, _ := syscall.LoadLibrary(\"kernel32.dll\")\n\tbeep32, _ := syscall.GetProcAddress(kernel32, \"Beep\")\n\n\tdefer syscall.FreeLibrary(kernel32)\n\n\t_, _, e := syscall.Syscall(uintptr(beep32), uintptr(2), uintptr(int(freq)), uintptr(duration), 0)\n\tif e != 0 {\n\t\treturn e\n\t}\n\n\treturn nil\n}", "comment": ""}
{"lang": "cpp", "code": "public Map<String, String> getProperty() {\n\n        if (m_properties == null) {\n            try {\n                List<CmsProperty> properties = m_cms.readPropertyObjects(this, false);\n                m_properties = CmsProperty.toMap(properties);\n            } catch (CmsException e) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(e.getMessage(), e);\n                }\n            }\n        }\n        return m_properties;\n    }", "comment": ""}
{"lang": "cpp", "code": "def write(self, msg):\n        \n        ser = msg.SerializeToString()\n        header = struct.pack(\">HL\", mapping.get_type(msg), len(ser))\n        self._write(b\"##\" + header + ser, msg)", "comment": ""}
{"lang": "cpp", "code": "public function tokenizeCard(CreditCard $card)\n    {\n        $tokenizeCardRequest = new TokenizeCardRequest($this->merchant, $this->environment);\n\n        return $tokenizeCardRequest->execute($card);\n    }", "comment": ""}
{"lang": "cpp", "code": "final public function dropTables(array $tables, $fkChecks = false)\n    {\n        // Whether FK checks are enabled\n        if ($fkChecks == false) {\n            $this->db->raw('SET FOREIGN_KEY_CHECKS=0')\n                     ->execute();\n        }\n\n        foreach ($tables as $table) {\n            if (!$this->dropTable($table)) {\n                return false;\n            }\n        }\n\n        // Whether FK checks are enabled\n        if ($fkChecks == false) {\n            $this->db->raw('SET FOREIGN_KEY_CHECKS=1')\n                     ->execute();\n        }\n\n        return true;\n    }", "comment": ""}
{"lang": "cpp", "code": "private function doDetach($entity, array &$visited, $noCascade = false)\n    {\n        $oid = spl_object_hash($entity);\n\n        if (isset($visited[$oid])) {\n            return; // Prevent infinite recursion\n        }\n\n        $visited[$oid] = $entity; // mark visited\n\n        switch ($this->getEntityState($entity, self::STATE_DETACHED)) {\n            case self::STATE_MANAGED:\n                if ($this->isInIdentityMap($entity)) {\n                    $this->removeFromIdentityMap($entity);\n                }\n\n                unset(\n                    $this->entityInsertions[$oid],\n                    $this->entityUpdates[$oid],\n                    $this->entityDeletions[$oid],\n                    $this->entityIdentifiers[$oid],\n                    $this->entityStates[$oid],\n                    $this->originalEntityData[$oid]\n                );\n                break;\n            case self::STATE_NEW:\n            case self::STATE_DETACHED:\n                return;\n        }\n\n        if ( ! $noCascade) {\n            $this->cascadeDetach($entity, $visited);\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "private function resolveAttributesFromAssertion(array $attributes, Assertion $assertion)\n    {\n        $attributeStatements = $assertion->getAllAttributeStatements();\n\n        return array_reduce($attributeStatements, [$this, 'resolveAttributesFromAttributeStatement'], $attributes);\n    }", "comment": ""}
{"lang": "cpp", "code": "public static Date toDate(final Object value) {\r\n\t\tif (value instanceof Date) {\r\n\t\t\treturn (Date) value;\r\n\t\t}\r\n\t\tif (value == null || value.equals(\"null\")) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif (value instanceof String) {\r\n\t\t\tthrow new IllegalStateException(\"fix me\");\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}", "comment": ""}
{"lang": "cpp", "code": "function (d, chart, series) {\n            var returnCx = 0;\n            if (series.x.measure !== null && series.x.measure !== undefined) {\n                returnCx = series.x._scale(d.cx);\n            } else if (series.x._hasCategories() && series.x.categoryFields.length >= 2) {\n                returnCx = series.x._scale(d.cx) + dimple._helpers.xGap(chart, series) + ((d.xOffset + 0.5) * (((chart._widthPixels() / series.x._max) - 2 * dimple._helpers.xGap(chart, series)) * d.width));\n            } else {\n                returnCx = series.x._scale(d.cx) + ((chart._widthPixels() / series.x._max) / 2);\n            }\n            return returnCx;\n        }", "comment": ""}
{"lang": "cpp", "code": "public static function patch($uri, $payload = null, $mime = null)\n    {\n        return self::init(Http::PATCH)->uri($uri)->body($payload, $mime);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function serialize(Ability $ability, array $options = [])\n    {\n        $serialized = [\n            'id' => $ability->getUuid(),\n            'name' => $ability->getName(),\n            'minResourceCount' => $ability->getMinResourceCount(),\n            'minEvaluatedResourceCount' => $ability->getMinEvaluatedResourceCount(),\n        ];\n\n        return $serialized;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (session *Session) NoAutoCondition(no ...bool) *Session {\n\tsession.Statement.NoAutoCondition(no...)\n\treturn session\n}", "comment": ""}
{"lang": "cpp", "code": "def _homogenize_data_filter(dfilter):\n    \n    if isinstance(dfilter, tuple) and (len(dfilter) == 1):\n        dfilter = (dfilter[0], None)\n    if (dfilter is None) or (dfilter == (None, None)) or (dfilter == (None,)):\n        dfilter = (None, None)\n    elif isinstance(dfilter, dict):\n        dfilter = (dfilter, None)\n    elif isinstance(dfilter, (list, str)) or (\n        isinstance(dfilter, int) and (not isinstance(dfilter, bool))\n    ):\n        dfilter = (None, dfilter if isinstance(dfilter, list) else [dfilter])\n    elif isinstance(dfilter[0], dict) or (\n        (dfilter[0] is None) and (not isinstance(dfilter[1], dict))\n    ):\n        pass\n    else:\n        dfilter = (dfilter[1], dfilter[0])\n    return dfilter", "comment": ""}
{"lang": "cpp", "code": "def modifyContacts(self, contactids, paused):\n        \n\n        response = self.request(\"PUT\", \"notification_contacts\", {'contactids': contactids,\n                                                    'paused': paused})\n        return response.json()['message']", "comment": ""}
{"lang": "cpp", "code": "def group_id(self):\n        \n        if self.derived_from is not None:\n            return self.derived_from.group_id()\n        if self.file_uuid is None:\n            return None\n        return utils.GROUP_ID_PREFIX + self.file_uuid", "comment": ""}
{"lang": "cpp", "code": "function TypedArray (config) {\n    const array = this;\n\n    // validate min items\n    if (config.hasOwnProperty('minItems') && (!util.isInteger(config.minItems) || config.minItems < 0)) {\n        throw Error('Invalid configuration value for property: minItems. Must be an integer that is greater than or equal to zero. Received: ' + config.minItems);\n    }\n    const minItems = config.hasOwnProperty('minItems') ? config.minItems : 0;\n\n    // validate max items\n    if (config.hasOwnProperty('maxItems') && (!util.isInteger(config.maxItems) || config.maxItems < minItems)) {\n        throw Error('Invalid configuration value for property: maxItems. Must be an integer that is greater than or equal to the minItems. Received: ' + config.maxItems);\n    }\n\n    // validate schema\n    if (config.hasOwnProperty('schema')) config.schema = FullyTyped(config.schema);\n\n    // define properties\n    Object.defineProperties(array, {\n\n        maxItems: {\n            /**\n             * @property\n             * @name TypedArray#maxItems\n             * @type {number}\n             */\n            value: Math.round(config.maxItems),\n            writable: false\n        },\n\n        minItems: {\n            /**\n             * @property\n             * @name TypedArray#minItems\n             * @type {number}\n             */\n            value: Math.round(config.minItems),\n            writable: false\n        },\n\n        schema: {\n            /**\n             * @property\n             * @name TypedArray#schema\n             * @type {object}\n             */\n            value: config.schema,\n            writable: false\n        },\n\n        uniqueItems: {\n            /**\n             * @property\n             * @name TypedArray#uniqueItems\n             * @type {boolean}\n             */\n            value: !!config.uniqueItems,\n            writable: false\n        }\n\n    });\n\n    return array;\n}", "comment": ""}
{"lang": "cpp", "code": "public String getLocalAddr() {\n\t\tfinal SIPTransaction sipTransaction = (SIPTransaction)getTransaction();\n\t\tif(sipTransaction != null) {\n\t\t\treturn sipTransaction.getHost();\n\t\t} else {\n\t\t\tfinal String transport = JainSipUtils.findTransport(message);\n\t\t\tfinal MobicentsExtendedListeningPoint listeningPoint = sipFactoryImpl.getSipNetworkInterfaceManager().findMatchingListeningPoint(transport, false);\n\t\t\treturn listeningPoint.getHost(true);\n\t\t}\n\t}", "comment": ""}
{"lang": "cpp", "code": "public static function export($value)\n\t{\n\t\tif (!is_scalar($value))\n\t\t{\n\t\t\tthrow new InvalidArgumentException(__METHOD__ . '() cannot export non-scalar values');\n\t\t}\n\t\tif (is_int($value))\n\t\t{\n\t\t\treturn (string) $value;\n\t\t}\n\t\tif (is_float($value))\n\t\t{\n\t\t\t// Avoid locale issues by using sprintf()\n\t\t\treturn preg_replace('(\\\\.?0+$)', '', sprintf('%F', $value));\n\t\t}\n\n\t\treturn self::exportString((string) $value);\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function setAddress($value)\n    {\n        if (is_array($value)) {\n            $value = new Address($value);\n        }\n        return $this->setParameter('address', $value);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getConnection(array $params, $type) {\n        if ($type == 'S') {\n            $host = (!empty($params['num_ip'])) ? $params['num_ip'] : '127.0.0.1';\n            $community = (!empty($params['des_snmp_community'])) ? $params['des_snmp_community'] : 'public';\n            $version = (!empty($params['des_snmp_version'])) ? $params['des_snmp_version'] : '2c';\n            $seclevel = (!empty($params['des_snmp_sec_level'])) ? $params['des_snmp_sec_level'] : 'noAuthNoPriv';\n            $authprotocol = (!empty($params['des_snmp_auth_protocol'])) ? $params['des_snmp_auth_protocol'] : 'MD5';\n            $authpassphrase = (!empty($params['des_snmp_auth_passphrase'])) ? $params['des_snmp_auth_passphrase'] : 'None';\n            $privprotocol = (!empty($params['des_snmp_priv_protocol'])) ? $params['des_snmp_priv_protocol'] : 'DES';\n            $privpassphrase = (!empty($params['des_snmp_priv_passphrase'])) ? $params['des_snmp_priv_passphrase'] : 'None';\n\n            $connection = new \\Cityware\\Snmp\\SNMP($host, $community, $version, $seclevel, $authprotocol, $authpassphrase, $privprotocol, $privpassphrase);\n            $connection->setSecLevel(3);\n            $connection->disableCache();\n\n            $this->setSnmpCon($connection);\n        } else if ($type == 'W') {\n            $host = (!empty($params['num_ip'])) ? $params['num_ip'] : '127.0.0.1';\n            $username = (!empty($params['des_wmi_user'])) ? $params['des_wmi_user'] : null;\n            $password = (!empty($params['des_wmi_password'])) ? $params['des_wmi_password'] : null;\n            $domain = (!empty($params['des_wmi_domain'])) ? $params['des_wmi_domain'] : null;\n            $wmi = new \\Cityware\\Wmi\\Wmi($host, $username, $password, $domain);\n            $connection = $wmi->connect('root\\\\cimv2');\n            $this->setWmiCon($connection);\n        }\n\n        return $connection;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function markNodeActive($nodeId)\n    {\n        $xPath = new DOMXPath($this->getDomXml());\n        $nodeList = $xPath->query(\"//*[@cl='{$nodeId}' or @list='{$nodeId}']\");\n\n        if ($nodeList->length) {\n            foreach ($nodeList as $node) {\n                // special case for external resources\n                $node->setAttribute('active', 1);\n                $node->parentNode->setAttribute('active', 1);\n            }\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "def delete_keys(self, keys, secret=False):\n        '''\n        \n        '''\n        return self.execute(\n            DeleteResult(),\n            ['--batch', '--yes', '--delete-secret-key' if secret else '--delete-key'] + list(make_list(keys))\n        )", "comment": ""}
{"lang": "cpp", "code": "public function unique() : Collection\n    {\n        $acc = [];\n        foreach ($this->list as $item) {\n            if (!in_array($item, $acc)) {\n                $acc[] = $item;\n            }\n        }\n\n        return self::from(...$acc);\n    }", "comment": ""}
{"lang": "cpp", "code": "def systemctl_autostart(self, service_name, start_cmd, stop_cmd):\n        \n        # get config content\n        service_content = bigdata_conf.systemctl_config.format(\n            service_name=service_name,\n            start_cmd=start_cmd,\n            stop_cmd=stop_cmd\n        )\n\n        # write config into file\n        with cd('/lib/systemd/system'):\n            if not exists(service_name):\n                sudo('touch {0}'.format(service_name))\n            put(StringIO(service_content), service_name, use_sudo=True)\n\n        # make service auto-start\n        sudo('systemctl daemon-reload')\n        sudo('systemctl disable {0}'.format(service_name))\n        sudo('systemctl stop {0}'.format(service_name))\n        sudo('systemctl enable {0}'.format(service_name))\n        sudo('systemctl start {0}'.format(service_name))", "comment": ""}
{"lang": "cpp", "code": "def url(self, url):\n        \n        if url is None:\n            return\n        el_FLocat = self._el.find('mets:FLocat', NS)\n        if el_FLocat is None:\n            el_FLocat = ET.SubElement(self._el, TAG_METS_FLOCAT)\n        el_FLocat.set(\"{%s}href\" % NS[\"xlink\"], url)", "comment": ""}
{"lang": "cpp", "code": "public function setUseCustomerKey( $use_customer_key )\n\t{\n\t\t$this->use_customer_key = ($use_customer_key == 1 || $use_customer_key == 'Y' || $use_customer_key === TRUE) ? TRUE : FALSE;\n\n\t\treturn $this;\n\t}", "comment": ""}
{"lang": "cpp", "code": "@XmlElementDecl(namespace = \"http://www.w3.org/1998/Math/MathML\", name = \"msup\")\n    public JAXBElement<MsupType> createMsup(MsupType value) {\n        return new JAXBElement<MsupType>(_Msup_QNAME, MsupType.class, null, value);\n    }", "comment": ""}
{"lang": "cpp", "code": "static byte[] sha1(InputStream in) {\n    try {\n      MessageDigest md = MessageDigest.getInstance(SHA1_DIGEST); \n      byte[] buffer = new byte[4096];\n      int bytes;\n      while ( (bytes = in.read(buffer)) > 0) {\n        md.update(buffer, 0, bytes);\n      }\n      return md.digest();\n    }\n    catch(NoSuchAlgorithmException | IOException e) {\n      throw new InternalErrorException(e);\n    }\n  }", "comment": ""}
{"lang": "cpp", "code": "func SplitFullName(fullName string) (string, string) {\n\tnameComponents := strings.Split(fullName, \" \")\n\tfirstName := nameComponents[0]\n\tlastName := \"\"\n\tif len(nameComponents) > 1 {\n\t\tlastName = strings.Join(nameComponents[1:], \" \")\n\t}\n\treturn firstName, lastName\n}", "comment": ""}
{"lang": "cpp", "code": "private static function _setWhere($where, QueryBuilder $query, string $primaryKey = \"id\") : QueryBuilder\n    {\n        if(!is_array($where)) {\n            return $query->where([\n                $primaryKey => $where\n            ]);\n        }\n\n        $columns = $where;\n\n        unset($columns[\"ORDER BY\"]);\n        unset($columns[\"LIMIT\"]);\n        unset($columns[\"OFFSET\"]);\n\n        if(!empty($columns)) {\n            $query->where($columns);\n        }\n\n        if(isset($where[\"ORDER BY\"])) {\n            $order = $where[\"ORDER BY\"];\n            if(!is_array($order)) {\n                $order = [$order];\n            }\n\n            $query->order(... $order);\n        }\n        if(isset($where[\"LIMIT\"])) {\n            $limit = $where[\"LIMIT\"];\n            if(!is_array($limit)) {\n                $limit = [$limit];\n            }\n\n            $query->limit(... $limit);\n        }\n        if(isset($where[\"OFFSET\"])) {\n            $query->offset($where[\"OFFSET\"]);\n        }\n\n        return $query;\n    }", "comment": ""}
{"lang": "cpp", "code": "def create_enum(enum_type, help_string=NO_HELP, default=NO_DEFAULT):\n        # type: (Type[Enum], str, Union[Any, NO_DEFAULT_TYPE]) -> Type[Enum]\n        \n        # noinspection PyTypeChecker\n        return ParamEnum(\n            help_string=help_string,\n            default=default,\n            enum_type=enum_type,\n        )", "comment": ""}
{"lang": "cpp", "code": "function e(label, gen) {\n  if (!gen) {\n    gen = label;\n    label = '';\n  }\n\n  if (!enabled) {\n    return gen;\n  }\n\n  var hackErr = new Error('hack');\n  hackErr.label = label;\n\n  return function *() {\n    try {\n      return yield gen;\n    } catch(err) {\n      throw buildError(err, hackErr);\n    }\n  };\n}", "comment": ""}
{"lang": "cpp", "code": "public function addFaxe(\\Sulu\\Bundle\\ContactBundle\\Entity\\Fax $faxes)\n    {\n        $this->faxes[] = $faxes;\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function listViews()\n    {\n        $database = $this->_conn->getDatabase();\n        $sql      = $this->_platform->getListViewsSQL($database);\n        $views    = $this->_conn->fetchAll($sql);\n\n        return $this->_getPortableViewsList($views);\n    }", "comment": ""}
{"lang": "cpp", "code": "def account_block(self, id):\n        \n        id = self.__unpack_id(id)\n        url = '/api/v1/accounts/{0}/block'.format(str(id))\n        return self.__api_request('POST', url)", "comment": ""}
{"lang": "cpp", "code": "func (ti *TabletInfo) MysqlAddr() string {\n\treturn netutil.JoinHostPort(topoproto.MysqlHostname(ti.Tablet), topoproto.MysqlPort(ti.Tablet))\n}", "comment": ""}
{"lang": "cpp", "code": "func (resource *AppointmentResponse) MarshalJSON() ([]byte, error) {\n\tresource.ResourceType = \"AppointmentResponse\"\n\t// Dereferencing the pointer to avoid infinite recursion.\n\t// Passing in plain old x (a pointer to AppointmentResponse), would cause this same\n\t// MarshallJSON function to be called again\n\treturn json.Marshal(*resource)\n}", "comment": ""}
{"lang": "cpp", "code": "def check_stripe_api_version(app_configs=None, **kwargs):\n\t\"\"\"\"\"\"\n\tfrom . import settings as djstripe_settings\n\n\tmessages = []\n\tdefault_version = djstripe_settings.DEFAULT_STRIPE_API_VERSION\n\tversion = djstripe_settings.get_stripe_api_version()\n\n\tif not validate_stripe_api_version(version):\n\t\tmsg = \"Invalid Stripe API version: {}\".format(version)\n\t\thint = \"STRIPE_API_VERSION should be formatted as: YYYY-MM-DD\"\n\t\tmessages.append(checks.Critical(msg, hint=hint, id=\"djstripe.C004\"))\n\n\tif version != default_version:\n\t\tmsg = (\n\t\t\t\"The Stripe API version has a non-default value of '{}'. \"\n\t\t\t\"Non-default versions are not explicitly supported, and may \"\n\t\t\t\"cause compatibility issues.\".format(version)\n\t\t)\n\t\thint = \"Use the dj-stripe default for Stripe API version: {}\".format(default_version)\n\t\tmessages.append(checks.Warning(msg, hint=hint, id=\"djstripe.W001\"))\n\n\treturn messages", "comment": ""}
{"lang": "cpp", "code": "def resume(self):\n        \n        for child in chain(self.consumers.values(), self.workers):\n            child.resume()", "comment": ""}
{"lang": "cpp", "code": "def successfuly_encodes(msg, raise_err=False):\n    \n    result = True\n    try:\n        msg.SerializeToString()\n    except EncodeError as encode_error:\n        if raise_err:\n            raise encode_error\n        result = False\n    return result", "comment": ""}
{"lang": "cpp", "code": "def floatize(self):\n        \"\"\"\"\"\"\n        self.x = float(self.x)\n        self.y = float(self.y)", "comment": ""}
{"lang": "cpp", "code": "protected function getErrorRoute(ServerRequestInterface $request, ResponseInterface $response)\n    {\n        if (\n            interface_exists('Jasny\\HttpMessage\\GlobalEnvironmentInterface') &&\n            $request instanceof GlobalEnvironmentInterface\n        ) {\n            $request = $request->withoutGlobalEnvironment();\n        }\n        \n        $status = $response->getStatusCode();\n        \n        $errorUri = $request->getUri()\n            ->withPath($status)\n            ->withQuery(null)\n            ->withFragment(null);\n        \n        return $this->router->getRoutes()->getRoute($request->withUri($errorUri));\n    }", "comment": ""}
{"lang": "cpp", "code": "public function withNano(int $nano) : LocalTime\n    {\n        if ($nano === $this->nano) {\n            return $this;\n        }\n\n        Field\\NanoOfSecond::check($nano);\n\n        return new LocalTime($this->hour, $this->minute, $this->second, $nano);\n    }", "comment": ""}
{"lang": "cpp", "code": "private function _validateLocalPart()\n    {\n        // First try to match the local part on the common dot-atom format\n        $result = false;\n\n        // Dot-atom characters are: 1*atext *(\".\" 1*atext)\n        // atext: ALPHA / DIGIT / and \"!\", \"#\", \"$\", \"%\", \"&\", \"'\", \"*\",\n        //        \"+\", \"-\", \"/\", \"=\", \"?\", \"^\", \"_\", \"`\", \"{\", \"|\", \"}\", \"~\"\n        $atext = 'a-zA-Z0-9\\x21\\x23\\x24\\x25\\x26\\x27\\x2a\\x2b\\x2d\\x2f\\x3d\\x3f\\x5e\\x5f\\x60\\x7b\\x7c\\x7d\\x7e';\n        if (preg_match('/^[' . $atext . ']+(\\x2e+[' . $atext . ']+)*$/', $this->_localPart)) {\n            $result = true;\n        } else {\n            // Try quoted string format\n\n            // Quoted-string characters are: DQUOTE *([FWS] qtext/quoted-pair) [FWS] DQUOTE\n            // qtext: Non white space controls, and the rest of the US-ASCII characters not\n            //   including \"\\\" or the quote character\n            $noWsCtl = '\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f';\n            $qtext   = $noWsCtl . '\\x21\\x23-\\x5b\\x5d-\\x7e';\n            $ws      = '\\x20\\x09';\n            if (preg_match('/^\\x22([' . $ws . $qtext . '])*[$ws]?\\x22$/', $this->_localPart)) {\n                $result = true;\n            } else {\n                $this->_error(self::DOT_ATOM);\n                $this->_error(self::QUOTED_STRING);\n                $this->_error(self::INVALID_LOCAL_PART);\n            }\n        }\n\n        return $result;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getClasses(): array {\n        $this->loadMetadata();\n        $ret = array();\n        foreach ($this->metadata->allResources('http://www.w3.org/1999/02/22-rdf-syntax-ns#type') as $i) {\n            $ret[] = $i->getUri();\n        }\n        return $ret;\n    }", "comment": ""}
{"lang": "cpp", "code": "def set_date_from_event(event, issue)\n      if event[\"commit_id\"].nil?\n        issue[\"actual_date\"] = issue[\"closed_at\"]\n      else\n        begin\n          commit = @fetcher.fetch_commit(event[\"commit_id\"])\n          issue[\"actual_date\"] = commit[\"commit\"][\"author\"][\"date\"]\n\n          # issue['actual_date'] = commit['author']['date']\n        rescue StandardError\n          puts \"Warning: Can't fetch commit #{event['commit_id']}. It is probably referenced from another repo.\"\n          issue[\"actual_date\"] = issue[\"closed_at\"]\n        end\n      end\n    end", "comment": ""}
{"lang": "cpp", "code": "func (s *DescribeUserStackAssociationsInput) SetUserName(v string) *DescribeUserStackAssociationsInput {\n\ts.UserName = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "function breakLines(tokens, maxWidth) {\n    if (!maxWidth) {\n        maxWidth = Infinity;\n    }\n    let i = 0;\n    let lineLength = 0;\n    let lastTokenWithSpace = -1;\n    while (i < tokens.length) { /* take all text tokens, remove space, apply linebreaks */\n        let token = tokens[i];\n        if (token.type == TYPE_NEWLINE) { /* reset */\n            lineLength = 0;\n            lastTokenWithSpace = -1;\n        }\n        if (token.type != TYPE_TEXT) { /* skip non-text tokens */\n            i++;\n            continue;\n        }\n        /* remove spaces at the beginning of line */\n        while (lineLength == 0 && token.value.charAt(0) == \" \") {\n            token.value = token.value.substring(1);\n        }\n        /* forced newline? insert two new tokens after this one */\n        let index = token.value.indexOf(\"\\n\");\n        if (index != -1) {\n            token.value = breakInsideToken(tokens, i, index, true);\n            /* if there are spaces at the end, we must remove them (we do not want the line too long) */\n            let arr = token.value.split(\"\");\n            while (arr.length && arr[arr.length - 1] == \" \") {\n                arr.pop();\n            }\n            token.value = arr.join(\"\");\n        }\n        /* token degenerated? */\n        if (!token.value.length) {\n            tokens.splice(i, 1);\n            continue;\n        }\n        if (lineLength + token.value.length > maxWidth) { /* line too long, find a suitable breaking spot */\n            /* is it possible to break within this token? */\n            let index = -1;\n            while (1) {\n                let nextIndex = token.value.indexOf(\" \", index + 1);\n                if (nextIndex == -1) {\n                    break;\n                }\n                if (lineLength + nextIndex > maxWidth) {\n                    break;\n                }\n                index = nextIndex;\n            }\n            if (index != -1) { /* break at space within this one */\n                token.value = breakInsideToken(tokens, i, index, true);\n            }\n            else if (lastTokenWithSpace != -1) { /* is there a previous token where a break can occur? */\n                let token = tokens[lastTokenWithSpace];\n                let breakIndex = token.value.lastIndexOf(\" \");\n                token.value = breakInsideToken(tokens, lastTokenWithSpace, breakIndex, true);\n                i = lastTokenWithSpace;\n            }\n            else { /* force break in this token */\n                token.value = breakInsideToken(tokens, i, maxWidth - lineLength, false);\n            }\n        }\n        else { /* line not long, continue */\n            lineLength += token.value.length;\n            if (token.value.indexOf(\" \") != -1) {\n                lastTokenWithSpace = i;\n            }\n        }\n        i++; /* advance to next token */\n    }\n    tokens.push({ type: TYPE_NEWLINE }); /* insert fake newline to fix the last text line */\n    /* remove trailing space from text tokens before newlines */\n    let lastTextToken = null;\n    for (let i = 0; i < tokens.length; i++) {\n        let token = tokens[i];\n        switch (token.type) {\n            case TYPE_TEXT:\n                lastTextToken = token;\n                break;\n            case TYPE_NEWLINE:\n                if (lastTextToken) { /* remove trailing space */\n                    let arr = lastTextToken.value.split(\"\");\n                    while (arr.length && arr[arr.length - 1] == \" \") {\n                        arr.pop();\n                    }\n                    lastTextToken.value = arr.join(\"\");\n                }\n                lastTextToken = null;\n                break;\n        }\n    }\n    tokens.pop(); /* remove fake token */\n    return tokens;\n}", "comment": ""}
{"lang": "cpp", "code": "public function getMemberAttribute()\n    {\n        $guild = $this->discord->guilds->get('id', $this->guild_id);\n\n        return $guild->members->get('id', $this->user_id);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function find_subcommand( &$args ) {\n\t\t$name = array_shift( $args );\n\n\t\t$subcommands = $this->get_subcommands();\n\n\t\tif ( ! isset( $subcommands[ $name ] ) ) {\n\t\t\t$aliases = self::get_aliases( $subcommands );\n\n\t\t\tif ( isset( $aliases[ $name ] ) ) {\n\t\t\t\t$name = $aliases[ $name ];\n\t\t\t}\n\t\t}\n\n\t\tif ( ! isset( $subcommands[ $name ] ) ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn $subcommands[ $name ];\n\t}", "comment": ""}
{"lang": "cpp", "code": "public function savePreviousVersion($version)\n    {\n        if (!is_numeric($version)) {\n            return;\n        }\n\n        try {\n            $this->setVersionNumber($version);\n            $this->owner->write();\n        } catch (Exception $e) {\n            throw new ValidationException(new ValidationResult(\n                false,\n                \"Could not replace file #{$this->owner->ID} with version #$version.\"\n            ));\n        }\n    }", "comment": ""}
{"lang": "cpp", "code": "protected function _initialize(AnConfig $config)\n    {\n        $config->append(array(\n            'name' => 'google',\n            'version' => '3',\n            'url' => 'https://maps.googleapis.com/maps/api/geocode/json?',\n            'key' => get_config_value('locations.api_key', null)\n        ));\n\n        parent::_initialize($config);\n    }", "comment": ""}
{"lang": "cpp", "code": "@Deprecated\n\tvoid add(final WComponent component, final String tag) {\n\t\tadd(component);\n\t\tcomponent.setTag(tag);\n\t}", "comment": ""}
{"lang": "cpp", "code": "function useMain (mdFile, swagger) {\n  const mainOpts = {\n    position: argv.position,\n    title: argv.title\n  }\n  opts.yaml ? mainOpts.yaml = true : mainOpts.json = true\n\n  fs.readFile(mdFile, { encoding: 'utf8' }, function (err, md) {\n    assert.ifError(err)\n    const compiled = remark()\n      .use(main(swagger, mainOpts))\n      .process(md)\n\n    const rs = fromString(compiled)\n    const ws = argv.w ? fs.createWriteStream(mdFile) : stdout\n    pump(rs, ws, handleErr)\n  })\n}", "comment": ""}
{"lang": "cpp", "code": "public function addChild($child, array $options = array())\n    {\n        $child->setParent($this);\n\n        $this->children[$child->getName()] = $child;\n\n        return $child;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function getDefaultDb(): ?ConnectionInterface\n    {\n        // By default, the DB Facade does not return the\n        // any actual database connection, but rather an\n        // instance of \\Illuminate\\Database\\DatabaseManager.\n        // Therefore, we make sure only to obtain its\n        // \"connection\", to make sure that its only the connection\n        // instance that we obtain.\n        $manager = DB::getFacadeRoot();\n        if (isset($manager)) {\n            return $manager->connection();\n        }\n        return $manager;\n    }", "comment": ""}
{"lang": "cpp", "code": "public function set_html($source, $from_file = false)\n    {\n        if ($from_file && file_exists($source)) {\n            $this->html = file_get_contents($source);\n        } else {\n            $this->html = $source;\n        }\n\n        $this->_converted = false;\n    }", "comment": ""}
{"lang": "cpp", "code": "protected static function deleteMarks(string $input): string\n    {\n        return preg_replace(\n            '/\\\\p{M}+/u',\n            '',\n            \\Normalizer::normalize($input, \\Normalizer::FORM_KD)\n        );\n    }", "comment": ""}
{"lang": "cpp", "code": "def command_update(prog_name, prof_mgr, prof_name, prog_args):\n\n\t\n\t\n\t# Retrieve arguments\n\tparser = argparse.ArgumentParser(\n\t\tprog=prog_name\n\t)\n\tparser.add_argument(\n\t\t\"components\",\n\t\tmetavar=\"comps\",\n\t\tnargs=argparse.REMAINDER,\n\t\thelp=\"system components\"\n\t)\n\targs = parser.parse_args(prog_args)\n\t\n\t# Profile load\n\tprof_stub = prof_mgr.load(prof_name)\n\t\n\t# Collect component stubs\n\tcomp_stubs = []\n\tif len(args.components) == 0:\n\t\traise Exception(\"Empty component list\")\n\tfor comp_name in args.components:\n\t\tcomp_stub = prof_stub.component(comp_name)\n\t\tcomponent_exists(prof_stub, comp_stub)\n\t\tcomp_stubs.append(comp_stub)\n\t\t\n\tcontext = prof_stub.context()\n\t\n\t# Create delete plan\n\tplan = []\n\tfor comp_stub in comp_stubs:\n\t\tcomp_stub.delete(context, plan)\n\t\t\n\t# Execute delete plan\n\tfor op in plan:\n\t\toperation_execute(op, context)\n\t\t\n\t# Update component stub list\n\tfor op in plan:\n\t\tcomp_stub = prof_stub.component(op.name())\n\t\tif comp_stub not in comp_stubs:\n\t\t\tcomp_stubs.append(comp_stub)\n\t\n\t# Create insert plan\n\tplan = []\n\tfor comp_stub in comp_stubs:\n\t\tcomp_stub.insert(context, plan)\n\t\t\n\t# Execute insert plan\n\tfor op in plan:\n\t\toperation_execute(op, context)", "comment": ""}
{"lang": "cpp", "code": "public static function pad(string $input, int $length, string $string = ' ', int $type = STR_PAD_RIGHT): string\n    {\n        $diff = strlen($input) - mb_strlen($input, 'utf-8');\n\n        return str_pad($input, $length + $diff, $string, $type);\n    }", "comment": ""}
{"lang": "cpp", "code": "public function createDraftFromCurrentVersion($contentId)\n    {\n        $contentInfo = $this->repository->getContentService()->loadContentInfo($contentId);\n        $contentType = $this->repository->getContentTypeService()->loadContentType($contentInfo->contentTypeId);\n        $versionInfo = $this->repository->getContentService()->loadVersionInfo(\n            $contentInfo\n        );\n\n        if ($versionInfo->isDraft()) {\n            throw new ForbiddenException('Current version is already in status DRAFT');\n        }\n\n        $contentDraft = $this->repository->getContentService()->createContentDraft($contentInfo);\n\n        return new Values\\CreatedVersion(\n            array(\n                'version' => new Values\\Version(\n                    $contentDraft,\n                    $contentType,\n                    $this->repository->getContentService()->loadRelations($contentDraft->getVersionInfo())\n                ),\n            )\n        );\n    }", "comment": ""}
{"lang": "cpp", "code": "public function setName(string $name): \\RolesCapabilities\\Capability\n    {\n        if (empty($name)) {\n            throw new InvalidArgumentException(\"Name cannot be empty\");\n        }\n        $this->name = $name;\n\n        return $this;\n    }", "comment": ""}
{"lang": "cpp", "code": "func (s *Socket) Recv() (parts [][]byte, err error) {\n\tparts = make([][]byte, 0)\n\tfor more := true; more; {\n\t\tvar part []byte\n\t\tif part, more, err = s.RecvPart(); err != nil {\n\t\t\treturn\n\t\t}\n\t\tparts = append(parts, part)\n\t}\n\treturn\n}", "comment": ""}
{"lang": "cpp", "code": "def _alerter_thread_func(self) -> None:\n        \n\n        self._alert_count = 0\n        self._next_alert_time = 0\n\n        while not self._stop_thread:\n            # Always acquire terminal_lock before printing alerts or updating the prompt\n            # To keep the app responsive, do not block on this call\n            if self.terminal_lock.acquire(blocking=False):\n\n                # Get any alerts that need to be printed\n                alert_str = self._generate_alert_str()\n\n                # Generate a new prompt\n                new_prompt = self._generate_colored_prompt()\n\n                # Check if we have alerts to print\n                if alert_str:\n                    # new_prompt is an optional parameter to async_alert()\n                    self.async_alert(alert_str, new_prompt)\n                    new_title = \"Alerts Printed: {}\".format(self._alert_count)\n                    self.set_window_title(new_title)\n\n                # No alerts needed to be printed, check if the prompt changed\n                elif new_prompt != self.prompt:\n                    self.async_update_prompt(new_prompt)\n\n                # Don't forget to release the lock\n                self.terminal_lock.release()\n\n            time.sleep(0.5)", "comment": ""}
{"lang": "cpp", "code": "func (l logf) Warningf(s string, args ...interface{}) {\n\tl.log.Warning(s, args...)\n}", "comment": ""}
{"lang": "cpp", "code": "def get_instance(self, payload):\n        \n        return TodayInstance(self._version, payload, account_sid=self._solution['account_sid'], )", "comment": ""}
{"lang": "cpp", "code": "func (s *CreateUserInput) SetAuthenticationToken(v string) *CreateUserInput {\n\ts.AuthenticationToken = &v\n\treturn s\n}", "comment": ""}
{"lang": "cpp", "code": "func (e *EnumDescriptor) prefix() string {\n\ttypeName := e.alias()\n\tif e.parent == nil {\n\t\t// If the enum is not part of a message, the prefix is just the type name.\n\t\treturn CamelCase(typeName[len(typeName)-1]) + \"_\"\n\t}\n\treturn CamelCaseSlice(typeName[0:len(typeName)-1]) + \"_\"\n}", "comment": ""}
{"lang": "cpp", "code": "function (id) {\n    var o = this.options;\n    return path.resolve(o.root, o.viewsDir, id, \"template\" + o.extension);\n  }", "comment": ""}
{"lang": "cpp", "code": "def convertbits(data, frombits, tobits, pad=True):\n    \"\"\"\"\"\"\n    acc = 0\n    bits = 0\n    ret = []\n    maxv = (1 << tobits) - 1\n    max_acc = (1 << (frombits + tobits - 1)) - 1\n    for value in data:\n        if value < 0 or (value >> frombits):\n            return None\n        acc = ((acc << frombits) | value) & max_acc\n        bits += frombits\n        while bits >= tobits:\n            bits -= tobits\n            ret.append((acc >> bits) & maxv)\n    if pad:\n        if bits:\n            ret.append((acc << (tobits - bits)) & maxv)\n    elif bits >= frombits or ((acc << (tobits - bits)) & maxv):\n        return None\n    return ret", "comment": ""}
{"lang": "cpp", "code": "protected function addNewWords($allWords)\r\n    {\r\n        try {\r\n            $newWords = $allWords;\r\n            $query = (new Query())->from(Vocabulary::tableName())->where(['word' => $allWords]);\r\n            foreach ($query->each() as $vocabularyFound) {\r\n                if (($key = array_search($vocabularyFound['word'], $allWords)) !== false) {\r\n                    unset($newWords[$key]);\r\n                }\r\n            }\r\n            $formatWords = [];\r\n            foreach ($newWords as $word) {\r\n                $formatWords[] = [$word];\r\n            }\r\n            if (!empty($formatWords)) {\r\n                if (!Podium::getInstance()->db->createCommand()->batchInsert(\r\n                        Vocabulary::tableName(), ['word'], $formatWords\r\n                    )->execute()) {\r\n                    throw new Exception('Words saving error!');\r\n                }\r\n            }\r\n        } catch (Exception $e) {\r\n            Log::error($e->getMessage(), null, __METHOD__);\r\n            throw $e;\r\n        }\r\n    }", "comment": ""}
